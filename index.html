  const derezEffects = [];
  const celliDerezState = { active: false, lastY: null };
  let derezParticleGeometry = null;
      state.presentActive = !!state.settings.enabled;
      FancyGraphics.decor.visible = FancyGraphics.settings.waveGrid || FancyGraphics.settings.mirror || FancyGraphics.settings.solidGround || FancyGraphics.settings.lights;
        const decorActive = FancyGraphics.enabled && (FancyGraphics.settings.waveGrid || FancyGraphics.settings.solidGround || FancyGraphics.settings.mirror || FancyGraphics.settings.lights);

  function triggerCelliDerez(worldPos){
    if(!scene || !THREE || celliDerezState.active) return;
    try{
      const base = new THREE.Group();
      const px = Number.isFinite(worldPos?.x) ? worldPos.x : 0;
      const py = Number.isFinite(worldPos?.y) ? worldPos.y : 0;
      const pz = Number.isFinite(worldPos?.z) ? worldPos.z : 0;
      base.position.set(px, py + 0.4, pz);

      const layout = [
        { size: [0.36, 0.48, 0.28], offset: [0, -0.05, 0], color: 0xf59e0b },
        { size: [0.32, 0.24, 0.24], offset: [0, 0.32, 0], color: 0xfcd34d },
        { size: [0.08, 0.08, 0.05], offset: [-0.1, 0.36, 0.12], color: 0x1f2937 },
        { size: [0.08, 0.08, 0.05], offset: [0.1, 0.36, 0.12], color: 0x1f2937 },
        { size: [0.14, 0.06, 0.05], offset: [0, 0.26, 0.13], color: 0x1f2937 },
        { size: [0.08, 0.06, 0.05], offset: [-0.16, 0.3, 0.12], color: 0xec4899 },
        { size: [0.08, 0.06, 0.05], offset: [0.16, 0.3, 0.12], color: 0xec4899 },
        { size: [0.36, 0.08, 0.12], offset: [0, 0.5, 0], color: 0xfcd34d },
        { size: [0.16, 0.12, 0.08], offset: [-0.24, 0.5, 0], color: 0xf59e0b },
        { size: [0.16, 0.12, 0.08], offset: [0.24, 0.5, 0], color: 0xf59e0b },
        { size: [0.12, 0.4, 0.12], offset: [-0.26, -0.2, 0], color: 0xf59e0b },
        { size: [0.12, 0.4, 0.12], offset: [0.26, -0.2, 0], color: 0xf59e0b },
        { size: [0.12, 0.24, 0.12], offset: [-0.12, -0.46, 0], color: 0xf59e0b },
        { size: [0.12, 0.24, 0.12], offset: [0.12, -0.46, 0], color: 0xf59e0b }
      ];

      const voxels = [];
      const boundsMin = new THREE.Vector3(Infinity, Infinity, Infinity);
      const boundsMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

      layout.forEach(part=>{
        const geo = new THREE.BoxGeometry(part.size[0], part.size[1], part.size[2]);
        const mat = new THREE.MeshStandardMaterial({
          color: part.color,
          emissive: new THREE.Color(part.color),
          emissiveIntensity: 0.2,
          transparent: true,
          opacity: 1,
          depthWrite: false
        });
        mat.toneMapped = false;
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(part.offset[0], part.offset[1], part.offset[2]);
        base.add(mesh);
        voxels.push({ mesh, geometry: geo, material: mat });

        const half = new THREE.Vector3(part.size[0] / 2, part.size[1] / 2, part.size[2] / 2);
        boundsMin.x = Math.min(boundsMin.x, mesh.position.x - half.x);
        boundsMin.y = Math.min(boundsMin.y, mesh.position.y - half.y);
        boundsMin.z = Math.min(boundsMin.z, mesh.position.z - half.z);
        boundsMax.x = Math.max(boundsMax.x, mesh.position.x + half.x);
        boundsMax.y = Math.max(boundsMax.y, mesh.position.y + half.y);
        boundsMax.z = Math.max(boundsMax.z, mesh.position.z + half.z);
      });

      const glow = new THREE.PointLight(0xfcd34d, 0, 3.5, 2);
      glow.position.set(0, 0.45, 0);
      base.add(glow);

      scene.add(base);

      derezEffects.push({
        group: base,
        voxels,
        bounds: { min: boundsMin, max: boundsMax },
        particles: [],
        light: glow,
        stage: 'glow',
        stageTime: 0,
        totalTime: 0
      });

      celliDerezState.active = true;
      if(celli){ celli.visible = false; }
      if(arrayaAvatar){ arrayaAvatar.setVisible(false); }
      needsRender = true;
    }catch(e){
      console.warn('Failed to trigger Celli derez effect', e);
      celliDerezState.active = false;
      if(celli){ celli.visible = true; }
    }
  }

  function cleanupDerezEffect(effect){
    if(!effect) return;
    try{
      if(effect.particles){
        effect.particles.forEach(p=>{
          if(p?.mesh){
            effect.group?.remove(p.mesh);
            try{ p.material?.dispose?.(); }catch{}
          }
        });
        effect.particles.length = 0;
      }
      if(effect.light){
        try{ effect.group?.remove(effect.light); }catch{}
      }
      if(effect.group){
        try{ scene.remove(effect.group); }catch{}
      }
    }catch(e){
      console.warn('Failed to cleanup derez effect', e);
    }
    effect.voxels = [];
    celliDerezState.active = false;
    if(celli){ celli.visible = true; }
    if(arrayaAvatar){ arrayaAvatar.setVisible(false); }
    needsRender = true;
  }

  function updateDerezEffects(deltaMs){
    if(!derezEffects.length) return;
    const deltaSec = deltaMs / 1000;
    for(let i = derezEffects.length - 1; i >= 0; i--){
      const effect = derezEffects[i];
      if(!effect) continue;
      effect.stageTime += deltaMs;
      effect.totalTime += deltaMs;
      needsRender = true;

      if(effect.stage === 'glow'){
        const glowT = Math.min(1, effect.stageTime / 350);
        const pulse = 0.94 + 0.08 * Math.sin(glowT * Math.PI);
        effect.voxels.forEach(v=>{
          if(!v?.mesh || !v.material) return;
          v.mesh.scale.set(pulse, pulse, pulse);
          v.material.emissiveIntensity = 0.6 + 1.8 * glowT;
          v.material.opacity = 1;
        });
        if(effect.light){
          effect.light.intensity = THREE.MathUtils.lerp(0, 3.2, glowT);
        }
        if(effect.stageTime >= 350){
          effect.stage = 'burst';
          effect.stageTime = 0;
          if(effect.light){ effect.light.intensity = 0; }
          if(!derezParticleGeometry){
            derezParticleGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.08);
          }
          const colorPool = effect.voxels.map(v=>v.material?.color?.getHex?.() ?? 0xf59e0b);
          const particleCount = Math.max(24, colorPool.length * 6);
          const bounds = effect.bounds;
          effect.voxels.forEach(v=>{
            if(!v) return;
            if(v.mesh){
              effect.group?.remove(v.mesh);
            }
            try{ v.geometry?.dispose?.(); }catch{}
            try{ v.material?.dispose?.(); }catch{}
          });
          effect.voxels = [];
          effect.particles = [];
          for(let j = 0; j < particleCount; j++){
            const colorHex = colorPool[j % colorPool.length];
            const material = new THREE.MeshStandardMaterial({
              color: colorHex,
              emissive: new THREE.Color(colorHex),
              emissiveIntensity: 1.3,
              transparent: true,
              opacity: 1,
              depthWrite: false
            });
            material.toneMapped = false;
            const particle = new THREE.Mesh(derezParticleGeometry, material);
            const rx = THREE.MathUtils.lerp(bounds.min.x, bounds.max.x, Math.random());
            const ry = THREE.MathUtils.lerp(bounds.min.y, bounds.max.y, Math.random());
            const rz = THREE.MathUtils.lerp(bounds.min.z, bounds.max.z, Math.random());
            particle.position.set(rx, ry, rz);
            particle.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            effect.group.add(particle);
            effect.particles.push({
              mesh: particle,
              material,
              velocity: new THREE.Vector3((Math.random()-0.5)*2.2, Math.random()*2.4 + 1.8, (Math.random()-0.5)*2.2),
              spin: new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4)
            });
          }
        }
      } else if(effect.stage === 'burst'){
        const fade = Math.min(1, effect.stageTime / 700);
        if(effect.particles){
          effect.particles.forEach(p=>{
            if(!p?.mesh || !p.material) return;
            p.velocity.y -= 6 * deltaSec;
            p.velocity.x *= 0.97;
            p.velocity.z *= 0.97;
            p.mesh.position.addScaledVector(p.velocity, deltaSec);
            p.mesh.rotation.x += p.spin.x * deltaSec;
            p.mesh.rotation.y += p.spin.y * deltaSec;
            p.mesh.rotation.z += p.spin.z * deltaSec;
            const life = Math.max(0, 1 - fade);
            p.material.opacity = life;
            p.material.emissiveIntensity = 1.3 * life;
            p.mesh.scale.setScalar(THREE.MathUtils.lerp(1, 0.6, fade));
          });
        }
        if(effect.stageTime >= 700){
          cleanupDerezEffect(effect);
          derezEffects.splice(i, 1);
          continue;
        }
      }
    }
  }
    const deltaRaw = lastFrame ? (time - lastFrame) : 16;
    if(deltaRaw < 16){ __rafId = requestAnimationFrame(animate); return; }
    const deltaMs = Math.min(64, deltaRaw);
      Scene.updateDeleteEffects?.(deltaMs);
      updateDerezEffects(deltaMs);
      let oceanDt = deltaMs / 1000;
            let respawned = false;
            const prevY = celliDerezState.lastY;
            const crossedZero = (prevY != null && prevY > 0 && p.y < 0);
            if(p.y < 0){
              if(crossedZero && !celliDerezState.active){
                triggerCelliDerez({ x: p.x, y: 0, z: p.z });
              }
              if(respawnPos){
                console.log('[PHYSICS] Fell off world, respawning at spawn point');
                playerBody.setTranslation(respawnPos, true);
                playerBody.setLinvel({x: 0, y: 0, z: 0}, true);
                cachedPlayerPos.set(respawnPos.x, respawnPos.y, respawnPos.z);
                jumpVelocity = 0;
                landingSquashTime = 0;
                wasGroundedLastFrame = false;
                lastLandKey = null;
                respawned = true;
                celliDerezState.lastY = null;
              }
            }
            if(!respawned){
              celliDerezState.lastY = cachedPlayerPos.y;
            }
            if(!respawned){

      oceanDt = dtFancy || oceanDt;
    OceanBackdrop.update(oceanDt);



    if(celliDerezState.active){
      if(celli) celli.visible = false;
      if(arrayaAvatar) arrayaAvatar.setVisible(false);
      return;
    }

    if(!physicsMode){
      celliDerezState.lastY = null;
    }

