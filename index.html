.ocean-note{position:fixed;left:16px;top:16px;z-index:10003;background:rgba(5,25,45,.35);border:1px solid rgba(170,220,255,.25);padding:8px 12px;border-radius:12px;font-size:12px;font-weight:600;color:#cfe9ff;text-shadow:0 1px 0 #001;display:none;pointer-events:none}
.ocean-err{position:fixed;left:16px;bottom:16px;z-index:10003;background:#240f12;color:#ffd2d2;border:1px solid #ff5a6a;padding:10px 12px;border-radius:10px;font-weight:600;font-size:12px;line-height:1.3;max-width:320px;display:none;pointer-events:none;box-shadow:0 8px 24px rgba(0,0,0,0.35)}
      <label class="stack" style="gap:4px;">
        <span class="sub">Near Fade <span id="oceanNearFadeValue"></span></span>
        <input type="range" id="oceanNearFade" min="0" max="200" step="1">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Far Fade <span id="oceanFarFadeValue"></span></span>
        <input type="range" id="oceanFarFade" min="50" max="600" step="1">
      </label>
    nearFade:20.0,
    farFade:200.0,
    const DEFAULT_ENV_INTENSITY = OceanDefaults.envIntensity || 1;
      lastSize:{w:0,h:0},
      ui:{note:null, err:null},
      watchdog:null,
      drewOnce:false,
      fallbackActive:false,
      fallbackScene:null,
      fallbackCamera:null,
      fallbackMesh:null
    function ensureUI(){
      if(state.ui.note && state.ui.err) return;
      const note = document.createElement('div');
      note.className = 'ocean-note';
      note.textContent = 'Ocean backdrop active — adjust via Ocean Backdrop panel.';
      note.style.display = 'none';
      document.body.appendChild(note);
      const err = document.createElement('div');
      err.className = 'ocean-err';
      err.style.display = 'none';
      document.body.appendChild(err);
      state.ui.note = note;
      state.ui.err = err;
    }

    function setNoteVisible(flag){
      ensureUI();
      state.ui.note.style.display = flag ? 'block' : 'none';
    }

    function showError(msg){
      ensureUI();
      state.ui.err.textContent = msg;
      state.ui.err.style.display = 'block';
    }

    function hideError(){
      if(state.ui.err) state.ui.err.style.display = 'none';
    }

    function clearWatchdog(){
      if(state.watchdog){
        clearTimeout(state.watchdog);
        state.watchdog = null;
      }
    }

    function resetWatchdog(){
      clearWatchdog();
      state.drewOnce = false;
      if(state.fallbackActive) return;
      state.watchdog = setTimeout(()=>{
        if(!state.drewOnce){
          triggerFallback('Watchdog: no ocean frame in 2s → showing fallback view.');
        }
      }, 2000);
    }

    function envIntensityScale(){
      const base = DEFAULT_ENV_INTENSITY > 0 ? DEFAULT_ENV_INTENSITY : 1;
      return base > 0 ? state.settings.envIntensity / base : state.settings.envIntensity;
    }

    function applyEmissiveScale(){
      const scale = envIntensityScale();
      if(state.ball && state.ball.material && state.ball.material.emissiveIntensity !== undefined){
        const base = state.ball.userData?.baseEmissiveIntensity ?? state.ball.material.emissiveIntensity;
        state.ball.material.emissiveIntensity = base * scale;
      }
      state.floaters.forEach(item=>{
        if(item.mesh && item.mesh.material && item.mesh.material.emissiveIntensity !== undefined){
          const base = item.baseEmissiveIntensity ?? item.mesh.userData?.baseEmissiveIntensity ?? item.mesh.material.emissiveIntensity;
          item.mesh.material.emissiveIntensity = base * scale;
        }
        if(item.light){
          const baseLight = item.baseLightIntensity ?? item.light.userData?.baseIntensity ?? item.light.intensity;
          item.light.intensity = baseLight * scale;
        }
      });
    }

    function markFrameDrawn(){
      state.drewOnce = true;
      clearWatchdog();
      if(state.fallbackActive){
        disableFallback();
      } else {
        hideError();
      }
    }

    function disableFallback(){
      if(!state.fallbackActive) return;
      state.fallbackActive = false;
      state.fallbackScene = null;
      state.fallbackCamera = null;
      state.fallbackMesh = null;
      hideError();
      setNoteVisible(state.presentActive);
    }

    function triggerFallback(message){
      if(state.fallbackActive) return;
      ensureCanvas();
      ensureUI();
      showError(message || 'Ocean backdrop unavailable — fallback engaged.');
      setNoteVisible(false);
      try{ ensureRenderer(); }catch(e){ showError(`Fallback init failed: ${e.message||e}`); return; }
      clearWatchdog();
      if(!state.renderer) return;
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1a2a);
      const cam = new THREE.PerspectiveCamera(60, window.innerWidth / Math.max(1, window.innerHeight), 0.1, 100);
      cam.position.set(2.2, 1.4, 2.2);
      const amb = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(amb);
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshStandardMaterial({ color:0x8fd0ff, roughness:0.2 })
      );
      scene.add(mesh);
      state.fallbackScene = scene;
      state.fallbackCamera = cam;
      state.fallbackMesh = mesh;
      state.fallbackActive = true;
      const renderer = state.renderer;
      const loop = ()=>{
        if(!state.fallbackActive) return;
        requestAnimationFrame(loop);
        try{
          mesh.rotation.x += 0.01;
          mesh.rotation.y += 0.013;
          cam.aspect = window.innerWidth / Math.max(1, window.innerHeight);
          cam.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, cam);
        }catch(err){
          showError(`Fallback error: ${err.message||err}`);
          state.fallbackActive = false;
        }
      };
      loop();
    }

      ensureUI();
        nearFade:{value:state.settings.nearFade},
        farFade:{value:state.settings.farFade},
      ball.userData.baseEmissiveIntensity = ball.material.emissiveIntensity ?? 1.05;
        mesh.userData.baseEmissiveIntensity = glow;
        floaters.push({
          mesh,
          light,
          floatSpeed:THREE.MathUtils.randFloat(0.3,0.7),
          floatOffset:Math.random()*Math.PI*2,
          baseEmissiveIntensity: glow,
          baseLightIntensity: intensity
        });
      applyEmissiveScale();
      const envScale = envIntensityScale();
          if(item.mesh.material && item.mesh.material.emissiveIntensity !== undefined){
            const baseEmissive = item.baseEmissiveIntensity ?? item.mesh.userData?.baseEmissiveIntensity ?? item.mesh.material.emissiveIntensity;
            item.mesh.material.emissiveIntensity = baseEmissive * envScale;
          }
          const baseIntensity = item.baseLightIntensity ?? item.light.userData?.baseIntensity ?? item.light.intensity;
          item.light.intensity = baseIntensity * envScale * pulse;
        if(state.post && state.post.compMat && state.post.compMat.uniforms){
          state.post.compMat.uniforms.camNear.value = state.camera.near;
          state.post.compMat.uniforms.camFar.value = state.camera.far;
        }
      if(state.post.raysMat && state.post.raysMat.uniforms){
        state.post.raysMat.uniforms.rayDecay.value = PP.rayDecay;
        state.post.raysMat.uniforms.rayExposure.value = PP.rayExposure;
      }
      if(state.post.lighthouseMat && state.post.lighthouseMat.uniforms){
        const count = state.settings.enableLighthouse
          ? Math.min(state.lighthousePositions.length, 4)
          : 0;
        state.post.lighthouseMat.uniforms.lighthouseCount.value = count;
      }
      if(state.scene && state.scene.fog){
        state.scene.fog.color.set(state.settings.fogColor);
      }
        state.waterUniforms.nearFade.value = state.settings.nearFade;
        state.waterUniforms.farFade.value = state.settings.farFade;
      applyEmissiveScale();
      const lighthouseCount = state.settings.enableLighthouse
        ? Math.min(state.lighthousePositions.length, 4)
        : 0;
      post.lighthouseMat.uniforms.lighthouseCount.value = lighthouseCount;
      for(let i=0;i<lighthouseCount;i++){
      for(let i=lighthouseCount;i<4;i++){
        post.lighthouseMat.uniforms.lighthousePos.value[i].set(-1, -1, 1);
      }
      markFrameDrawn();
        setNoteVisible(false);
        clearWatchdog();
        disableFallback();
        hideError();
      const prev = state.presentActive;
      setNoteVisible(state.presentActive);
      if(state.presentActive && !prev){
        resetWatchdog();
      }
      if(!state.presentActive){
        clearWatchdog();
        disableFallback();
        hideError();
      }
      if(state.presentActive){
        applyEmissiveScale();
      }
    nearFade: document.getElementById('oceanNearFade'),
    farFade: document.getElementById('oceanFarFade'),
    nearFade: document.getElementById('oceanNearFadeValue'),
    farFade: document.getElementById('oceanFarFadeValue'),
    nearFade: (v)=>`${Math.round(Number(v)||0)}m`,
    farFade: (v)=>`${Math.round(Number(v)||0)}m`,
    'foamAmount','foamBias','foamScale','nearFade','farFade','maxGloss','roughnessScale',
