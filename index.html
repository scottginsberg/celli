<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />

<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Celli</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Rubik:wght@400;600;800&family=Roboto+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<!-- Twemoji for consistent emoji rendering -->
<script src="https://unpkg.com/twemoji@latest/dist/twemoji.min.js"></script>
<!-- TanStack Virtual for 2D sheet virtualization -->
<script src="https://unpkg.com/@tanstack/virtual-core@latest/dist/index.umd.js"></script>
<style>
:root{
  /* Reference palette */
  --bg:#f0f2f5; --ink:#1f2937; --muted:#5b6170; --panel:#ffffff; --line:#e5e7eb;
  --accent:#3b82f6; --accent-2:#22c55e; --accent-3:#f59e0b; --chip:#eef2ff;
  --shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
}
/* Background world gradient + optional spiral intensifier */
#world{ position:fixed; inset:0; background:radial-gradient(1200px 800px at 20% 10%, #93c5fd 0, transparent 70%), linear-gradient(135deg,#1e3a8a 0%,#3b82f6 50%,#93c5fd 100%); pointer-events:none; z-index:0 }
#world::after{ content:""; position:absolute; inset:-10%; opacity:0; pointer-events:none; mix-blend-mode:screen; background:conic-gradient(from 0deg at 50% 50%, rgba(59,130,246,.00) 0%, rgba(59,130,246,.08) 10%, rgba(147,197,253,.06) 20%, transparent 30%, rgba(59,130,246,.08) 40%, transparent 55%, rgba(147,197,253,.06) 70%, transparent 85%, rgba(59,130,246,.08) 100%); transform-origin:center; }
@keyframes swirl{ to{ transform:rotate(360deg); } }
.spiral #world::after{ opacity:.7; animation:swirl 8s linear infinite; }

/* Narrative icons */
.ui-icon{ position:fixed; width:50px; height:50px; background:#1f2937; border-radius:10px; box-shadow:var(--shadow); display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:10002; transition:transform .2s ease; color:#e5e7eb; }
.ui-icon:hover{ transform:scale(1.1); }
.ui-icon svg{ pointer-events:none; }
#terminal-icon{ bottom:24px; right:24px; }
#notepad-icon{ bottom:108px; right:24px; }

/* Narrative windows */
#terminal{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:90vw; max-width:700px; height:460px; background:rgba(17,24,39,.95); border:1px solid rgba(255,255,255,.12); border-radius:12px; box-shadow:0 25px 50px -12px rgb(0 0 0 / .5); z-index:10002; display:none; flex-direction:column; color:#e5e7eb; font-family:'Roboto Mono',monospace; }
.win-header{ background:rgba(255,255,255,.06); padding:8px 12px; border-bottom:1px solid rgba(255,255,255,.12); display:flex; justify-content:space-between; align-items:center; user-select:none; cursor:move; }
.close{ width:20px; height:20px; background:#ef4444; border-radius:50%; cursor:pointer; }
#term{ flex-grow:1; padding:12px; overflow-y:auto; white-space:pre-wrap; word-break:break-word; overflow-wrap:break-word; line-height:1.35; }
#term .cursor::after{ content:'█'; animation:blink .8s step-end infinite; }
#term .underscore::after{ content:'_'; animation:blink .75s step-end infinite; }
@keyframes blink{ 50%{ opacity:0; } }
/* Lanes for multi-processing thoughts */
#term .lane-wrap{ display:flex; gap:10px; }
#term .lane{ flex:1 1 0; min-width:0; }
/* Mood styles */
.soft{ opacity:.95; }
.artifact{ filter:saturate(0) contrast(1.2); opacity:.9; }
.catharsis{ color:#e5f2ff; text-shadow:0 0 10px rgba(147,197,253,.6), 0 0 24px rgba(59,130,246,.35); }
/* Glitch effect */
.glitch{ position:relative; display:inline-block; }
.glitch::before,.glitch::after{ content:attr(data-text); position:absolute; left:0; top:0; width:100%; pointer-events:none; }
.glitch::before{ color:rgba(59,130,246,.95); transform:translate(1px,0); animation:glitchA .55s steps(2,end) infinite; }
.glitch::after{ color:rgba(239,68,68,.9); transform:translate(-1px,0); animation:glitchB .5s steps(2,end) infinite; }
@keyframes glitchA{ 0%{clip-path:inset(0 0 70% 0)} 50%{clip-path:inset(30% 0 40% 0)} 100%{clip-path:inset(60% 0 0 0)} }
@keyframes glitchB{ 0%{clip-path:inset(60% 0 0 0)} 50%{clip-path:inset(30% 0 40% 0)} 100%{clip-path:inset(0 0 70% 0)} }
#pad{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:480px; height:360px; background:rgba(17,24,39,.95); border:1px solid rgba(255,255,255,.12); border-radius:12px; box-shadow:0 25px 50px -12px rgb(0 0 0 / .5); z-index:10002; display:none; color:#e5e7eb; }
#pad textarea{ width:100%; height:calc(100% - 40px); background:transparent; color:#e5e7eb; border:none; padding:10px; font-family:'Roboto Mono',monospace; outline:none }
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;overscroll-behavior:none}
canvas#view{position:fixed;inset:0;width:100vw;height:100vh;display:block}
/* Intro overlay gradient that sits above 3D and behind sheet */
#introOverlay{position:fixed;inset:0;z-index:10000;pointer-events:none;
  background:linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #93c5fd 100%);
  opacity:1; transition:opacity .8s ease}
#introOverlay.hidden{opacity:0; pointer-events:none}

/* Panels */
.panel{position:fixed;z-index:10;background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow);padding:12px}
.panel#hud{z-index:10002}
.panel .title{font-weight:800;letter-spacing:.2px}
.row{display:flex;gap:8px;align-items:center}
.stack{display:flex;flex-direction:column;gap:8px}
.chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);padding:6px 10px;border-radius:999px;background:var(--chip);font-size:12px}
.btn{appearance:none;border:1px solid var(--line);background:#fff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
.btn:hover{border-color:#d1d5e4}
.btn:active{transform:translateY(1px)}
.btn.primary{background:var(--accent);border-color:#2162df;color:#fff}
.btn.good{background:var(--accent-2);border-color:#15a34a;color:#fff}
.btn.warn{background:var(--accent-3);border-color:#c0790a;color:#fff}
.kbd{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;border:1px solid var(--line);padding:1px 6px;border-radius:6px;background:#fff}
.code{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;background:#0b1220;color:#eaeefb;border-radius:10px;padding:10px 12px;font-size:12px;white-space:pre-wrap}
input[type=text]{width:100%;padding:8px 10px;border-radius:10px;border:1px solid var(--line);font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre}

/* Formula input highlighting (fx) */
.fx-wrap{position:relative;flex:1}
#fxHighlight{position:absolute;inset:0;padding:8px 10px;border-radius:10px;background:#fff;pointer-events:none;white-space:pre;overflow:hidden;font-family:Rubik,ui-monospace,Menlo,Consolas,monospace;font-size:12px;color:var(--ink)}
#fx{background:transparent;color:transparent;caret-color:var(--ink);position:relative}
.tok-str{color:#16a34a}
.tok-range{color:#f59e0b}
.tok-num{color:#1d4ed8}

/* HUD positions */
#hud{top:16px;left:16px;width:420px;display:none}
#right{top:16px;right:16px;width:380px;display:none}
#footer{display:none}
.sub{color:var(--muted);font-size:12px}

/* 2D Sheet + merged Fx UI */
.intro-centered{width:860px !important; height:520px !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important}
#sheet{position:fixed; left:16px; bottom:16px; width:760px; height:440px; background:var(--panel); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); padding:12px; z-index:10001; display:flex; flex-direction:column; transition:all .9s cubic-bezier(0.34,1.56,0.64,1); overflow:hidden}
.intro-max{width:95vw !important; height:95vh !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important}
body.crystal-2d #sheet{background:linear-gradient(150deg, rgba(255,255,255,0.22) 0%, rgba(221,238,255,0.28) 42%, rgba(236,233,255,0.18) 100%); border:1px solid rgba(255,255,255,0.58); box-shadow:0 30px 60px rgba(15,23,42,0.25), inset 0 1px 0 rgba(255,255,255,0.75); backdrop-filter:blur(26px) saturate(185%); -webkit-backdrop-filter:blur(26px) saturate(185%); position:fixed;}
body.crystal-2d #sheet::before{content:""; position:absolute; inset:-12% -18%; border-radius:28px; background:radial-gradient(120% 140% at 12% 8%, rgba(255,255,255,0.65) 0%, rgba(255,255,255,0.05) 55%), radial-gradient(140% 140% at 88% 92%, rgba(147,197,253,0.35) 0%, rgba(147,197,253,0.0) 65%); opacity:0.7; pointer-events:none; filter:blur(4px);}
body.crystal-2d #sheet::after{content:""; position:absolute; inset:-2px; border-radius:inherit; border:1px solid rgba(255,255,255,0.4); mix-blend-mode:soft-light; opacity:0.7; pointer-events:none;}
body.crystal-2d #sheet .sheet-head{background:rgba(255,255,255,0.22); border-bottom:1px solid rgba(255,255,255,0.45); box-shadow:inset 0 1px 0 rgba(255,255,255,0.6); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);}
body.crystal-2d #sheet .sheet-title{color:#0f172a; text-shadow:0 1px 12px rgba(148,163,209,0.45);}
body.crystal-2d #sheet .sheet-ctrls .btn{background:rgba(255,255,255,0.55); border-color:rgba(148,163,209,0.45); color:#1f2937; box-shadow:0 12px 24px rgba(15,23,42,0.18); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);}
body.crystal-2d #sheet .sheet-ctrls .btn:hover{border-color:rgba(59,130,246,0.55);}
body.crystal-2d table.sheet th{background:linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(229,240,255,0.28) 100%); border:1px solid rgba(255,255,255,0.45); color:#0f172a; text-shadow:0 1px 10px rgba(255,255,255,0.55); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);}
body.crystal-2d table.sheet td{background:rgba(255,255,255,0.58); border:1px solid rgba(255,255,255,0.38); color:#0b1220; backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);}
body.crystal-2d table.sheet td.sel{background:rgba(96,165,250,0.32) !important; box-shadow:0 0 0 1px rgba(59,130,246,0.5) inset;}
body.crystal-2d table.sheet td.hovered{background:rgba(147,197,253,0.28) !important; border-color:rgba(96,165,250,0.5) !important;}
body.crystal-2d table.sheet td.cell:hover{background:rgba(191,219,254,0.33) !important;}
body.crystal-2d .note-tooltip{background:rgba(59,130,246,0.82); box-shadow:0 10px 22px rgba(59,130,246,0.28); backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);}
body.crystal-2d #sheetHeaderCard{background:rgba(241,245,255,0.52); border:1px solid rgba(255,255,255,0.58); box-shadow:0 26px 48px rgba(15,23,42,0.22); backdrop-filter:blur(28px) saturate(175%); -webkit-backdrop-filter:blur(28px) saturate(175%);}
body.crystal-2d #sheetHeaderCard.wipe{background:rgba(229,239,255,0.58);}
/* No body fade; overlay handles it */
.sheet-resizer{position:absolute; right:6px; bottom:6px; width:12px; height:12px; background:var(--accent); border-radius:3px; cursor:nwse-resize}
.sheet-head{display:flex;flex-direction:column;gap:8px; padding:8px; border-bottom:1px solid var(--line)}
/* Disable old floating chip header */
.app-header-float{ display:none }
/* Behind-sheet header card that expands to wipe */
#sheetHeaderCard{ position:fixed; z-index:10000; display:none; background:rgba(255,255,255,0.92); border:1px solid rgba(0,0,0,0.08); border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.65); backdrop-filter:saturate(150%) blur(8px); transition: all .6s cubic-bezier(.34,1.56,.64,1) }
#sheetHeaderCard.visible{ display:block }
#sheetHeaderCard.wipe{ left:0 !important; top:0 !important; width:100vw !important; height:100vh !important; border-radius:0 !important }
.sheet-title-row{display:flex;justify-content:space-between;align-items:center}
.sheet-title{font-weight:800}
.sheet-ctrls{display:flex;gap:6px;align-items:center}
.sheet-fx{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
.sheet-fx input{flex:1}
/* Touch-only minimize (yellow dot) */
#minDot{ position:absolute; right:12px; top:12px; width:16px; height:16px; background:#facc15; border:1px solid #eab308; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,.15); transform:scale(0); opacity:0; transition: transform .35s cubic-bezier(.34,1.56,.64,1), opacity .25s ease; z-index:5; display:none }
body.touch #minDot.show{ display:block; transform:scale(1); opacity:1 }
.sheet-body{flex:1; display:flex; overflow:hidden}
.col-headers{position:relative; margin-left:48px; height:60px; display:flex; gap:0}
.row-headers{width:48px; overflow:auto hidden; border-right:1px solid var(--line)}
.grid-wrap{flex:1; overflow:auto}
table.sheet{border-collapse:collapse; table-layout:fixed; width:max-content}
table.sheet td, table.sheet th{border:1px solid #e6e8ef; padding:0; height:60px; font-size:14px; font-family:'Roboto Mono', monospace}
/* Match reference code: use Roboto Mono for both headers and cells */
td.cell{width:92px; background:#fff; padding:0 6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer; text-align:left; font-family:'Roboto Mono', monospace}
/* Axes/header cells: soft gray */
table.sheet th{ background:#f9fafb; text-align:center; font-weight:600 }
/* Row header (Y labels) padding/width for non-touch */
table.sheet tr th:first-child{ min-width:56px; padding:0 10px }

/* Ensure compatibility with reference-style selector */
.sheet-table th,.sheet-table td{ border:1px solid var(--line); padding:6px 8px; min-width:60px; text-align:left; font-family:'Roboto Mono', monospace; font-size:14px }
.sheet-table th{ background:#f9fafb; text-align:center; font-weight:600 }
td.cell[data-generated="true"]{background:#f0fdf4} /* Light green for formula-emitted cells */
td.cell[data-anchor="true"]{background:#dcfce7} /* Darker green for anchor cells */
td.sel{outline:2px solid var(--accent); outline-offset:-2px; background:#eef5ff}
.cell.clickable{ cursor:pointer; }
.cell.pending{ background:#fef08a !important; }
.layer-chip{display:none}
.layer-btn{border:1px solid var(--line); background:#fff; border-radius:8px; padding:2px 6px; cursor:pointer}
#directEdit{position:fixed; z-index:30; padding:6px 8px; border-radius:8px; border:1px solid var(--line); font-family:Rubik,ui-monospace,Menlo,Consolas,monospace; display:none}

/* Header alignment fix: ensure headers match cell size exactly */
.col-headers .chip{height:60px; line-height:60px; min-width:80px; padding:0; text-align:center}
.row-headers .chip{height:60px; line-height:60px; width:48px; padding:0; text-align:center}

/* Cell hover like reference code */
td.cell:hover{background-color: #eff6ff !important}
/* Programmatic hover sync class for 2D */
td.cell.hovered{background-color:#e0f2ff !important; border:1px solid #93c5fd !important}
/* Note tooltip - simple blue card on hover */
.note-tooltip{position:absolute; top:-30px; left:10px; background:#3b82f6; color:white; padding:4px 8px; border-radius:6px; font-size:11px; white-space:nowrap; opacity:0; transform:translateY(4px); transition:opacity .2s ease, transform .2s ease; pointer-events:none; z-index:200}
.cell:hover .note-tooltip{opacity:1; transform:translateY(0)}
.note-visible{opacity:1 !important; transform:translateY(0) !important}
/* Special styling for intro cell */
.intro-cell{position:relative; background:#e0e7ff !important; font-weight:600; overflow:visible !important}

/* Touch mode scaling */
body.touch #sheet{ width:86vw; height:40vh }
body.touch table.sheet td, body.touch table.sheet th{ height:34px; font-size:14px }
body.touch td.cell{ width:120px }
body.touch .ui-icon{ width:64px; height:64px }
body.touch #dpad{ --dp:72px }
/* Touch-friendly sheet sizing: full device width card at bottom */
body.touch #sheet{ left:50%; right:auto; width:min(92vw, 680px); height:40vh; bottom:12px; top:auto; transform:translateX(-50%) }
body.touch .sheet-body .sheet td, body.touch .sheet-body .sheet th{ height:36px; font-size:15px }
/* Make cells scale to ~8 columns (minus row header) */
body.touch .sheet-body .sheet td.cell{ width:calc((100vw - 24px - 150px)/8) }

/* Touch-friendly sheet sizing: full device width with small gutters */
body.touch #sheet{ left:50%; right:auto; width:min(92vw, 680px); height:40vh; transform:translateX(-50%) }
body.touch .sheet-body .sheet td, body.touch .sheet-body .sheet th{ height:36px; font-size:15px }
/* Make cells scale to roughly 8 visible columns minus row header */
body.touch .sheet-body .sheet td.cell{ width:calc((100vw - 24px - 140px)/8) }
/* Touch: opening (intro-centered) should be a centered card with mobile dimensions */
body.touch #sheet.intro-centered{ width:min(92vw, 680px) !important; height:40vh !important; left:50% !important; top:50% !important; bottom:auto !important; transform:translate(-50%,-50%) !important }
/* Hide debug console by default on touch; allow button to show it */
body.touch #hud{ display:none }
#debug-icon{ position:fixed; left:24px; bottom:24px; z-index:10003 }

/* Fx panel (docs) */
#fxPanel{position:relative; flex:0 0 340px; height:100%; background:var(--panel); border:1px solid var(--line); border-radius:16px; box-shadow:var(--shadow); display:none; flex-direction:column; z-index:11; opacity:0; transform:translateX(12px); transition:opacity .25s ease, transform .25s ease, box-shadow .25s ease}
.fx-visible{display:flex !important; opacity:1 !important; transform:translateX(0) !important}
.fx-panel{margin-left:12px; border-left:1px solid var(--line)}
.fx-head{display:flex; align-items:center; justify-content:space-between; padding:8px 12px; border-bottom:1px solid var(--line)}
.fx-body{flex:1; overflow:auto; padding:8px 12px}
.fx-item{border:1px solid var(--line); border-radius:12px; padding:8px 10px; margin-bottom:8px}
.fx-name{font-weight:800}
.fx-syntax{font-family:Rubik,ui-monospace,Menlo,Consolas,monospace; background:#0b1220; color:#eaeefb; padding:6px 8px; border-radius:8px; font-size:12px; margin-top:6px}
.fx-desc{font-size:12px; color:var(--muted); margin-top:6px}
.fx-copy{font-size:12px; border:1px solid var(--line); padding:4px 8px; border-radius:8px; cursor:pointer}
.fx-category-header{transition: background-color 0.2s;}
.fx-category-header:hover{background-color: rgba(0,0,0,0.05) !important;}
.fx-category-body{overflow:hidden; transition: all 0.3s ease;}
.fx-item{border:1px solid var(--line); border-radius:8px; padding:6px 8px; margin-bottom:4px; background:#fff;}

/* Toast */
#toast{position:fixed; left:50%; transform:translateX(-50%); top:16px; padding:8px 12px; border-radius:10px; background:#111827; color:#fff; font-size:12px; display:none; z-index:50}

/* Brand card on intro overlay */
#introBrand{position:absolute; left:24px; top:24px; transform:none; z-index:10001; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:16px 28px; border-radius:28px; color:#0b1320; font-weight:700; font-size:22px; letter-spacing:.2px; box-shadow:0 10px 30px rgba(0,0,0,0.20), inset 0 1px 0 rgba(255,255,255,0.75); border:1px solid rgba(255,255,255,0.35); background:linear-gradient(180deg, rgba(255,255,255,0.52), rgba(255,255,255,0.30)); backdrop-filter:blur(20px) saturate(180%)}
#introBrand::before{content:""; position:absolute; inset:0; border-radius:28px; background:radial-gradient(120px 80px at 20% 30%, rgba(59,130,246,0.35), transparent 60%), radial-gradient(140px 100px at 80% 70%, rgba(236,72,153,0.28), transparent 60%); pointer-events:none; filter:blur(8px)}
#introBrand .brand-ver{font-weight:400; font-size:12px; opacity:.8; margin-top:3px}

/* D-Pad HUD (soft lab style) */
#dpad{
  --dp:56px;
  position:fixed; right:24px; bottom:24px; z-index:20;
  display:grid; 
  grid-template-columns: var(--dp) var(--dp) var(--dp);
  grid-template-rows: var(--dp) var(--dp) var(--dp);
  grid-template-areas:
    "grab up depthUp"
    "left center right"
    ". down depthDown";
  gap:10px;
}
#dpad .dp{
  width:var(--dp); height:var(--dp);
  border:1px solid #2162df; 
  border-radius:12px; 
  background:var(--accent);
  color:#fff; 
  display:flex; align-items:center; justify-content:center; 
  cursor:pointer; font-weight:800; font-size:18px; 
  box-shadow: var(--shadow);
}
#dpad .dp:hover{filter:brightness(1.06)}
#dpad .dp:active{transform:translateY(1px)}
#dpad .up{grid-area:up}
#dpad .left{grid-area:left}
#dpad .right{grid-area:right}
#dpad .down{grid-area:down}
#dpad .depthUp{grid-area:depthUp}
#dpad .depthDown{grid-area:depthDown}
#dpad .center{grid-area:center; visibility:visible; font-size:14px}
#dpad .grab{grid-area:grab; width:calc(var(--dp)*0.7); height:calc(var(--dp)*0.7); align-self:center; justify-self:center; border:1px dashed #e5e7eb; background:#ffffffaa; color:#1f2937; font-size:14px; display:flex; align-items:center; justify-content:center; cursor:grab}
#dpad .grab:active{cursor:grabbing}

/* Visible focus for keyboard users */
:where(button,[role="button"],a,input,select,textarea,[tabindex]):focus-visible{
  outline: 2px solid rgba(59,130,246,0.8);
  outline-offset: 2px;
}
@media (prefers-contrast: more){
  :where(button,[role="button"],a,input,select,textarea,[tabindex]):focus-visible{
    outline-width: 3px;
  }
}







/* Respect reduced motion preferences */
@media (prefers-reduced-motion: reduce){
  .anim-spin, .anim-pulse, #world::after{
    animation: none !important;
    transition-duration: 0.001ms !important;
  }
}

/* Twemoji styling */
img.emoji {
  height: 1em;
  width: 1em;
  margin: 0 0.05em 0 0.1em;
  vertical-align: -0.1em;
}
</style>

</head>
<body>

<script>
(function(){
  var reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if(reduce){ document.documentElement.classList.add('reduced-motion'); }
  if(reduce && !window.__rafPatched){
    window.__rafPatched = true;
    var _raf = window.requestAnimationFrame;
    window.requestAnimationFrame = function(cb){
      return setTimeout(function(){ try{ cb(performance.now()); }catch(e){} }, 250);
    };
  }
})();
</script>
<script>
document.addEventListener('click', function(e){
  try{
    var btn = e.target && e.target.closest && e.target.closest('button[aria-pressed]');
    if(!btn) return;
    var next = (btn.getAttribute('aria-pressed') !== 'true').toString();
    btn.setAttribute('aria-pressed', next);
  }catch{}
}, {capture:true});
</script>
<script>
(function(){
  try{
    var canvas=document.createElement('canvas');
    var ok = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    if(!ok){
      var wrap=document.createElement('div');
      wrap.setAttribute('role','alert');
      wrap.style.cssText='position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:24px;background:rgba(0,0,0,0.6);z-index:99999;';
      wrap.innerHTML='<div style="max-width:640px;background:#fff;color:#111;border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(0,0,0,.2)"><h2 style="margin:0 0 8px">WebGL not available</h2><p>The 3D view is unavailable. You can still work with the sheet. Try updating your browser or enable hardware acceleration.</p></div>';
      document.body.appendChild(wrap);
      document.documentElement.classList.add('no-webgl');
    }
  }catch(e){ console.warn('WebGL check failed', e); }
})();
</script>
<div id="introOverlay"><div id="introBrand">celli.os<div class="brand-ver">v.0.0.1</div></div></div>
<div id="world"></div>
<canvas id="view"></canvas>

<!-- Debug/builder card -->
<div class="panel stack" id="hud" style="padding:0; overflow:hidden">
  <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)"><span>DEBUG CONSOLE</span><div id="debug-close" class="close" title="Hide"></div></div>
  <div class="sub" style="padding:0 12px 8px;">Click cells • <span class="kbd">← ↑ → ↓</span> move • <span class="kbd">Enter</span> edit • <span class="kbd">P</span> physics • <span class="kbd">F</span> functions</div>
  
  <!-- Navigation & View Controls -->
  <div class="row" style="padding:0 12px 6px;">
    <button class="btn primary" id="centerHome">🏠 Home</button>
    <button class="btn" id="viewMainframe">🖥️ Mainframe</button>
    <button class="btn" id="toggleGrid">Grid</button>
    <button class="btn" id="toggleAxes">Axes</button>
  </div>
  
  <!-- Scene & Physics Controls -->
  <div class="row" style="padding:0 12px 6px;">
    <button class="btn good" id="physicsBtn">⚡ Physics</button>
    <button class="btn" id="toggleChunks">📦 Chunks</button>
    <button class="btn warn" id="reset">🔄 Reset</button>
  </div>

  <div class="row" style="padding:0 12px 6px;">
    <button class="btn" id="presentToggleBtn">🎨 Present: OFF</button>
    <button class="btn" id="graphicsSettingsBtn">🎛️ Graphic Settings</button>
  </div>

  <label class="row" style="padding:0 12px 6px; justify-content:space-between; align-items:center; font-weight:600;">
    <span>Crystal 2D Style</span>
    <input type="checkbox" id="crystal2DToggle">
  </label>

  <!-- Data Import/Export -->
  <div class="row" style="padding:0 12px 6px;">
    <button class="btn" id="importFileBtn">📁 Import File</button>
    <button class="btn" id="pasteDataBtn">📋 Paste Data</button>
  </div>
  
  <!-- Save System -->
  <div class="row" style="padding:0 12px 6px;">
    <button class="btn good" id="saveStateBtn">💾 Save</button>
    <button class="btn" id="loadStateBtn">📂 Load</button>
    <button class="btn warn" id="clearSaveBtn">🗑️ Clear Save</button>
  </div>
  
  <!-- Save Status -->
  <div style="padding:0 12px 12px; font-size:11px; color:var(--muted);">
    <span id="saveStatus">Auto-save: Ready</span>
  </div>
</div>

<div class="panel stack" id="graphicsSettingsPanel" style="display:none; position:absolute; left:440px; top:16px; width:320px; max-height:80vh; overflow:auto;">
  <div class="win-header" style="background:rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.12)">
    <span>Graphic Settings</span>
    <div id="graphicsSettingsClose" class="close" title="Hide"></div>
  </div>
  <div class="stack" style="padding:12px; gap:12px;">
    <div class="sub" id="graphicsSettingsHint">Enable Present mode to tweak fancy rendering.</div>

    <div class="stack" style="gap:6px;">
      <div class="title" style="font-size:14px;">Environment</div>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Studio HDRI</span>
        <input type="checkbox" id="gfxHdri">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>3-Point Lighting</span>
        <input type="checkbox" id="gfxLights">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Dark Background</span>
        <input type="checkbox" id="gfxDarkBg">
      </label>
    </div>

    <div class="stack" style="gap:6px;">
      <div class="title" style="font-size:14px;">Cinematic</div>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Bloom</span>
        <input type="checkbox" id="gfxBloom">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Bloom Strength <span id="gfxBloomStrengthValue"></span></span>
        <input type="range" id="gfxBloomStrength" min="0" max="1" step="0.01">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Bloom Radius <span id="gfxBloomRadiusValue"></span></span>
        <input type="range" id="gfxBloomRadius" min="0" max="1" step="0.05">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Exposure <span id="gfxExposureValue"></span></span>
        <input type="range" id="gfxExposure" min="0.4" max="2" step="0.05">
      </label>
    </div>

    <div class="stack" style="gap:6px;">
      <div class="title" style="font-size:14px;">Depth of Field</div>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Depth of Field</span>
        <input type="checkbox" id="gfxDof">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Aperture <span id="gfxDofApertureValue"></span></span>
        <input type="range" id="gfxDofAperture" min="0" max="0.02" step="0.0005">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Max Blur <span id="gfxDofMaxBlurValue"></span></span>
        <input type="range" id="gfxDofMaxBlur" min="0" max="0.02" step="0.0005">
      </label>
    </div>

    <div class="stack" style="gap:6px;">
      <div class="title" style="font-size:14px;">Visual Extras</div>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Frosted Glass</span>
        <input type="checkbox" id="gfxTransmission">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Reflective Ground</span>
        <input type="checkbox" id="gfxMirror">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Solid Ground</span>
        <input type="checkbox" id="gfxGround">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Deforming Grid</span>
        <input type="checkbox" id="gfxWaveGrid">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>FXAA</span>
        <input type="checkbox" id="gfxFxaa">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Fog</span>
        <input type="checkbox" id="gfxFog">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Fog Density <span id="gfxFogDensityValue"></span></span>
        <input type="range" id="gfxFogDensity" min="0" max="0.05" step="0.001">
      </label>
    </div>

    <div class="stack" style="gap:6px;">
      <div class="title" style="font-size:14px;">Stylization</div>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Selection Outline</span>
        <input type="checkbox" id="gfxOutline">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Outline Strength <span id="gfxOutlineStrengthValue"></span></span>
        <input type="range" id="gfxOutlineStrength" min="0" max="5" step="0.1">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Outline Thickness <span id="gfxOutlineThicknessValue"></span></span>
        <input type="range" id="gfxOutlineThickness" min="0" max="4" step="0.1">
      </label>
      <label class="row" style="justify-content:space-between; align-items:center;">
        <span>Motion Blur</span>
        <input type="checkbox" id="gfxMotion">
      </label>
      <label class="stack" style="gap:4px;">
        <span class="sub">Blur Damping <span id="gfxMotionDampingValue"></span></span>
        <input type="range" id="gfxMotionDamping" min="0.7" max="0.99" step="0.005">
      </label>
    </div>
  </div>
</div>

<div class="panel stack" id="right" style="display:none"></div>

<div class="panel" id="footer">
  <span class="chip" id="statusChip">Booting…</span>
  <span class="chip">Chunked</span>
  <span class="chip">Deps</span>
  <span class="chip" id="physChip">Physics: OFF</span>
  <span class="chip">Fn-Tags</span>
  <span class="chip" id="countChip">Counts: –</span>
</div>

<!-- Screen-space D-Pad (bottom-right) -->
<div id="dpad" aria-label="D-Pad">
  <div class="dp grab" title="Drag">⠿</div>
  <div class="dp up" data-dx="0" data-dy="-1" data-dz="0">↑</div>
  <div class="dp depthUp" data-dx="0" data-dy="0" data-dz="-1">↥</div>
  <div class="dp left" data-dx="-1" data-dy="0" data-dz="0">←</div>
  <div class="dp center" title="Arrow mapping"><span style="display:inline-block;width:16px;height:12px;border:2px solid #fff;border-radius:3px"></span>&nbsp;<span id="depthMode">H</span></div>
  <div class="dp depthDown" data-dx="0" data-dy="0" data-dz="1">↧</div>
  <div class="dp down" data-dx="0" data-dy="1" data-dz="0">↓</div>
  <div class="dp right" data-dx="1" data-dy="0" data-dz="0">→</div>
</div>

<!-- 2D Sheet with merged Fx UI -->
<div id="sheetHeaderCard"></div>
<div id="sheet" class="intro-centered" aria-label="2D Sheet">
  <div class="sheet-head">
    <div class="sheet-title-row" style="display:flex;align-items:center;justify-content:space-between;">
      <div style="display:flex;align-items:center;gap:8px;">
        <button class="layer-btn" id="prevArray" style="display:none">◀</button>
        <div class="sheet-title" id="sheetTitle" style="font-family:Inter, system-ui; font-weight:600;"></div>
        <button class="layer-btn" id="nextArray" style="display:none">▶</button>
      </div>
      <div class="sheet-ctrls" style="display:flex;gap:6px;align-items:center;">
        <button class="btn" id="copyAddress" title="Copy Address" aria-label="Copy Address">@</button>
      <button class="btn" id="toggleAddressMode" title="Toggle Local/Absolute">A1α</button>
        <div id="color-picker-wrapper" title="Fill Color" style="display:flex; flex-direction:column; width:120px; gap:6px;">
          <input type="color" id="fillColorPicker" value="#ffffff" style="width:36px; height:36px; border-radius:8px; cursor:pointer; border:none; padding:0; background:transparent" />
          <div id="fillColorPreview" style="width:100%; height:12px; border:1px solid var(--line); border-radius:6px; pointer-events:none;"></div>
          <div style="display:flex; gap:6px; align-items:center;">
            <label class="kbd" style="display:flex; align-items:center; gap:6px;">
              <input type="checkbox" id="fillColorLive" checked /> Live
            </label>
            <button class="btn" id="fillColorApply" title="Apply color to selection">Apply</button>
            <button class="btn" id="fillColorClear" title="Clear cell color">Clear</button>
          </div>
        </div>
        <button class="btn" id="viewToggleBtn" title="Toggle 3D View Mode" style="width: 36px; height: 36px; padding: 6px;">
          <svg id="viewToggleIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </button>
        <button class="btn" id="toggleFxPanel" title="Functions" aria-label="Toggle formula panel" aria-pressed="false">Fx</button>
    </div>
  </div>
    <!-- Formula row placed beneath label/buttons -->
    <div class="sheet-fx" style="display:flex; gap:6px; align-items:center; margin-top:6px;">
      <div class="fx-wrap" style="flex:1;">
        <div id="fxHighlight" aria-hidden="true"></div>
        <input type="text" id="fx" placeholder='=ARRAY("Hello","World")'>
      </div>
      <button class="btn primary" id="applyFx" title="Apply">✓</button>
    </div>
    <div id="minDot" title="Minimize"></div>
  </div>
  <div class="sheet-body" style="position:relative; display:flex; align-items:stretch">
    <div class="grid-wrap" style="flex:1; overflow:auto">
    <table class="sheet">
      <thead><tr id="cols"><th></th></tr></thead>
      <tbody id="rows"></tbody>
    </table>
</div>
  </div>
  <div class="sheet-resizer" id="sheetResizer" title="Resize"></div>
<div id="fxPanel" class="fx-panel">
  <div class="fx-head">
    <div class="title">Functions</div>
    <button class="btn" id="fxClose">Close</button>
  </div>
  <div class="fx-body" id="fxBody"></div>
</div>
</div>
<input id="directEdit" />

<div id="toast"></div>
<input type="file" id="fileImporter" style="display:none;" accept=".csv,.tsv,.txt,.xlsx,.xls" />
<div id="pasteModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:10005; align-items:center; justify-content:center;">
  <div style="background:white; padding:20px; border-radius:12px; width:90vw; max-width:600px; display:flex; flex-direction:column; gap:12px;">
    <h3 style="margin:0;">Paste Spreadsheet Data</h3>
    <p style="margin:0; font-size:14px; color:#555;">Paste data from Excel, Google Sheets, or CSV/TSV.</p>
    <textarea id="pasteDataInput" style="width:100%; height:200px; font-family:monospace; border:1px solid #ccc; border-radius:8px; padding:8px;"></textarea>
    <div>
      <button class="btn primary" id="processPasteBtn">Import</button>
      <button class="btn" id="cancelPasteBtn">Cancel</button>
    </div>
  </div>
  </div>

<!-- Narrative icons and windows -->
<div id="terminal-icon" class="ui-icon" title="Open Celli_Log.txt">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
</div>
<div id="notepad-icon" class="ui-icon" title="ty.txt">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300"><path d="M8 2v4"></path><path d="M12 2v4"></path><path d="M16 2v4"></path><rect x="4" y="4" width="16" height="18" rx="2"></rect><path d="M12 12h.01"></path><path d="M16 16h.01"></path><path d="M8 12h.01"></path><path d="M8 16h.01"></path></svg>
</div>
<div id="terminal">
  <div class="win-header"><span>Terminal</span><div id="term-close" class="close" title="Close"></div></div>
  <pre id="term"></pre>
</div>
<div id="pad" style="background:#fafafc; color:#1f2937; border:1px solid #e5e7eb;">
  <div class="win-header" style="background:#f2f4f8; color:#111827"><span>ty.txt — Notepad</span><div id="pad-close" class="close" title="Close"></div></div>
  <textarea id="note" style="background:#ffffff; color:#111827">special thanks:
- Stephen Lavelle (Increpare)
- Arvi Teikari (Hempuli)
- Jonathan Blow</textarea>
</div>
<div id="crash" style="display:none; position:fixed; inset:0; background:#0b1220; color:#eaeefb; padding:24px; white-space:pre-wrap; z-index:1000; overflow:auto"></div>

<!-- Settings gear and panel removed -->

<!-- Direct CDN ESM imports (no shims/importmap) to avoid sourcemap noise under file:// -->

<script>
  // Error handler for import failures
  window.addEventListener('error', function(e) {
    console.error('Script error:', e.error || e.message);
    const statusEl = document.getElementById('statusChip');
    if (statusEl) statusEl.textContent = 'Import Error: ' + (e.error?.message || e.message);
  });
</script>
<script type="module">
// Guard against duplicate boot/RAF chains
if (window.__CELL_REWORK_BOOTED__) {
  console.warn('Duplicate boot blocked');
  throw new Error('Duplicate boot');
}
window.__CELL_REWORK_BOOTED__ = true;
// Debug: global render-order controls (defaults)
// Shells behind fills by default; array frame behind all
window.__RO = window.__RO || { ghostFill:350, solidFill:360, solidShell:340, ghostShell:300, frameCore:295, frameShell:300 };
/* ===========================
   Imports
=========================== */
// Try multiple import strategies to bypass caching issues
let THREE, OrbitControls, RoundedBoxGeometry, BufferGeometryUtils;
let EffectComposer, RenderPass, UnrealBloomPass, BokehPass, ShaderPass, FXAAShader, OutlinePass, AfterimagePass, OutputPass;
let RGBELoader, Reflector;

try {
  // Strategy 1: Use esm.sh which rewrites internal bare imports to absolute URLs
  const baseUrl = 'https://esm.sh/three@0.160.0';
  const [threeModule, controlsModule, geometryModule, utilsModule,
    effectComposerModule, renderPassModule, bloomPassModule, bokehPassModule,
    shaderPassModule, fxaaModule, outlineModule, afterimageModule, outputModule,
    rgbeModule, reflectorModule
  ] = await Promise.all([
    import(`${baseUrl}`),
    import(`${baseUrl}/examples/jsm/controls/OrbitControls.js`),
    import(`${baseUrl}/examples/jsm/geometries/RoundedBoxGeometry.js`),
    import(`${baseUrl}/examples/jsm/utils/BufferGeometryUtils.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/EffectComposer.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/RenderPass.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/UnrealBloomPass.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/BokehPass.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/ShaderPass.js`),
    import(`${baseUrl}/examples/jsm/shaders/FXAAShader.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/OutlinePass.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/AfterimagePass.js`),
    import(`${baseUrl}/examples/jsm/postprocessing/OutputPass.js`),
    import(`${baseUrl}/examples/jsm/loaders/RGBELoader.js`),
    import(`${baseUrl}/examples/jsm/objects/Reflector.js`)
  ]);

  THREE = threeModule.default || threeModule;
  OrbitControls = controlsModule.OrbitControls || controlsModule.default;
  RoundedBoxGeometry = geometryModule.RoundedBoxGeometry || geometryModule.default;
  BufferGeometryUtils = utilsModule.default || utilsModule;
  EffectComposer = effectComposerModule.EffectComposer || effectComposerModule.default;
  RenderPass = renderPassModule.RenderPass || renderPassModule.default;
  UnrealBloomPass = bloomPassModule.UnrealBloomPass || bloomPassModule.default;
  BokehPass = bokehPassModule.BokehPass || bokehPassModule.default;
  ShaderPass = shaderPassModule.ShaderPass || shaderPassModule.default;
  FXAAShader = fxaaModule.FXAAShader || fxaaModule.default;
  OutlinePass = outlineModule.OutlinePass || outlineModule.default;
  AfterimagePass = afterimageModule.AfterimagePass || afterimageModule.default;
  OutputPass = outputModule.OutputPass || outputModule.default;
  RGBELoader = rgbeModule.RGBELoader || rgbeModule.default;
  Reflector = reflectorModule.Reflector || reflectorModule.default;
  
  console.log('Three.js imports successful:', !!THREE.Scene, !!OrbitControls, !!RoundedBoxGeometry);
  document.getElementById('statusChip').textContent = 'Modules loaded successfully';
} catch(e) {
  console.error('Import failed:', e);
  document.getElementById('statusChip').textContent = 'Import failed: ' + e.message;
  throw e;
}
// Fancy mode removed; keep only core Three.js imports
// Removed heavy AO/Vignette to keep the look clean and modern
// Dynamic Rapier loader (optional)
let RAPIER = null; let RAP_READY = false;
// Global intro flag to guarantee onboarding runs exactly once across handlers
window.__INTRO_FIRED = window.__INTRO_FIRED || false;

// Initialize Twemoji for consistent emoji rendering
if(typeof twemoji !== 'undefined'){
  twemoji.parse(document.body, {
    folder: 'svg',
    ext: '.svg',
    className: 'emoji'
  });
}
const playClickSound = (()=>{
  try{
    const audio = new Audio('https://threejs.org/examples/sounds/ping_pong.mp3');
    audio.preload = 'auto';
    audio.volume = 0.55;
    return ()=>{ try{ audio.currentTime = 0; audio.play(); }catch{} };
  }catch{
    return ()=>{};
  }
})();
let lastCellClickSound = 0;
function playCellClick(){
  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  if(now - lastCellClickSound < 260) return;
  lastCellClickSound = now;
  playClickSound();
}

function formulaHasChime(formula){
  if(!formula) return false;
  try{
    return /\bCHIME\s*\(/i.test(String(formula));
  }catch{
    return false;
  }
}

const ChimeSystem = (()=>{
  const NOTE_BASE = { C:-9, D:-7, E:-5, F:-4, G:-2, A:0, B:2 };
  let ctx = null;
  let master = null;

  function ensureContext(){
    if(typeof window === 'undefined') return null;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if(!AudioCtx) return null;
    if(!ctx){
      try{
        ctx = new AudioCtx();
        master = ctx.createGain();
        master.gain.value = 0.22;
        master.connect(ctx.destination);
      }catch{ ctx = null; master = null; return null; }
    }
    if(ctx && ctx.state === 'suspended'){
      try{ ctx.resume(); }catch{}
    }
    return ctx && master ? { ctx, master } : null;
  }

  function parseNote(raw){
    if(raw == null) return null;
    const str = String(raw).trim();
    if(!str) return null;
    const letter = str[0].toUpperCase();
    if(!NOTE_BASE.hasOwnProperty(letter)) return null;
    let accidental = '';
    const rest = str.slice(1).trim();
    if(rest.startsWith('#')) accidental = '#';
    else if(rest.startsWith('b') || rest.startsWith('B')) accidental = 'b';
    let offset = NOTE_BASE[letter];
    if(accidental === '#') offset += 1;
    if(accidental === 'b') offset -= 1;
    return { label: `${letter}${accidental}`, offset };
  }

  function toOctave(raw){
    if(raw == null || raw === '') return 4;
    const n = parseInt(raw, 10);
    return Number.isFinite(n) ? n : 4;
  }

  function toFrequency(offset, octave){
    const semitones = offset + (octave - 4) * 12;
    return 440 * Math.pow(2, semitones / 12);
  }

  function play(offset, octave, duration = 0.65){
    const ctxData = ensureContext();
    if(!ctxData) return;
    const { ctx, master: masterGain } = ctxData;
    try{
      const osc = ctx.createOscillator();
      const env = ctx.createGain();
      const now = ctx.currentTime;
      const freq = toFrequency(offset, octave);
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(freq, now);
      env.gain.setValueAtTime(0, now);
      env.gain.linearRampToValueAtTime(1, now + 0.018);
      env.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.2, duration));
      osc.connect(env);
      env.connect(masterGain);
      osc.start(now);
      osc.stop(now + Math.max(0.25, duration) + 0.12);
    }catch(e){ console.warn('Chime playback failed', e); }
  }

  return { ensureContext, parseNote, toOctave, toFrequency, play };
})();
try{ window.CelliChimes = ChimeSystem; }catch{}
// Early touch detection so initial sizing uses correct mode (coarse pointer or small screen with touch)
try{
  const coarse = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
  const many = ((navigator.maxTouchPoints||0) > 0) || ((navigator.msMaxTouchPoints||0) > 0);
  const small = Math.min(window.innerWidth, window.innerHeight) <= 820;
  if(coarse || (many && small)) document.body.classList.add('touch');
}catch{}
async function loadRapier(){
  // Prefer ESM builds to avoid CommonJS globals like `exports`
  const candidates = [
    'https://esm.sh/@dimforge/rapier3d-compat@0.12.0',
    'https://cdn.skypack.dev/@dimforge/rapier3d-compat'
  ];
  for(const url of candidates){
    try{
      const mod = await import(url);
      RAPIER = mod?.default || mod;
      if(RAPIER){ RAP_READY = true; return; }
    }catch(e){ console.warn('Rapier load failed', url, e); }
  }
  console.warn('Rapier unavailable, continuing without physics');
  RAPIER=null; RAP_READY=false;
}

/* ===========================
   Constants & Utils
=========================== */
const CHUNK_SIZE = 16;
const INACTIVE_GREEDY_THRESHOLD = 4096; // switch non-focused large arrays to shell + greedy
const WINDOW_CHUNK_RADIUS = 1; // detailed window radius (in chunk units) around selection
const greekChars = ['α','β','γ','δ','ε','ζ','η','θ','ι','κ','λ','μ','ν','ξ','ο','π','ρ','σ','τ','υ','φ','χ','ψ','ω'];
const greek = (i)=>greekChars[i%greekChars.length];
const A1 = (n)=>{ let s=''; let v=n+1; while(v>0){ const r=(v-1)%26; s=String.fromCharCode(65+r)+s; v=Math.floor((v-1)/26); } return s; };
const chunkOf = (x,y,z)=>({x:Math.floor(x/CHUNK_SIZE),y:Math.floor(y/CHUNK_SIZE),z:Math.floor(z/CHUNK_SIZE)});
const keyChunk = (cx,cy,cz)=>`${cx}_${cy}_${cz}`;
const aKey = ({arrId,x,y,z})=>`${arrId}:${x},${y},${z}`;
const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints>0) || (navigator.msMaxTouchPoints>0));
// Simple helpers for Map/Set <-> POJO
const toObject = (m)=> Object.fromEntries(m || new Map());
const toMap    = (o)=> new Map(Object.entries(o || {}));
// Absolute refs are 1-based: @[1,1,1,ID] is the first cell. A literal 0 means "same as executing cell component".
// Missing coordinate defaults to 1.
const parseAlt = (s, anchor)=>{
  const m=/^@\[(\-?\d+)?,(\-?\d+)?,(\-?\d+)?,(-?\d+)\]$/.exec(String(s).trim());
  if(!m) return null;
  const cur = anchor || {x:0,y:0,z:0,arrId:0};
  const raw = [m[1], m[2], m[3]].map(v=> (v===undefined || v===null) ? '' : String(v));
  const toOneBased = (val, curComp)=>{
    if(val==='' ) return 1; // missing -> first cell
    const n = +val;
    if(n===0) return (curComp|0)+1; // 0 => same as executing cell (convert to 1-based)
    return n; // already 1-based or negative
  };
  const xb = toOneBased(raw[0], cur.x);
  const yb = toOneBased(raw[1], cur.y);
  const zb = toOneBased(raw[2], cur.z);
  return { x: xb-1, y: yb-1, z: zb-1, arrId: +m[4] };
};
const formatLocalAddress = (arrId, coord)=>{ const row = coord.y + 1; return `${A1(coord.x)}${row}${greek(coord.z)}`; };
const debugCoord = (label, arrId, coord) => { console.log(`${label}: 3D(${coord.x},${coord.y},${coord.z}) → 2D(${formatLocalAddress(arrId, coord)}) → @[${coord.x+1},${coord.y+1},${coord.z+1},${arrId}]`); };
const parseA1g = (s,defId)=>{const m=/^([A-Z]+)(\d+)([\u03b1-\u03c9])?(?:\^(-?\d+))?$/.exec(s.trim()); if(!m) return null; let x=0; for(let i=0;i<m[1].length;i++) x=x*26+(m[1].charCodeAt(i)-64); x--; const y=+m[2]-1; const G='αβγδεζηθικλμνξοπρστυφχψω'; const z=m[3]?G.indexOf(m[3]):null; const arrId=m[4]!==undefined?+m[4]:defId; return {x,y,z,arrId};};
const showToast=(t)=>{const el=document.getElementById('toast'); el.textContent=t; el.style.display='block'; setTimeout(()=>el.style.display='none',1200);};

/* ===========================
   Tiny Store (Zustand-ish)
=========================== */
const createStore = (init)=>{
  let state; const listeners=new Set();
  const setState = (partial)=>{ const next=typeof partial==='function'?partial(state):partial; const prev=state; state={...state,...next}; listeners.forEach(l=>l(state,prev)); };
  const getState = ()=>state;
  const subscribe = (fn)=> (listeners.add(fn), ()=>listeners.delete(fn));
  state = init(setState,getState);
  return {getState,setState,subscribe};
};
const Store = createStore((set,get)=>({
  arrays: {}, nextArrayId:1, lastCreatedArrayId:null,
  selection:{arrayId:null, focus:null, anchor:null, range:null},
  scene:{physics:false, showGrid:true, showAxes:true},
  ui:{zLayer:0, fxOpen:false, addressMode:'local', lastInteraction:'3d', viewMode:'standard', crystal2D:false},
  gridPhase:{x:null,y:null,z:null},
  namedBlocks:new Map(), // name -> {x,y,z, data: [layers[z][y][x]] }
  hidden:new Set(), // aKey(cell) -> hidden (per-cell visual mask)
  namedMacros:new Map(), // name -> formula
  // Deferred/meta binding queue for robust late resolution
  pendingMeta: [], // {kind:'onClick'|'note', target:{arrId,x,y,z}, meta:{...}}
  // Global state and event system
  globalState: new Map(), // key -> value
  eventListeners: new Map(), // eventName -> [listenerObjects]
  anchorsByGlobalKey: new Map(), // globalKey -> Set<anchorKey>
  globalKeysByAnchor: new Map(), // anchorKey -> Set<globalKey>
  // Emission tracking for generated values (e.g., ARRAY)
  emittedByAnchor: new Map(), // anchorKey -> Set<cellKey>
  sourceByCell: new Map(), // cellKey -> anchorKey
  // Projectile and collision system
  activeProjectiles: [], // Each item: {id, pos, vel, sourceArrId, payload}
  collisionHandlers: new Map(), // cellKey -> formulaString
  nextProjectileId: 0,
  // Interactions
  interactions:{ gobblingEnabled:false },
  // Game state system
  gameState: { goals: new Map(), winCallbacks: [], hasWon: false },
  // Embedding system
  embeddedMeshes: new Map(), // anchorKey -> { mesh, sourceArrId }
  worldState: { mode: 'normal', parentArr: null, childArr: null },
  // Docking system
  dockGroups: new Map(), // groupId -> {mode:'parent'|'all', members:number[], parentId:number}
  dockGroupsByAnchor: new Map(), // anchorKey -> groupId
  // Track active 3D_ROTATE applications and suppressions for revert logic
  activeRotations: new Map(), // anchorKey -> {targetId, ids:number[], pivot:{arrId,x,y,z}, steps:{sx,sy,sz}}
  suppress3DRotateRevert: new Set(), // Set<anchorKey>
  // Persisted reverts after refresh
  // (3D translate persisted meta is read at revert time; no store change needed here)
  // Track active 3D_TRANSLATE applications and suppressions for revert logic
  activeTranslations: new Map(), // anchorKey -> {targetId, from:{x,y,z}, delta:{dx,dy,dz}}
  suppress3DTranslateRevert: new Set(), // Set<anchorKey>
  // Signal system
  bufferedWrites: [], // { tick, anchor, value, formula }
  currentTick: 0,
  // dependency graph
  depsByAnchor:new Map(), anchorsByDep:new Map(),
  // helpers
  utils:{
    A1, greek,
    key:(arrId,x,y,z)=>`${arrId}:${x},${y},${z}`,
  },
  actions:{
    saveState: ()=>{
      try{
        const s = get();
        console.log('Saving state with', Object.keys(s.arrays).length, 'arrays...');
        
        // Enhanced state preservation - keep ALL meaningful data
        const arrays = {};
        Object.values(s.arrays).forEach(a=>{
          const outA = { 
            id:a.id, name:a.name, size:a.size, hidden:a.hidden, sealed:a.sealed, offset:a.offset,
            fnPolicy: a.fnPolicy ? {
              mode: a.fnPolicy.mode,
              allow: Array.from(a.fnPolicy.allow || []),
              deny: Array.from(a.fnPolicy.deny || []),
              tags: Array.from(a.fnPolicy.tags || [])
            } : undefined,
            params: a.params,
            locks: Array.from(a.locks || []),
            chunks:{} 
          };
          // Transform and per-array knobs
          try{
            const quat = (a._frame?.quaternion?.toArray?.()) || a.rotationQuat || [0,0,0,1];
            outA.transform = {
              offset: a.offset || {x:0,y:0,z:0},
              rotationQuat: quat,
              rotationSteps: a.rotationSteps || {x:0,y:0,z:0}
            };
          }catch{}
          if(a.axesVisible !== undefined) outA.axesVisible = !!a.axesVisible;
          if(a.onSelectHooks)             outA.onSelectHooks = a.onSelectHooks;
          if(a.uiControls)                outA.uiControls    = a.uiControls;
          if(a.cameraLock)                outA.cameraLock    = a.cameraLock;
          if(a.viewMode)                  outA.viewMode      = a.viewMode;
          
          Object.entries(a.chunks).forEach(([k,ch])=>{
            const cells = [];
            for(const c of ch.cells){
              const hasVal = !(c.value===''||c.value==null||c.value===undefined);
              const hasFx = !!c.formula;
              const hasMeta = c.meta && Object.keys(c.meta).length > 0;
              
              // Save ALL cells with content, formulas, or metadata
              if(hasVal || hasFx || hasMeta){
                const metaOut = c.meta ? {...c.meta} : undefined;
                cells.push({
                  x:c.x, y:c.y, z:c.z,
                  value: c.value, // preserve exact value including empty strings
                  formula: c.formula, // preserve exact formula including null
                  meta: metaOut
                });
              }
            }
            if(cells.length>0) outA.chunks[k] = { coord: ch.coord, cells };
          });
          arrays[a.id] = outA;
        });
        
        // Save comprehensive state including dependencies and global state
        const serializable = { 
          version: '1.1',
          timestamp: Date.now(),
          arrays, 
          nextArrayId: s.nextArrayId,
          globalState: Object.fromEntries(s.globalState.entries()),
          selection: s.selection,
          ui: s.ui,
          scene: {
            physics: s.scene.physics,
            showGrid: s.scene.showGrid,
            showAxes: s.scene.showAxes,
            arrowMapDepth: s.scene.arrowMapDepth
          },
          camera: (Scene && Scene.captureCamera) ? Scene.captureCamera() : undefined,
          gridPhase: s.gridPhase,
          docks: {
            groups: Object.fromEntries([...(s.dockGroups||new Map()).entries()].map(([id,g])=> [id, {mode:g.mode, members:[...g.members], parentId:g.parentId??null}] )),
            byAnchor: Object.fromEntries((s.dockGroupsByAnchor||new Map()).entries())
          },
          chunking: { enabled: !!(Scene.ChunkManager && Scene.ChunkManager.enabled) },
          interactions: s.interactions,
          namedBlocks: Object.fromEntries(s.namedBlocks.entries()),
          namedMacros: Object.fromEntries(s.namedMacros.entries())
        };
        
        const data = JSON.stringify(serializable);
        console.log('Serialized state size:', Math.round(data.length/1024), 'KB');
        
        try{
          localStorage.setItem('celliOsState', data);
          showToast(`💾 State Saved (${Math.round(data.length/1024)}KB)`);
        }catch(e){
          if(e.name === 'QuotaExceededError'){
            // Try compressing by removing some metadata
            const compressed = { 
              arrays: Object.fromEntries(Object.entries(arrays).map(([id, a]) => [id, {
                ...a,
                chunks: Object.fromEntries(Object.entries(a.chunks).map(([k, ch]) => [k, {
                  ...ch,
                  cells: ch.cells.map(c => ({
                    x: c.x, y: c.y, z: c.z,
                    value: c.value,
                    formula: c.formula,
                    meta: c.meta ? {
                      onClick: c.meta.onClick,
                      noteText: c.meta.noteText,
                      color: c.meta.color
                    } : undefined
                  }))
                }]))
              }]))
            };
            const compressedData = JSON.stringify(compressed);
            localStorage.setItem('celliOsState', compressedData);
            showToast(`💾 State Saved (Compressed: ${Math.round(compressedData.length/1024)}KB)`);
          } else {
            throw e;
          }
        }
      }catch(e){ 
        console.error('saveState failed', e); 
        showToast('❌ Save failed: ' + e.message); 
      }
    },
    loadState: ()=>{
      try{
        const json = localStorage.getItem('celliOsState'); 
        if(!json){ showToast('📂 No saved state found'); return; }
        
        const data = JSON.parse(json);
        console.log('Loading state version:', data.version, 'from:', new Date(data.timestamp));
        
        // Clear existing scene visuals
        Object.values(get().arrays).forEach(arr=>{ try{ Scene.removeArrayGraphics(arr); }catch{} });
        
        // Restore grid phase early for snapping
        if(data.gridPhase){
          try{ Store.setState({ gridPhase: { x:+data.gridPhase.x||0, y:+data.gridPhase.y||0, z:+data.gridPhase.z||0 } }); }catch{}
        }
        // Restore dock groups
        try{
          const docks = data.docks || {};
          Store.setState({
            dockGroups: toMap(docks.groups || {}),
            dockGroupsByAnchor: toMap(docks.byAnchor || {})
          });
        }catch{}
        // Restore ChunkManager flag
        try{ if(data.chunking && data.chunking.enabled===true && Scene.ChunkManager) Scene.ChunkManager.enabled = true; }catch{}
        // Restore camera later via Scene.restoreCamera
        const cameraSnapshot = data.camera;

        const arrays={};
        Object.values(data.arrays||{}).forEach(a=>{
          arrays[a.id] = { 
            id:a.id, name:a.name, size:{...a.size}, hidden:a.hidden, sealed:a.sealed, offset:{...a.offset},
            state:'ACTIVE', stableCount:0, lastHash:null, lastDepSig:null,
            fnPolicy: a.fnPolicy ? {
              mode: a.fnPolicy.mode || 'ALLOW_ALL',
              allow: new Set(a.fnPolicy.allow || []),
              deny: new Set(a.fnPolicy.deny || []),
              tags: new Set(a.fnPolicy.tags || [])
            } : {mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()},
            params: a.params || {},
            locks: new Set(a.locks || []),
            chunks:{}, labels:[], _frame:null, _colliders:[], _occluders:null 
          };
          // Hydrate added fields (back-compat: prefer transform)
          const T = a.transform || {};
          arrays[a.id].offset = T.offset || a.offset || {x:0,y:0,z:0};
          arrays[a.id].rotationQuat = T.rotationQuat || a.rotationQuat || [0,0,0,1];
          arrays[a.id].rotationSteps = T.rotationSteps || a.rotationSteps || {x:0,y:0,z:0};
          if(a.axesVisible !== undefined) arrays[a.id].axesVisible = !!a.axesVisible;
          if(a.onSelectHooks)             arrays[a.id].onSelectHooks = a.onSelectHooks;
          if(a.uiControls)                arrays[a.id].uiControls    = a.uiControls;
          if(a.cameraLock)                arrays[a.id].cameraLock    = a.cameraLock;
          if(a.viewMode)                  arrays[a.id].viewMode      = a.viewMode;
          // Reserved arrays default hidden if not explicitly saved as visible
          if((a.id===-1) && arrays[a.id].hidden !== true){ arrays[a.id].hidden = true; }
          
          Object.entries(a.chunks||{}).forEach(([k,ch])=>{
            const C = new Scene.Chunk(arrays[a.id], ch.coord);
            C.cells = (ch.cells||[]).map(c=>({
              x:c.x, y:c.y, z:c.z,
              value:c.value, 
              formula:c.formula, 
              meta:c.meta||{}
            }));
            // Rebuild cellMap for O(1) access
            C.cellMap = new Map();
            C.cells.forEach(cell => C.cellMap.set(`${cell.x},${cell.y},${cell.z}`, cell));
            arrays[a.id].chunks[k] = C;
            // Backfill missing empties within existing chunk bounds
            try{
              const arrRef = arrays[a.id];
              const minX=C.coord.x*CHUNK_SIZE, minY=C.coord.y*CHUNK_SIZE, minZ=C.coord.z*CHUNK_SIZE;
              const maxX=Math.min(minX+CHUNK_SIZE, arrRef.size.x), maxY=Math.min(minY+CHUNK_SIZE, arrRef.size.y), maxZ=Math.min(minZ+CHUNK_SIZE, arrRef.size.z);
              for(let z=minZ; z<maxZ; z++)
                for(let y=minY; y<maxY; y++)
                  for(let x=minX; x<maxX; x++){
                    const key=`${x},${y},${z}`;
                    if(!C.cellMap.has(key)){
                      const cell={x,y,z,value:'',formula:null,meta:{}};
                      C.cells.push(cell);
                      C.cellMap.set(key, cell);
                    }
                  }
            }catch{}
          });
          // Ensure chunks exist for all regions and are populated with empties where missing
          try{
            const arrRef = arrays[a.id];
            const cDims={x:Math.ceil(arrRef.size.x/CHUNK_SIZE), y:Math.ceil(arrRef.size.y/CHUNK_SIZE), z:Math.ceil(arrRef.size.z/CHUNK_SIZE)};
            for(let cz=0; cz<cDims.z; cz++)
              for(let cy=0; cy<cDims.y; cy++)
                for(let cx=0; cx<cDims.x; cx++){
                  const key = keyChunk(cx,cy,cz);
                  let C = arrRef.chunks[key];
                  if(!C){
                    C = new Scene.Chunk(arrRef, {x:cx,y:cy,z:cz});
                    arrRef.chunks[key] = C;
                    C.cellMap = new Map();
                  }
                  const minX=cx*CHUNK_SIZE, minY=cy*CHUNK_SIZE, minZ=cz*CHUNK_SIZE;
                  const maxX=Math.min(minX+CHUNK_SIZE, arrRef.size.x), maxY=Math.min(minY+CHUNK_SIZE, arrRef.size.y), maxZ=Math.min(minZ+CHUNK_SIZE, arrRef.size.z);
                  for(let z=minZ; z<maxZ; z++)
                    for(let y=minY; y<maxY; y++)
                      for(let x=minX; x<maxX; x++){
                        const k2=`${x},${y},${z}`;
                        if(!C.cellMap.has(k2)){
                          const cell={x,y,z,value:'',formula:null,meta:{}};
                          C.cells.push(cell);
                          C.cellMap.set(k2, cell);
                        }
                      }
                }
          }catch{}
        });
        
        // Rebuild emission tracking maps from loaded metadata
        const emittedByAnchor = new Map();
        const sourceByCell = new Map();
        try{
          Object.values(arrays).forEach(a=>{
            Object.values(a.chunks||{}).forEach(ch=>{
              (ch.cells||[]).forEach(cell=>{
                const src = cell?.meta?.emitter;
                if(src){
                  const ck = `${a.id}:${cell.x},${cell.y},${cell.z}`;
                  sourceByCell.set(ck, src);
                  const set = emittedByAnchor.get(src) || new Set();
                  set.add(ck);
                  emittedByAnchor.set(src, set);
                }
              });
            });
          });
        }catch{}

        // Restore full state (including rebuilt emission maps)
        const restoredUi = {...get().ui, ...(data.ui||{})};
        if(restoredUi.crystal2D !== true){ restoredUi.crystal2D = false; }
        set({
          arrays,
          nextArrayId: data.nextArrayId||get().nextArrayId,
          globalState: new Map(Object.entries(data.globalState||{})),
          selection: data.selection||get().selection,
          ui: restoredUi,
          scene: {...get().scene, ...(data.scene||{})},
          interactions: {...get().interactions, ...(data.interactions||{})},
          namedBlocks: new Map(Object.entries(data.namedBlocks||{})),
          namedMacros: new Map(Object.entries(data.namedMacros||{})),
          emittedByAnchor,
          sourceByCell
        });
        
        // Restore selection early so focused array renders with shells/LOD correctly
        try{
          const sel0 = data.selection || {};
          const arrMap = Store.getState().arrays;
          let targetSel = null;
          if(sel0.arrayId && sel0.focus && arrMap[sel0.arrayId] && !arrMap[sel0.arrayId].hidden){
            targetSel = sel0;
          } else {
            const firstVisible = Object.values(arrMap).find(a=>a && !a.hidden && a.id>0);
            if(firstVisible) targetSel = { arrayId:firstVisible.id, focus:{x:0,y:0,z:0} };
          }
          if(targetSel){
            Actions.setSelection(targetSel.arrayId, targetSel.focus);
            try{
              const arrF = Store.getState().arrays[targetSel.arrayId];
              if(arrF){ Scene.renderArray(arrF); Scene.centerOnArray(arrF); }
            }catch{}
          }
        }catch{}

        // Force-reserve arrays (id<0) hidden before first render to prevent any flash/overlap
        try{
          const S0 = Store.getState();
          Object.values(S0.arrays).forEach(A=>{ if((A.id|0) < 0){ A.hidden = true; } });
        }catch{}

        // Rebuild visuals and restore UI state
        Scene.reconcileAllArrays();
        // Apply saved rotations and offsets explicitly
        try{
          Object.values(Store.getState().arrays).forEach(A=>{
            if(A._frame){
              if(Array.isArray(A.rotationQuat) && A.rotationQuat.length===4){ A._frame.quaternion.fromArray(A.rotationQuat); }
              const off=A.offset||{x:0,y:0,z:0}; A._frame.position.set(off.x,off.y,off.z);
              // Apply visibility as saved (e.g., Mainframe/Library hidden)
              try{ Scene.syncVisibility(A); }catch{}
            }
          });
        }catch{}
        // Restore camera last
        try{ if(cameraSnapshot && Scene.restoreCamera) Scene.restoreCamera(cameraSnapshot); }catch{}
        // Force render all arrays to show loaded cells and shells
        try{
          const Sx = Store.getState();
          Object.values(Sx.arrays).forEach(A=>{ Scene.renderArray(A); });
          // After arrays are rendered, apply occlusion for focused selection once
          const sf = Sx.selection;
          if(sf && sf.arrayId && sf.focus){
            try{ Scene.updateFocus(sf); }catch{}
          }
        }catch{}
        window.UI?.init?.(); // Re-initialize UI event handlers
        window.UI?.renderSheet?.();
        // Defer a final focus/apply to the next frame to honor all rebuilt visuals
        try{
          requestAnimationFrame(()=>{
            try{
              const selD = Store.getState().selection || {};
              if(selD.arrayId && selD.focus){
                Scene.updateFocus(selD);
                const arrD = Store.getState().arrays[selD.arrayId];
                if(arrD) Scene.renderArray(arrD);
              }
            }catch{}
          });
        }catch{}
        // Finalize by re-applying focus and re-rendering focused array to honor shells/cutaway
        try{
          const selF = Store.getState().selection || {};
          if(selF.arrayId && selF.focus){
            Scene.updateFocus(selF);
            const arrF = Store.getState().arrays[selF.arrayId];
            if(arrF) Scene.renderArray(arrF);
          }
        }catch{}
        // Recreate text sprites for visible cell values after scene reconcile
        try{ Scene.hydrateAll?.(); }catch(e){ console.warn('Hydrate on load failed', e); }
        // One more pass next tick to cover late async mesh/frame attaches
        try{ setTimeout(()=>{ try{ Scene.hydrateAll?.(); }catch{} }, 0); }catch{}
        
        showToast(`📂 State Loaded (${Object.keys(arrays).length} arrays)`);
        console.log('Load complete, arrays restored:', Object.keys(arrays));
      }catch(e){ 
        console.error('loadState failed', e); 
        showToast('❌ Load failed: ' + e.message); 
      }
    },
    resetSave: ()=>{
      try{
        const confirmed = confirm('🗑️ Clear saved state and restart?\n\nThis will delete all saved arrays and formulas.');
        if(!confirmed) return;
        
        localStorage.removeItem('celliOsState');
        // Reset visibility settings as well
        try{ localStorage.removeItem('VisibilitySettings'); window.VisibilitySettings = JSON.parse(JSON.stringify(DEFAULT_VISIBILITY)); }catch{}
        showToast('🗑️ Save cleared - restarting...');
        setTimeout(()=> location.reload(), 800);
      }catch(e){ 
        console.warn('resetSave failed', e); 
        showToast('❌ Clear failed: ' + e.message);
      }
    },
    init: async ()=>{
      await Scene.init(document.getElementById('view'));

      // Mainframe (#-1) → Library (#0) → Sandbox (#2) → Celli's Home (#1)
      const sp = Actions.createArray({id:-1,name:'Mainframe', size:{x:5,y:5,z:5}, hidden:true, sealed:true, offset:{x:-15,y:0,z:-15}});
      // No Library in this build

      console.log('Arrays created');
      
      // Create home array directly (avoid formulas during init)
      const home = Actions.createArray({id:1,name:"Celli's Home", size:{x:8,y:4,z:8}, hidden:false, offset:{x:0,y:1,z:0}});
      
      // Simple content setup matching reference spreadsheet
      console.log('Setting up content...');
      // Top-down sheet: y=0 is first row (A1)
      Actions.setCell(1, {x:0,y:0,z:0}, 'Hello', null, true);   // A1
      Actions.setCell(1, {x:0,y:1,z:0}, 'World!', null, true);  // A2 (note will be on A3)
      
      // Direct meta setup for A3 intro (bypass diegetic complexity during init)
      console.log('Setting up A3 intro meta directly...');
      try{
        // Ensure A3 exists
        Actions.resizeArrayIfNeeded(home, {x:0,y:2,z:0});
        const chKey = keyChunk(...Object.values(chunkOf(0,2,0)));
        let ch = home.chunks[chKey];
        if(!ch){ console.warn('A3 chunk missing after resize'); return; }
        let cell = ch.cells.find(c=>c.x===0&&c.y===2&&c.z===0);
        if(!cell){ ch.cells.push({x:0,y:2,z:0,value:'',formula:null,meta:{}}); cell = ch.cells[ch.cells.length-1]; }
        // Set meta directly with proper formula prefix
        cell.meta = {...(cell.meta||{}), noteText:'Click Me!', onClick:'=STARTINTROEXPERIENCE()'};
        console.log('A3 meta set:', cell.meta);
      }catch(e){ console.warn('Direct A3 setup failed', e); }
      

      try {
        // Focus home array and render it immediately for interaction
        Actions.setSelection(1, {x:0,y:0,z:0});
        Scene.centerOnArray(home);
        Scene.renderArray(home);
      } catch(e) {
        console.error('Home focus failed:', e);
      }


      try {
        UI.init();
        console.log('UI init done');
        // Onboarding: start maximized; collapse only when triggered
        const sheetEl=document.getElementById('sheet');
        const intro=document.getElementById('introOverlay');
        // Block interactions with overlay initially; start centered small
        sheetEl.classList.add('intro-centered');
        intro.classList.remove('hidden');
        // Ensure overlay actually sits above canvas and accepts pointer for safety-net
        intro.style.zIndex = '10000';

      UI.renderSheet();
        console.log('Sheet rendered');
        // Ensure intro note and wiring after DOM paints; re-render sheet to bind onClick eagerly
        requestAnimationFrame(()=>{ requestAnimationFrame(()=>{ 
          try{ UI.ensureIntroNote?.(); }catch{}
          try{ UI.renderSheet?.(); }catch{}
 
        }); });
        
        // Skip full reconcile during intro to avoid duplicate viewports
        

        window.__APP_READY = true;
      } catch(e) {
        console.error('Init failed:', e);
      }
    },
  }
}));
window.Store = Store;

/* ===========================
   Array actions (chunked)
=========================== */
// Transaction ledger for undo/redo and provenance (dual-mode)
const History = {
  dataPast: [], dataFuture: [], dataMax: 100, // cell value/formula changes
  uiPast: [], uiFuture: [], uiMax: 50          // selection/view changes
};

/* ===========================
   Goal/Win System
=========================== */
let checkingWinConditions = false; // Guard against recursion

function checkWinConditions() {
  if (checkingWinConditions) return; // Prevent recursive calls
  const S = Store.getState();
  if (!S.gameState || S.gameState.goals.size === 0 || S.gameState.hasWon) return;

  checkingWinConditions = true;
  try {
    let allGoalsMet = true;
    for (const [key, conditionRef] of S.gameState.goals.entries()) {
      const val = Formula.getCellValue(conditionRef);
      if (val !== 1 && val !== '1' && val !== true) {
        allGoalsMet = false;
        break;
      }
    }

    if (allGoalsMet) {
      S.gameState.hasWon = true; // Prevent re-triggering
      S.gameState.winCallbacks.forEach(cb => {
        try {
          const tx = Write.start('game.onwin', 'Triggering ONWIN');
          Formula.executeAt(cb.anchor, cb.callback, tx);
          Write.commit(tx);
        } catch(e) {
          console.error('ONWIN callback error:', e);
        }
      });
      showToast("✨ You Win! ✨");
    }
  } finally {
    checkingWinConditions = false;
  }
}
const Write = (() => {
  let nextId = 1;
  
  function start(origin, reason) {
    return { id: nextId++, ops: [], reason, time: Date.now(), origin };
  }
  
  function set(tx, arrId, coord, next) {
    const arr = Store.getState().arrays[arrId];
    if(!arr) return;
    
    // Ensure array is large enough
    Actions.resizeArrayIfNeeded(arr, coord);
    
    const prevCell = UI.getCell(arrId, coord);
    const prev = { 
      value: prevCell.value, 
      formula: prevCell.formula, 
      meta: prevCell.meta || {} 
    };
    
    // If formula is being changed/removed, revert any 3D_ROTATE and clean up any emitted cells
    const ak = aKey({arrId, ...coord});
    const skipCleanup = !!(next && next.meta && next.meta.skip_cleanup);
    if(!skipCleanup && prev.formula && (next.formula === null || next.formula === '' || next.formula !== prev.formula)) {
      // Attempt 3D_ROTATE auto-revert for this anchor unless suppressed
      try{
        const S=Store.getState();
        const rec=(S.activeRotations||new Map()).get(ak);
        const suppressed=(S.suppress3DRotateRevert||new Set()).has(ak);
        if(rec && !suppressed){
          const targ=S.arrays[rec.targetId];
          if(targ){
            const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
            const rx=-(rec.steps.sx||0), ry=-(rec.steps.sy||0), rz=-(rec.steps.sz||0);
            (rec.ids||[rec.targetId]).map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, rx, ry, rz));
            (rec.ids||[rec.targetId]).map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
          }
          const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
        }
        if(suppressed){ const sup=new Set(Store.getState().suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
      }catch{}
      const S = Store.getState();
      const emitted = S.emittedByAnchor.get(ak);
      if(emitted) {
        // Guard re-entrancy within a single tx
        tx._clearVisited = tx._clearVisited || new Set();
        emitted.forEach(ck => {
          const [eArrId, coords] = ck.split(':');
          const [x, y, z] = coords.split(',').map(Number);
          const childKey = `${eArrId}:${x},${y},${z}`;
          if(tx._clearVisited.has(childKey)) { S.sourceByCell.delete(ck); return; }
          tx._clearVisited.add(childKey);
          // Clear the emitted cell (avoid self and skip cleanup in nested call)
          if(eArrId !== arrId || x !== coord.x || y !== coord.y || z !== coord.z) {
            Write.set(tx, +eArrId, {x, y, z}, { value: '', formula: null, meta: { skip_cleanup: true } });
          }
          S.sourceByCell.delete(ck);
        });
        S.emittedByAnchor.delete(ak);
      }
    }
    
    let merged = {
      value: next.value !== undefined ? next.value : prevCell.value,
      formula: next.formula !== undefined ? next.formula : prevCell.formula,
      meta: { ...prev.meta, ...(next.meta || {}), from: tx.origin }
    };
    // If clearing a cell (no value and no formula), strip visual-emission metadata
    const clearingCell = ((merged.formula==null || merged.formula==='') && (merged.value==='' || merged.value==null || merged.value===undefined));
    if (clearingCell) {
      const mm = {...(merged.meta||{})};
      delete mm.generated; delete mm.emitter; // remove flags that cause 2D color fill
      merged = { ...merged, meta: mm };
    }
    
    // Emission tracking for generated blocks
    const S = Store.getState();
    if(merged.meta && merged.meta.emitter){
      const srcAk = merged.meta.emitter;
      const ck = `${arrId}:${coord.x},${coord.y},${coord.z}`;
      if(ck !== srcAk){
        const set = S.emittedByAnchor.get(srcAk) || new Set();
        set.add(ck);
        S.emittedByAnchor.set(srcAk, set);
        S.sourceByCell.set(ck, srcAk);
      }
    }
    
    // Apply to in-memory model immediately
    Actions._setCellRaw(arrId, coord, merged);
    tx.ops.push({ arrId, x: coord.x, y: coord.y, z: coord.z, prev, next: merged });
  }
  function commit(tx) {
    // Store transaction in data history
    History.dataPast.push(tx);
    if(History.dataPast.length > History.dataMax) History.dataPast.shift();
    History.dataFuture = [];
    
    // Gather changed anchors for recompute
    const changedAnchors = new Set();
    const affectedArrays = new Set();
    
    for (const op of tx.ops) {
      // Skip recompute for anchors explicitly marked to avoid re-entry
      const skip = !!(op.next?.meta && op.next.meta.skip_recompute);
      if(!skip){
      const key = `${op.arrId}:${op.x},${op.y},${op.z}`;
      changedAnchors.add(key);
      }
      affectedArrays.add(op.arrId);
    }
    
    // Trigger dependency recompute unless we're already inside a recompute pass
    if(!(Formula.isRecomputing && Formula.isRecomputing())){
    Formula.recomputeAnchors(Array.from(changedAnchors));
    }
    
    // Collect emitted cells that became empty to restore them after commit
    const toRestore = [];
    try{
      const S = Store.getState();
      for(const op of tx.ops){
        const becameEmpty = (op.next.formula==null || op.next.formula==='') && (op.next.value==='' || op.next.value===null || op.next.value===undefined);
        if(!becameEmpty) continue;
        const ck = `${op.arrId}:${op.x},${op.y},${op.z}`;
        const srcAk = S.sourceByCell.get(ck);
        if(!srcAk) continue;
        const [aId, rest] = srcAk.split(':');
        const [sx, sy, sz] = rest.split(',').map(Number);
        const sc = Formula.getCell({arrId:+aId, x:sx, y:sy, z:sz});
        if(sc && sc.formula) toRestore.push({arrId:+aId,x:sx,y:sy,z:sz});
      }
    }catch{ /* ignore */ }
    
    // Update visuals for affected arrays with immediate layer re-rendering
    affectedArrays.forEach(id => {
      const arr = Store.getState().arrays[id];
      if(arr) {
        // Force immediate layer re-render for all affected layers
        const affectedLayers = new Set();
        for (const op of tx.ops) {
          if(op.arrId === id) {
            affectedLayers.add(op.z);
            Scene.updateValueSprite(arr, op.x, op.y, op.z, op.next);
          }
        }
        
        // Re-render each affected layer immediately to update voxel colors
        affectedLayers.forEach(z => {
          // Force complete layer rebuild by marking as not rendered
          const layerKey = `${arr.id}:${z}`;
          ['empty','ghost','filled','formula','edges'].forEach(type => {
            const rec = Scene.getLayerMesh(`${layerKey}:${type}`);
            if(rec && rec.mesh) {
              rec.mesh.count = 0; // Reset count to force rebuild
            }
          });
          Scene.renderLayer(arr, z);
        });
        
        // Full array render for any structural changes
        Scene.renderArray(arr);
        
        if(id === Store.getState().selection.arrayId && window.UI?.renderSheet) window.UI.renderSheet();
      }
    });
    
    // Persist after commit for seamless resume (debounced to avoid quota thrash)
    try{
      clearTimeout(window.__AUTO_SAVE_T);
      // Update save status
      const statusEl = document.getElementById('saveStatus');
      if(statusEl) statusEl.textContent = 'Auto-save: Pending...';
      
      window.__AUTO_SAVE_T = setTimeout(()=>{ 
        try{ 
          Store.getState().actions.saveState(); 
          const statusEl = document.getElementById('saveStatus');
          if(statusEl) statusEl.textContent = `Auto-save: ${new Date().toLocaleTimeString()}`;
        }catch{
          const statusEl = document.getElementById('saveStatus');
          if(statusEl) statusEl.textContent = 'Auto-save: Failed';
        } 
      }, 600);
    }catch{}
    // Check win conditions after any state change (async to break call stack)
    setTimeout(checkWinConditions, 0);
    
    // Restore cleared emitted cells by re-executing their source anchors
    if(toRestore.length>0 && !Actions._repairing){
      setTimeout(()=>{
        if(Actions._repairing) return;
        Actions._repairing = true;
        try{
          const rtx = Write.start('emit.restore','Restore cleared emitted cells');
          const uniq = new Set(toRestore.map(r=>`${r.arrId}:${r.x},${r.y},${r.z}`));
          uniq.forEach(k=>{ const [aid,coords]=k.split(':'); const [x,y,z]=coords.split(',').map(Number);
            Formula.executeAt({arrId:+aid,x,y,z}, undefined, rtx);
          });
          Write.commit(rtx);
        }catch(e){ console.warn('Restore emitted failed', e); }
        finally{ Actions._repairing = false; }
      },0);
    }
  }
  
  function rollback(tx) {
    for (const op of tx.ops.reverse()) {
      Actions._setCellRaw(op.arrId, {x:op.x, y:op.y, z:op.z}, op.prev);
    }
  }
  
  return { start, set, commit, rollback };
})();

const Actions = {
  // Batch write system for dependency propagation
  _batch: null,
  _repairing: false, // Guard for emission auto-repair
  begin: function() { if(!this._batch) this._batch = { changed:new Set(), tx: Write.start('actions.batch','Grouped setCell') }; },
  end: function() {
    if(!this._batch) return;
    try{
      // Commit once to trigger recompute/renders once at the end of the chain
      if(this._batch.tx){ Write.commit(this._batch.tx); }
      // Consolidated visuals after recompute
    const affectedArrays = new Set();
    for (const k of this._batch.changed) {
      const [arrId, rest] = k.split(':');
      const [x,y,z] = rest.split(',').map(Number);
      const numArrId = +arrId;
      affectedArrays.add(numArrId);
      const arr = Store.getState().arrays[numArrId];
      if(arr && window.UI?.renderSheetCell) window.UI.renderSheetCell(arr, x, y, z);
    }
    const currentArrayId = Store.getState().selection.arrayId;
        if(affectedArrays.has(currentArrayId) && window.UI?.renderSheet) window.UI.renderSheet();
    affectedArrays.forEach(id=>{ const arr=Store.getState().arrays[id]; if(arr) Scene.renderArray(arr); });
    } finally {
    this._batch = null;
    }
  },

  createArray: ({id,name='Array',size={x:6,y:4,z:6},hidden=false,sealed=false,offset={x:0,y:0,z:0}})=>{
    // Determine a stable, unique array ID
    const S0 = Store.getState();
    let arrId;
    if(id !== undefined){
      if(!Number.isInteger(id)) throw new Error('Array ID must be an integer');
      if(id>0 && S0.arrays[id]) throw new Error(`Array with ID ${id} already exists.`);
      // Allow non-positive IDs for reserved/system arrays only (e.g., boot-time arrays)
      arrId = id;
    } else {
      const used = Object.values(S0.arrays).map(a=>a.id).filter(n=>Number.isInteger(n) && n>0);
      const sorted = [...new Set(used)].sort((a,b)=>a-b);
      let next = 1;
      for(const n of sorted){ if(n===next) next++; else if(n>next) break; }
      arrId = next;
    }
      const arr = {
      id:arrId, name, size:{...size}, hidden, sealed,
      state:'ACTIVE', stableCount:0, lastHash:null, lastDepSig:null,
      fnPolicy:{mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()},
      params:{}, locks:new Set(),
      chunks:{}, labels:[], _frame:null, _colliders:[], offset:{...offset}, _occluders:null
    };
    // build chunks sparsely
    const cDims={x:Math.ceil(size.x/CHUNK_SIZE), y:Math.ceil(size.y/CHUNK_SIZE), z:Math.ceil(size.z/CHUNK_SIZE)};
    for(let cz=0;cz<cDims.z;cz++)
      for(let cy=0;cy<cDims.y;cy++)
        for(let cx=0;cx<cDims.x;cx++){
          const ch = new Scene.Chunk(arr, {x:cx,y:cy,z:cz});
          for(let z=0;z<CHUNK_SIZE;z++)
            for(let y=0;y<CHUNK_SIZE;y++)
              for(let x=0;x<CHUNK_SIZE;x++){
                const wx=cx*CHUNK_SIZE+x, wy=cy*CHUNK_SIZE+y, wz=cz*CHUNK_SIZE+z;
                if(wx<size.x&&wy<size.y&&wz<size.z){
                  const cell={x:wx,y:wy,z:wz,value:'',formula:null,meta:{}};
                  ch.cells.push(cell);
                  ch.cellMap.set(`${wx},${wy},${wz}`, cell);
              }
              }
          arr.chunks[keyChunk(cx,cy,cz)] = ch;
        }

    const S=Store.getState();
    // Initialize global grid phase on first array: align its origin cell center to world integer
    if(!S.gridPhase.x&&S.gridPhase.x!==0){
      const phase={x:Math.round(offset.x), y:Math.round(offset.y), z:Math.round(offset.z)};
      Store.setState({gridPhase:phase});
    }
    // Snap offset to global grid phase so cell centers line up across arrays
    const snapAxis=(axis,val,sz)=>{ const phase = Store.getState().gridPhase[axis]||0; const base = (axis==='z') ? (sz/2 - 0.5) : (-(sz/2) + 0.5); return Math.round(val - base - phase) + base + phase; };
    arr.offset={ x:snapAxis('x', offset.x, size.x), y:snapAxis('y', offset.y, size.y), z:snapAxis('z', offset.z, size.z) };
    Store.setState({ arrays:{...S.arrays,[arrId]:arr}, nextArrayId:Math.max(S.nextArrayId, arrId+1), lastCreatedArrayId:arrId });
    Scene.renderArray(arr);
    // Immediately construct LOD1 meshes and rehydrate so new arrays appear without extra interactions
    try{
      Object.values(arr.chunks).forEach(ch=>{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); });
      // Keep this array fully hydrated for a few frames so it is clickable before focus
      arr._warmupFrames = 6;
      // Do NOT apply ghost mask immediately; default new arrays to SOLID (no ghosting)
      try{ forceRenderOrderRefresh?.(false); }catch{}
    }catch{}
    // Snap this array just beyond the max extent of existing arrays with a 1-cell gap
    try{
      const arrays = Object.values(Store.getState().arrays).filter(a=>a && a.id!==arr.id);
      if(arrays.length){
        let maxX=-Infinity; arrays.forEach(a=>{ const x=a.offset?.x||0; maxX=Math.max(maxX, x + a.size.x/2); });
        const desired = { x: Math.round(maxX + 0.5 + arr.size.x/2 + 1), y: arr.offset.y, z: arr.offset.z };
        setArrayOffset(arr, desired, {interactive:true});
      }
    }catch{}
    // Force shell creation by triggering focus if this becomes the active array
    try{
      const currentSel = Store.getState().selection;
      if(!currentSel.arrayId || !Store.getState().arrays[currentSel.arrayId] || Store.getState().arrays[currentSel.arrayId].hidden){
        Actions.setSelection(arrId, {x:0,y:0,z:0});
      }
    }catch{}
    // Apply any pending meta queued for this array (e.g., late onClick/note bindings)
    try{
      const St=Store.getState();
      if(Array.isArray(St.pendingMeta) && St.pendingMeta.length){
        const remain=[]; const ptx=Write.start('pending.meta','Apply pending meta');
        St.pendingMeta.forEach(item=>{
          if(item?.target?.arrId===arrId){
            try{
              const t=item.target; const prior=Formula.getCell({arrId:arrId,x:t.x,y:t.y,z:t.z})||{};
              Write.set(ptx, arrId, {x:t.x,y:t.y,z:t.z}, { value: prior.value??'', formula: prior.formula??null, meta:{...(prior.meta||{}), ...(item.meta||{})} });
            }catch(e){ remain.push(item); }
          } else { remain.push(item); }
        });
        Write.commit(ptx);
        Store.setState({pendingMeta:remain});
        if(remain.length !== St.pendingMeta.length){ try{ UI.renderSheet?.(); }catch{} }
      }
    }catch{}
      return arr;
    },

  deleteArray: (arrId, opts={})=>{
    const S = Store.getState();
    const arr = S.arrays[arrId];
    if(!arr) return false;

    try{ Scene.spawnDeleteExplosion?.(arr); }catch{}

    // Hide immediately in both 3D and 2D
    arr.hidden = true;
    Scene.syncVisibility(arr);

    // Remove 3D graphics and sprites
    try{ Scene.removeArrayGraphics?.(arr); }catch{}

    // Clean emitted tracking
    try{
      const emitted = S.emittedByAnchor;
      const source = S.sourceByCell;
      [...emitted.keys()].forEach(ak=>{
        if(ak.startsWith(`${arrId}:`)) emitted.delete(ak);
      });
      [...source.keys()].forEach(ck=>{
        if(ck.startsWith(`${arrId}:`)) source.delete(ck);
      });
    }catch{}

    // Clean dependency graph for this array
    try{
      const newDepsByAnchor = new Map();
      S.depsByAnchor.forEach((deps, ak)=>{
        if(!ak.startsWith(`${arrId}:`)) newDepsByAnchor.set(ak, deps);
      });
      const newAnchorsByDep = new Map();
      S.anchorsByDep.forEach((anchors, dk)=>{
        if(dk.startsWith(`${arrId}:`)) return;
        const filtered = new Set([...anchors].filter(a => !String(a).startsWith(`${arrId}:`)));
        if(filtered.size) newAnchorsByDep.set(dk, filtered);
      });
      Store.setState({ depsByAnchor:newDepsByAnchor, anchorsByDep:newAnchorsByDep });
    }catch{}

    // Remove from dock groups
    try{
      const ng = new Map(S.dockGroups||new Map());
      ng.forEach((g,k)=>{
        g.members = g.members.filter(id=> id!==arrId);
        if(g.members.length === 0) ng.delete(k);
      });
      Store.setState({ dockGroups: ng });
    }catch{}

    // Remove from array registry
    const arrays = { ...S.arrays };
    delete arrays[arrId];
    Store.setState({ arrays });

    // Reroute selection if necessary
    try{
      const sel = Store.getState().selection;
      if(sel.arrayId === arrId){
        const next = Object.values(Store.getState().arrays).find(a=>!a.hidden) || null;
        if(next) Actions.setSelection(next.id, {x:0,y:Math.max(0,next.size.y-1),z:0}, null, '3d');
        else Store.setState(s=>({ selection:{ arrayId:null, focus:null, anchor:null, range:null } }));
      }
      window.UI?.renderSheet?.();
    }catch{}

    showToast(`Deleted #${arrId}`);
    return true;
  },

  // Raw cell update without notifications or rendering (used by Write system)
  _setCellRaw: (arrayId, coord, cellData)=>{
    const S=Store.getState();
    const arr=S.arrays[arrayId]; if(!arr) return;
    Actions.resizeArrayIfNeeded(arr, coord);
    const c = chunkOf(coord.x,coord.y,coord.z); const k=keyChunk(c.x,c.y,c.z);
    const ch=arr.chunks[k]; if(!ch) return;
    let cell = ch.cellMap?.get(`${coord.x},${coord.y},${coord.z}`);
    if(!cell){
      cell = {x:coord.x, y:coord.y, z:coord.z, value:'', formula:null, meta:{}};
      ch.cells.push(cell);
      ch.cellMap?.set(`${coord.x},${coord.y},${coord.z}`, cell);
    }
    // Auto-revert 3D_ROTATE on clear without requiring execution
    try{
      const beforeFormula = ch.cells[idx]?.formula || null;
      const ak = `${arrayId}:${coord.x},${coord.y},${coord.z}`;
      const clearing = (cellData.formula===null || cellData.formula==='');
      if(clearing && beforeFormula){
        const rec=(S.activeRotations||new Map()).get(ak);
        const suppressed=(S.suppress3DRotateRevert||new Set()).has(ak);
        if(rec && !suppressed){
          const targ=S.arrays[rec.targetId];
          if(targ){
            const ids=rec.ids||[rec.targetId];
            ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
            const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
            const rx=-(rec.steps.sx||0), ry=-(rec.steps.sy||0), rz=-(rec.steps.sz||0);
            ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, rx, ry, rz));
            ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
          }
          const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
          if(suppressed){ const sup=new Set(S.suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
        }
      }
    }catch{}
    Object.assign(cell, cellData);
    try{ ch.markDirty?.(); }catch{}
    arr.state='ACTIVE'; arr.stableCount=0;
  },

  setCell: (arrayId, coord, value, formula=null, noRender=false)=>{
    // Prefer active batch transaction for coherence
    const activeTx = Actions._batch?.tx;
    if(activeTx){
      try{
        Write.set(activeTx, arrayId, coord, { value, formula });
        // Track changed for consolidated post-commit render
        Actions._batch.changed.add(aKey({arrId:arrayId, ...coord}));
        // Defer visuals during batch to avoid mid-chain flicker and wrong states
        return;
      } catch(e){ console.error('batched setCell failed, falling back', e); }
    }
    // Fallback: single-op transaction to preserve dependency semantics
    const tx = Write.start('actions.setCell','single op');
    Write.set(tx, arrayId, coord, { value, formula });
    Write.commit(tx);
  },

  resizeArrayIfNeeded: (arr, coord)=>{
    let changed=false; const newSize={...arr.size};
    if(coord.x>=arr.size.x){ newSize.x=coord.x+1; changed=true; }
    if(coord.y>=arr.size.y){ newSize.y=coord.y+1; changed=true; }
    if(coord.z>=arr.size.z){ newSize.z=coord.z+1; changed=true; }
    if(!changed) return;
    
    // expand chunks
    const oldSize={...arr.size}; arr.size=newSize;
    const cDims={x:Math.ceil(newSize.x/CHUNK_SIZE), y:Math.ceil(newSize.y/CHUNK_SIZE), z:Math.ceil(newSize.z/CHUNK_SIZE)};
    for(let cz=0;cz<cDims.z;cz++)
      for(let cy=0;cy<cDims.y;cy++)
        for(let cx=0;cx<cDims.x;cx++){
          const k=keyChunk(cx,cy,cz); if(arr.chunks[k]) continue;
          const ch = new Scene.Chunk(arr, {x:cx,y:cy,z:cz});
          for(let z=0;z<CHUNK_SIZE;z++)
            for(let y=0;y<CHUNK_SIZE;y++)
              for(let x=0;x<CHUNK_SIZE;x++){
                const wx=cx*CHUNK_SIZE+x, wy=cy*CHUNK_SIZE+y, wz=cz*CHUNK_SIZE+z;
                if(wx<newSize.x&&wy<newSize.y&&wz<newSize.z) ch.cells.push({x:wx,y:wy,z:wz,value:'',formula:null,meta:{}});
              }
          arr.chunks[k] = ch;
        }
    // render new layers if Z grew
    for(let z=0; z<arr.size.z; z++){ Scene.renderLayer(arr,z); }
    Scene.renderArray(arr);
    
    // Update all global references when array expands
    if(changed) {
      Actions.offsetGlobalReferences(arr.id, oldSize, newSize);
    }
    
    // Trigger auto-repair for any emitted cells that might need refilling in the expanded area
    if(!Actions._repairing) {
      const S = Store.getState();
      // Check all source anchors that emit into this array
      S.emittedByAnchor.forEach((emittedSet, sourceAk) => {
        const hasEmptyInExpansion = Array.from(emittedSet).some(ck => {
          const [eArrId, coords] = ck.split(':');
          if(+eArrId !== arr.id) return false;
          const [x, y, z] = coords.split(',').map(Number);
          // Check if this emitted cell is in the newly expanded area and is empty
          const isInExpansion = x >= oldSize.x || y >= oldSize.y || z >= oldSize.z;
          if(isInExpansion) {
            const cell = UI.getCell(arr.id, {x, y, z});
            return cell.value === '' || cell.value === null || cell.value === undefined;
          }
          return false;
        });
        
        if(hasEmptyInExpansion) {
          // Re-execute the source to refill the expansion
          const [aId, rest] = sourceAk.split(':');
          const [sx, sy, sz] = rest.split(',').map(Number);
          setTimeout(() => {
            if(!Actions._repairing) {
              Actions._repairing = true;
              try {
                const tx = Write.start('expand.refill', 'Refill after array expansion');
                Formula.executeAt({arrId: +aId, x: sx, y: sy, z: sz}, undefined, tx);
                Write.commit(tx);
              } finally {
                Actions._repairing = false;
              }
            }
          }, 10); // Small delay to avoid recursion
        }
      });
    }
  },
  // Update all global references when an array expands
  offsetGlobalReferences: (arrayId, oldSize, newSize) => {
    const S = Store.getState();
    const dx = newSize.x - oldSize.x;
    const dy = newSize.y - oldSize.y; 
    const dz = newSize.z - oldSize.z;
    
    if(dx === 0 && dy === 0 && dz === 0) return; // No expansion
    
    console.log(`Offsetting references for array ${arrayId}: expansion (${dx},${dy},${dz})`);
    
    // Update all formulas that reference cells in the expanded array
    Object.values(S.arrays).forEach(arr => {
      Object.values(arr.chunks).forEach(chunk => {
        chunk.cells.forEach(cell => {
          if(cell.formula) {
            // Check if formula contains references to the expanded array
            const refs = cell.formula.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g);
            if(refs) {
              let newFormula = cell.formula;
              refs.forEach(ref => {
                const match = ref.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/);
                if(match && +match[4] === arrayId) {
                  const refX = +match[1], refY = +match[2], refZ = +match[3];
                  // Only offset if reference is beyond the original bounds
                  if(refX >= oldSize.x || refY >= oldSize.y || refZ >= oldSize.z) {
                    const newRef = `@[${refX + (refX >= oldSize.x ? dx : 0)},${refY + (refY >= oldSize.y ? dy : 0)},${refZ + (refZ >= oldSize.z ? dz : 0)},${arrayId}]`;
                    newFormula = newFormula.replace(ref, newRef);
                  }
                }
              });
              
              if(newFormula !== cell.formula) {
                cell.formula = newFormula;
                console.log(`Updated formula: ${cell.formula}`);
              }
            }
          }
        });
      });
    });
    
    // Update dependency graph keys
    const newDepsByAnchor = new Map();
    const newAnchorsByDep = new Map();
    
    S.depsByAnchor.forEach((deps, anchorKey) => {
      const [aId, coords] = anchorKey.split(':');
      if(+aId === arrayId) {
        const [x, y, z] = coords.split(',').map(Number);
        if(x >= oldSize.x || y >= oldSize.y || z >= oldSize.z) {
          const newX = x + (x >= oldSize.x ? dx : 0);
          const newY = y + (y >= oldSize.y ? dy : 0);
          const newZ = z + (z >= oldSize.z ? dz : 0);
          const newKey = `${aId}:${newX},${newY},${newZ}`;
          newDepsByAnchor.set(newKey, deps);
        } else {
          newDepsByAnchor.set(anchorKey, deps);
        }
      } else {
        newDepsByAnchor.set(anchorKey, deps);
      }
    });
    
    S.anchorsByDep.forEach((anchors, depKey) => {
      const [aId, coords] = depKey.split(':');
      if(+aId === arrayId) {
        const [x, y, z] = coords.split(',').map(Number);
        if(x >= oldSize.x || y >= oldSize.y || z >= oldSize.z) {
          const newX = x + (x >= oldSize.x ? dx : 0);
          const newY = y + (y >= oldSize.y ? dy : 0);
          const newZ = z + (z >= oldSize.z ? dz : 0);
          const newKey = `${aId}:${newX},${newY},${newZ}`;
          newAnchorsByDep.set(newKey, anchors);
        } else {
          newAnchorsByDep.set(depKey, anchors);
        }
      } else {
        newAnchorsByDep.set(depKey, anchors);
      }
    });
    
    Store.setState({ depsByAnchor: newDepsByAnchor, anchorsByDep: newAnchorsByDep });
  },

  setSelection:(arrayId, focus, anchor=null, interactionSource='3d')=>{
    Store.setState(s=>({ selection:{arrayId, focus, anchor:anchor||focus, range:null}, ui:{...s.ui, zLayer:focus.z, lastInteraction:interactionSource} }));
    Scene.updateFocus(Store.getState().selection);
    UI.updateFocusChip();
    UI.renderSheet();

    // ---- ON_SELECT dispatch (no-stamp, single tx, recursion-guard) ----
    try {
      const arr=Store.getState().arrays[arrayId];
      const hooks=arr?.onSelectHooks||[];
      if(!hooks.length) return;

      if(Actions._handlingOnSelect) return; // guard against re-entrancy
      Actions._handlingOnSelect = true;

      const {x,y,z}=focus; 
      const addr=formatLocalAddress(arrayId,{x,y,z});
      const tx=Write.start('hook.on_select','ON_SELECT actions');
      for(const h of hooks){
          if(h.cells.has(`${x},${y},${z}`)){
          const action = String(h.action||'').replaceAll('$ADDR',addr);
          Formula.runOnceAt({arrId:arrayId, x:h.anchor.x, y:h.anchor.y, z:h.anchor.z}, action, tx);
        }
      }
      Write.commit(tx);
    } catch(e) {
      console.warn('ON_SELECT hooks failed', e);
    } finally {
      Actions._handlingOnSelect = false;
    }
  },

  setSelectionRange:(arrayId, anchor, focus)=>{
    const xs=[anchor.x,focus.x].sort((a,b)=>a-b), ys=[anchor.y,focus.y].sort((a,b)=>a-b);
    const range={x1:xs[0],y1:ys[0],x2:xs[1],y2:ys[1],z:focus.z};
    Store.setState(s=>({ selection:{arrayId, focus, anchor, range}, ui:{...s.ui, zLayer:focus.z} }));
    Scene.updateFocus(Store.getState().selection);
    UI.updateFocusChip();
    UI.renderSheet();
  },

  moveSelection:(dx,dy,dz=0)=>{
    const s=Store.getState().selection; if(!s.arrayId||!s.focus) return;
    const arr=Store.getState().arrays[s.arrayId]; if(!arr) return;
    const newFocus={x:Math.max(0,Math.min(arr.size.x-1,s.focus.x+dx)), y:Math.max(0,Math.min(arr.size.y-1,s.focus.y+dy)), z:Math.max(0,Math.min(arr.size.z-1,s.focus.z+dz))};
    if(s.range){
      const newAnchor={x:Math.max(0,Math.min(arr.size.x-1,s.anchor.x+dx)), y:Math.max(0,Math.min(arr.size.y-1,s.anchor.y+dy)), z:Math.max(0,Math.min(arr.size.z-1,s.anchor.z+dz))};
      Actions.setSelectionRange(s.arrayId, newAnchor, newFocus);
    } else {
      Actions.setSelection(s.arrayId, newFocus);
    }
  },

  togglePhysics: ()=>{ 
    const next = !Store.getState().scene.physics; 
    Store.setState(s=>({scene:{...s.scene, physics:next}})); 
    // On first enable, build colliders for all arrays to ensure movement/collision works immediately
    if(next){ Object.values(Store.getState().arrays).forEach(a=>Scene.debounceColliderRebuild(a)); }
  },
  toggleGrid: ()=>{ Store.setState(s=>({scene:{...s.scene, showGrid:!s.scene.showGrid}})); Scene.setGridVisible(Store.getState().scene.showGrid); },
  toggleAxes: ()=>{ Store.setState(s=>({scene:{...s.scene, showAxes:!s.scene.showAxes}})); Scene.setAxesVisible(Store.getState().scene.showAxes); },
  setCrystal2D: (enabled)=>{
    const next = !!enabled;
    Store.setState(s=>({ ui:{...s.ui, crystal2D: next} }));
    window.UI?.applyCrystalStyle?.(next);
    return next;
  },
  toggleCrystal2D: ()=>{
    const prev = !!Store.getState().ui?.crystal2D;
    const next = !prev;
    Actions.setCrystal2D(next);
    window.UI?.renderSheet?.();
    return next;
  },
  togglePresentMode: ()=> Scene.togglePresentMode(),
  updateGraphicsSettings: (patch)=> Scene.updateGraphicsSettings(patch || {}),
  // Render mode removed - always use simple mode
  // Undo/Redo system
  // Data history (undo/redo)
  undoData: ()=>{
    if(History.dataPast.length === 0) return;
    const tx = History.dataPast.pop();
    History.dataFuture.push(tx);
    Write.rollback(tx);
    const changed = tx.ops.map(op => `${op.arrId}:${op.x},${op.y},${op.z}`);
    Formula.recomputeAnchors(changed);
    const affectedArrays = new Set(tx.ops.map(op => op.arrId));
    affectedArrays.forEach(id => { const arr = Store.getState().arrays[id]; if(arr){ Scene.renderArray(arr); if(id===Store.getState().selection.arrayId) UI.renderSheet(); } });
  },

  redoData: ()=>{
    if(History.dataFuture.length === 0) return;
    const tx = History.dataFuture.pop();
    History.dataPast.push(tx);
    tx.ops.forEach(op => { Actions._setCellRaw(op.arrId, {x:op.x, y:op.y, z:op.z}, op.next); });
    const changed = tx.ops.map(op => `${op.arrId}:${op.x},${op.y},${op.z}`);
    Formula.recomputeAnchors(changed);
    const affectedArrays = new Set(tx.ops.map(op => op.arrId));
    affectedArrays.forEach(id => { const arr = Store.getState().arrays[id]; if(arr){ Scene.renderArray(arr); if(id===Store.getState().selection.arrayId) UI.renderSheet(); } });
  },
};

/* ===========================
   Function Registry + Policy
=========================== */
const ALWAYS = new Set([
  'FUNCTIONS','LOCK','CREATE','ARRAY','PARAMETERS','ADDRESS','ALT_ADDRESS','COMBINE','COLOR','GETCOLOR',
  'ON_SELECT','ON_EVENT','FIRE_EVENT','SET_GLOBAL','GET_GLOBAL','FOCUS_SET','COPY',
  'SOKOBAN','SOKO_STEP','SOKOBAN2','SOKO_STEP2','SSR','SSR_STEP','DEP_VIS','GET_ARRAY_POS','SET_ARRAY_POS','TRANSLATE_ARRAY','ROTATE_ARRAY',
  'INVENTORY','3D_TRANSLATE','3D_ROTATE','DELETE','DEL','REMOVE','LIGHT','CHIME'
]);
const Fn = {}; // name -> {tags:[...], impl(anchor, arr, ast)}
const tag = (name,tags,impl)=>{ Fn[name]={tags:new Set(tags),impl}; };
// helper: policy check with proper tag filtering
function isAllowed(arr, fnName){
  if(ALWAYS.has(fnName)) return true;
  const pol=arr.fnPolicy||{mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()};
  const fnTags = Fn[fnName]?.tags || new Set();

  if(pol.mode==='ALLOW_ONLY'){
    if(pol.allow?.has(fnName)) return true;
    if(pol.tags?.size && [...pol.tags].some(t => fnTags.has(t))) return true;
    return false;
  }
  // ALLOW_ALL with optional deny / tag filter
  if(pol.deny?.has(fnName)) return false;
  if(pol.tags?.size) return [...pol.tags].some(t => fnTags.has(t));
  return true;
}

// Utility tags (registered after policy init)
// 3D_TRANSLATE(target, dx, dy, dz[, originRef])
// - target: array id (number) or ref within target array; if ref, its arrId is used
// - dx,dy,dz: integer notch offsets (snap grid)
// - originRef: optional ref used only for semantic symmetry; translation is uniform so origin isn't needed, but kept for API parity
tag('3D_TRANSLATE',["SCENE"],(anchor,arr,ast)=>{
  // Args: target (arrId | ref | "@[x,y,z,id]" | SELF()), dx, dy, dz[, continuous]
  const targetArg = ast.args[0];
  const toInt = (a)=>{ try{ const v = Formula.valOf(a); const s = String(v==null? a : v); const n = parseFloat(s.replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? (n|0) : 0; }catch{ return 0; } };
  const dx = toInt(ast.args[1]);
  const dy = toInt(ast.args[2]);
  const dz = toInt(ast.args[3]);
  const cont = !!toInt(ast.args[4]||0);

  const S = Store.getState();
  let targetArr = null;
  let queueAnchor = anchor; // default to the calling cell if no explicit ref provided

  if(targetArg && targetArg.kind==='ref'){
    targetArr = S.arrays[targetArg.arrId];
    queueAnchor = { x:targetArg.x, y:targetArg.y, z:targetArg.z, arrId: targetArg.arrId };
  } else {
    const raw = Formula.valOf(targetArg);
    // Try parsing absolute ref strings like SELF() => "@[x,y,z,id]"
    if(typeof raw === 'string'){
      try{
        const parsed = parseAlt(raw, anchor);
        if(parsed && S.arrays[parsed.arrId]){
          targetArr = S.arrays[parsed.arrId];
          queueAnchor = { x:parsed.x, y:parsed.y, z:parsed.z, arrId: parsed.arrId };
        }
      }catch{}
    }
    if(!targetArr){
      const id = +raw;
      if(Number.isFinite(id) && S.arrays[id]){
        targetArr = S.arrays[id];
        // If only an ID was provided, anchor defaults to A1α of the target for preview semantics
        queueAnchor = { x:0, y:0, z:0, arrId:id };
      }
    }
  }

  if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }

  // If PREVIEW is on (in-array or 3D), do not apply now; animation system will read formulas
  let timed = null; try{ if(typeof Scene!=='undefined' && Scene.ensureTimedState) timed = Scene.ensureTimedState(targetArr); }catch{}
  const G0 = (Store.getState().scene||{}).timed3D;
  if((timed && timed.previewInArray) || (G0 && G0.preview)){
    return;
  }

  // Non-repeat executable: if this anchor already applied a translate, skip
  try{
    const ak=aKey(anchor);
    const existing=(Store.getState().activeTranslations||new Map()).get(ak);
    if(existing && !cont){ Actions.setCell(arr.id, anchor, `3D_Translate:skip`, (ast.raw||`=3D_TRANSLATE(...)`)); return; }
  }catch{}

  // Immediate translation respecting docking/parentage (apply to group as a unit)
  const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(targetArr.id));
  const ids = group
    ? (group.mode==='parent'
        ? [targetArr.id, ...group.members.filter(id=> id!==targetArr.id && group.members.indexOf(id) > group.members.indexOf(targetArr.id))]
        : [...group.members])
    : [targetArr.id];
  const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);
  arrays.forEach(a=>{
    const offA = a.offset||{x:0,y:0,z:0};
    const nextA = { x: Math.round((offA.x||0) + dx), y: Math.round((offA.y||0) + dy), z: Math.round((offA.z||0) + dz) };
    Scene.setArrayOffset(a, nextA, {interactive:true, _skipDock:true, _skipConnections:true});
  });
  Actions.setCell(arr.id, anchor, `Moved:${dx},${dy},${dz}`, ast.raw, true);
  // Record for revert when this anchor's formula is cleared; suppress repeat execution
  try{
    const S=Store.getState();
    const ak=aKey(anchor);
    const map=new Map(S.activeTranslations||new Map());
    map.set(ak, { targetId: targetArr.id, from:{...off}, delta:{dx,dy,dz} });
    Store.setState({activeTranslations:map});
    // Persist revert info in meta so refresh can restore revert behavior
    const txw = Write.start('mark.3d.translate','mark');
    const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
    Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedTranslate:{ targetId: targetArr.id, from: off, delta:{dx,dy,dz} } } });
    Write.commit(txw);
  }catch{}
});
// 3D_ROTATE(targetOrPivot, stepsX[, stepsY[, stepsZ]])
// - First arg: array ID or cell address (pivot + derives array ID). If ID, pivot defaults to A1α.
// - If ref has no ^arrId, it uses the host array (anchor's array).
// - Rotates entire docked structure (Parent or All modes) atomically around the pivot.
tag('3D_ROTATE',["SCENE"],(anchor,arr,ast)=>{
  const targetArg = ast.args[0];
  const sx = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[1])|0) || 0) : ((+Formula.valOf(ast.args[1]||0)|0));
  const sy = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[2])|0) || 0) : 0;
  const sz = ast.args[3]!==undefined ? ((+Formula.valOf(ast.args[3])|0) || 0) : 0;

  const S=Store.getState();
  let targetId=null, pivotRef=null;
  if(targetArg && targetArg.kind==='ref'){
    targetId = targetArg.arrId ?? arr.id;
    pivotRef = {x:targetArg.x,y:targetArg.y,z:targetArg.z,arrId:targetId};
  } else if(targetArg!==undefined){
    const id=+Formula.valOf(targetArg); if(!isNaN(id)) targetId=id;
  }
  if(targetId==null) targetId = arr.id;
  const targetArr = S.arrays[targetId];
  if(!targetArr){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }
  // If no explicit pivot, default to A1α (0,0,0)
  if(!pivotRef) pivotRef={x:0,y:0,z:0,arrId:targetId};

  // Resolve dock group membership
  const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(targetArr.id));
  const ids = group
    ? (group.mode==='parent'
        ? [targetArr.id, ...group.members.filter(id=> id!==targetArr.id && group.members.indexOf(id) > group.members.indexOf(targetArr.id))]
        : [...group.members])
    : [targetArr.id];
  const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);

  // Timed preview queue (in-array or 3D)
  const timed0 = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(arr) : (arr.params&&arr.params.timed);
  const G0 = (typeof Scene!=='undefined' && Scene.ensureTimed3D) ? Scene.ensureTimed3D() : ((Store.getState().scene||{}).timed3D);
  if(timed0?.previewInArray || (G0&&G0.preview)){
    queueTimedOp(arr, pivotRef||anchor, { type:'rotate', sx, sy, sz });
    Actions.setCell(arr.id, anchor, `Queued:Rot ${sx},${sy},${sz}`,(ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`));
    return;
  }
  // Ensure frames
  arrays.forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
  // Compute pivot in world space at time of rotation
  const pivotWorld = Scene.cellWorldPos(targetArr, pivotRef.x, pivotRef.y, pivotRef.z);

  // Apply atomic rotation
  arrays.forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));
  arrays.forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});

  // Track for revert when this anchor formula is removed
  try{
    const ak=aKey(anchor);
    const rec={targetId:targetArr.id, ids:[...ids], pivot:{...pivotRef}, steps:{sx,sy,sz}};
    const map=new Map(S.activeRotations||new Map()); map.set(ak, rec); Store.setState({activeRotations:map});
  }catch{}

  Actions.setCell(arr.id, anchor, `3D_Rotate:${targetArr.id};${sx},${sy},${sz}`, ast.raw, true);
});

// Backward-compatible alias: ROTATE_ARRAY delegates to 3D_ROTATE
tag('ROTATE_ARRAY',["SCENE"],(anchor,arr,ast)=> Fn['3D_ROTATE'].impl(anchor,arr,ast));
tag('PRIORITY',['META'], (anchor,arr,ast)=>{
  const target = ast.args[0];
  const level  = (+Formula.valOf(ast.args[1])|0) || 0;
  const mode   = (String(Formula.valOf(ast.args[2]||'value')).toLowerCase()==='coord')?'coord':'value';
  const sort   = (()=>{ try{ return JSON.parse(String(Formula.valOf(ast.args[3]||'{}'))||'{}'); }catch{ return {}; }})();

  const items=[]; const push=(x,y,z)=>items.push({x,y,z, arrId:target?.arrId ?? arr.id});
  if(target && target.kind==='range') target.cells.forEach(c=>push(c.x,c.y,c.z));
  else if(target && target.kind==='ref') push(target.x,target.y,target.z);
  else push(anchor.x,anchor.y,anchor.z);

  arr.priority = arr.priority || [];
  arr.priority.push({level, mode, sort, items});
});

tag('FORMULA_TEXT',['PURE'], (anchor,arr,ast)=>{
  const t = (ast.args[0] && ast.args[0].kind==='ref') ? ast.args[0] : anchor;
  const c = Formula.getCell({arrId:t.arrId||arr.id, x:t.x, y:t.y, z:t.z});
  const f = c?.formula ?? '';
  Actions.setCell(arr.id, anchor, f, ast.raw, true);
});

// CREATE(x,y,z[, "Name"[, "Id"]]) — optional explicit ID supported
tag('CREATE',["ACTION"],(anchor,arr,ast)=>{
  try{
    const args = ast.args.map(a => Formula.valOf(a));

    let sx = 6, sy = 4, sz = 6, name = 'Array', explicitId = null;
    let argOffset = 0;

    if (args.length > 0 && typeof args[0] === 'string') {
        name = args[0];
        argOffset = 1;
    }

    if (args.length >= argOffset + 1 && Number.isFinite(+args[argOffset])) sx = Math.max(1, (+args[argOffset] | 0));
    if (args.length >= argOffset + 2 && Number.isFinite(+args[argOffset + 1])) sy = Math.max(1, (+args[argOffset + 1] | 0));
    if (args.length >= argOffset + 3 && Number.isFinite(+args[argOffset + 2])) sz = Math.max(1, (+args[argOffset + 2] | 0));

    if (argOffset === 0 && args.length >= 4) name = String(args[3]);
    const idArgIndex = 4;
    if (args.length > idArgIndex && args[idArgIndex] != null) {
        const n = +args[idArgIndex];
        if (Number.isFinite(n)) explicitId = Math.trunc(n);
    }

    const opts = { name, size: {x: sx, y: sy, z: sz} };
    if(explicitId !== null) opts.id = explicitId;

    const created = Actions.createArray(opts);
    if (!created) throw new Error('Array creation failed internally.');

    const host = arr, newArr = created, gap = 1.0;
    const hostOff = host.offset || {x:0, y:0, z:0};
    const newX = hostOff.x + (host.size.x / 2) + (newArr.size.x / 2) + gap;
    Scene.setArrayOffset(newArr, {x: newX, y: hostOff.y, z: hostOff.z});

    Actions.setCell(arr.id, anchor, created.id, null, true);

  } catch(e) {
    Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
  }
});

// GET_NEXT_ID(): returns the lowest available positive integer ID
tag('GET_NEXT_ID',["META","PURE"],(anchor,arr,ast)=>{
  const ids = Object.values(Store.getState().arrays).map(a=>a.id).filter(id=>Number.isInteger(id) && id>0);
  const sorted = [...new Set(ids)].sort((a,b)=>a-b);
  let next=1; for(const n of sorted){ if(n===next) next++; else if(n>next) break; }
  Actions.setCell(arr.id, anchor, next, ast.raw, true);
});
// FORMULIZE(targetRef): builds a kickoff DO formula capturing arrays reachable from target
tag('FORMULIZE',["META","ACTION"],(anchor,arr,ast)=>{
  try{
    const target = ast.args[0] && ast.args[0].kind==='ref' ? ast.args[0] : anchor;
    const startId = target.arrId || arr.id;
    const S = Store.getState();
    if(!S.arrays[startId]){ Actions.setCell(arr.id, anchor, '!ERR:TARGET', ast.raw, true); return; }
    // BFS through formulas to find referenced array IDs
    const q=[startId]; const seen=new Set([startId]);
    while(q.length){
      const id=q.shift(); const A=S.arrays[id]; if(!A) continue;
      Object.values(A.chunks).forEach(ch=>{
        ch.cells.forEach(cell=>{
          if(!cell.formula) return;
          const matches = cell.formula.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g) || [];
          matches.forEach(m=>{ const mm=m.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/); const refId=+mm[4]; if(refId>0 && !seen.has(refId) && S.arrays[refId]){ seen.add(refId); q.push(refId);} });
          const carats = cell.formula.match(/\^[0-9]+/g) || [];
          carats.forEach(tk=>{ const refId=+(tk.slice(1)); if(refId>0 && !seen.has(refId) && S.arrays[refId]){ seen.add(refId); q.push(refId);} });
        });
      });
    }
    const ids = Array.from(seen).sort((a,b)=>a-b);
    const idMap = new Map(ids.map((id,i)=>[id, `temp.id_${i+1}`]));
    const esc=(s)=> String(s).replace(/"/g,'\\\"');
    const lines=[];
    // Reserve IDs
    ids.forEach(id=>{ const key=idMap.get(id); lines.push(`"=SET_GLOBAL(\\\"${key}\\\", GET_NEXT_ID())"`); });
    // CREATE arrays (with proper escaping inside outer string)
    ids.forEach(id=>{
      const A=S.arrays[id]; const nm=esc(A.name||'Array');
      const size=`${A.size.x}, ${A.size.y}, ${A.size.z}`;
      lines.push(`"=CREATE(${size}, \\\"${nm}\\\", GET_GLOBAL(\\\"${idMap.get(id)}\\\"))"`);
    });
    // Populate values and formulas efficiently by aggregating contiguous 3D blocks
    ids.forEach(id=>{
      const A=S.arrays[id];
      const idExpr = `GET_GLOBAL(\\\"${idMap.get(id)}\\\")`;
      // Build occupancy and value hash per cell
      const W=A.size.x,H=A.size.y,D=A.size.z;
      const occ=new Map(); // key x,y,z -> {v, f}
      Object.values(A.chunks).forEach(ch=>{ ch.cells.forEach(c=>{ const k=`${c.x},${c.y},${c.z}`; occ.set(k,{v:c.value,f:c.formula}); }); });
      const visited=new Set();
      const key=(x,y,z)=>`${x},${y},${z}`;
      const inb=(x,y,z)=> x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;
      // Helper to emit a fill block via EXEC_AT to avoid dynamic A1^id refs
      const emitFill=(x1,y1,z1,x2,y2,z2,val)=>{
        const w=x2-x1+1,h=y2-y1+1,d=z2-z1+1;
        const v = typeof val==='string' ? `\"${esc(val)}\"` : `${val}`;
        // Use EXEC_AT with ARRAY("fill",...) at (x1,y1,z1) inside target array idExpr
        lines.push(`"=EXEC_AT(${x1},${y1},${z1}, ${idExpr}, \"=ARRAY(\\\"fill\\\", ${w}, ${h}, ${d}, ${v})\")"`);
      };
      // Greedy 3D block aggregation for identical scalar values
      for(let z=0;z<D;z++) for(let y=0;y<H;y++) for(let x=0;x<W;x++){
        const k=key(x,y,z); if(visited.has(k)) continue; const cell=occ.get(k)||{v:'',f:null};
        if(cell.f || cell.v==='' || cell.v===null || cell.v===undefined){ continue; }
        // grow in X
        let x2=x; while(inb(x2+1,y,z)){ const c=occ.get(key(x2+1,y,z))||{v:'',f:null}; if(visited.has(key(x2+1,y,z)) || c.f || c.v!==cell.v) break; x2++; }
        // grow in Y
        let y2=y; outerY: while(inb(x,y2+1,z)){
          for(let xi=x; xi<=x2; xi++){ const c=occ.get(key(xi,y2+1,z))||{v:'',f:null}; if(visited.has(key(xi,y2+1,z)) || c.f || c.v!==cell.v){ break outerY; } }
          y2++;
        }
        // grow in Z
        let z2=z; outerZ: while(inb(x,y,z2+1)){
          for(let yi=y; yi<=y2; yi++) for(let xi=x; xi<=x2; xi++){ const c=occ.get(key(xi,yi,z2+1))||{v:'',f:null}; if(visited.has(key(xi,yi,z2+1)) || c.f || c.v!==cell.v){ break outerZ; } }
          z2++;
        }
        // mark visited and emit
        for(let zz=z; zz<=z2; zz++) for(let yy=y; yy<=y2; yy++) for(let xx=x; xx<=x2; xx++) visited.add(key(xx,yy,zz));
        emitFill(x,y,z,x2,y2,z2,cell.v);
      }
      // Emit formulas with ID remapping using EXEC_AT for precise stamping
      Object.values(A.chunks).forEach(ch=>{
        ch.cells.forEach(c=>{
          if(!c.formula) return;
          let f=String(c.formula);
          ids.forEach(oldId=>{ const keyVar=idMap.get(oldId); f=f.replace(new RegExp(`\\^${oldId}\\b`,'g'), `^" & GET_GLOBAL(\\\"${keyVar}\\\") & "`); f=f.replace(new RegExp(`@\\[(-?\\d+),(-?\\d+),(-?\\d+),${oldId}\\]`,'g'), `@[" & $1 & "," & $2 & "," & $3 & "," & GET_GLOBAL(\\\"${keyVar}\\\") & "]`); });
          const tx = `=EXEC_AT(${c.x},${c.y},${c.z}, ${idExpr}, \"${esc(f)}\")`;
          lines.push(`"${tx}"`);
        });
      });
      // Set positions
      const off=A.offset||{x:0,y:0,z:0};
      lines.push(`"=SET_ARRAY_POS(${idExpr}, ${Math.round(off.x)}, ${Math.round(off.y)}, ${Math.round(off.z)})"`);
    });
    // Self cleanup
    lines.push(`"=SET(SELF(), \"\")"`);
    const out = `=DO(\n  ${lines.join(',\n  ')}\n)`;
    Actions.setCell(arr.id, anchor, out, ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// SPLIT(text, delimiter[, splitByEach]) -> array of tokens (vertical list starting at anchor)
tag('SPLIT',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('SPLIT requires active transaction');
  const text = String(Formula.valOf(ast.args[0] ?? ''));
  const delimRaw = Formula.valOf(ast.args[1] ?? '');
  const splitByEach = !!Formula.valOf(ast.args[2] ?? 0);
  const delims = String(delimRaw);
  let parts;
  if(splitByEach){
    const re = new RegExp(`[${delims.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')}]`, 'g');
    parts = text.split(re);
  } else {
    parts = delims==='' ? [text] : text.split(delims);
  }
  for(let i=0;i<parts.length;i++){
    Write.set(tx, arr.id, {x:anchor.x, y:anchor.y-i, z:anchor.z}, { value: parts[i], formula: i===0?ast.raw:null, meta:{generated:true, emitter:aKey(anchor)} });
  }
});
// INDEX(rangeOrRef, row[, col[, depth]]) — 1-based; supports 3D offsets
tag('INDEX',['PURE'], (anchor,arr,ast)=>{
  const tgt = ast.args[0];
  const r = (+Formula.valOf(ast.args[1])|0) || 1;
  const c = (+Formula.valOf(ast.args[2])|0) || 1;
  const d = ast.args[3]!==undefined ? ((+Formula.valOf(ast.args[3])|0) || 1) : 1;
  let ref;
  if(tgt && tgt.kind==='range'){
    const xs=[...new Set(tgt.cells.map(t=>t.x))].sort((a,b)=>a-b);
    const ys=[...new Set(tgt.cells.map(t=>t.y))].sort((a,b)=>a-b);
    const zs=[...new Set(tgt.cells.map(t=>t.z))].sort((a,b)=>a-b);
    const x=xs[Math.min(xs.length-1, Math.max(0, c-1))];
    const y=ys[Math.min(ys.length-1, Math.max(0, r-1))];
    const z=zs[Math.min(zs.length-1, Math.max(0, d-1))];
    ref = {x,y,z,arrId:tgt.cells[0].arrId,kind:'ref'};
  } else if(tgt && tgt.kind==='ref'){
    ref = {x:tgt.x+(c-1), y:tgt.y+(r-1), z:tgt.z+(d-1), arrId:tgt.arrId, kind:'ref'};
  } else {
    ref = anchor;
  }
  const v = Formula.getCellValue(ref);
  Actions.setCell(arr.id, anchor, v, ast.raw, true);
});

// MATCH(lookup, range[, matchType]) — returns 1-based position along linearized order
tag('MATCH',['PURE'], (anchor,arr,ast)=>{
  const lookup = Formula.valOf(ast.args[0]);
  const tgt = ast.args[1];
  const matchType = (+Formula.valOf(ast.args[2] ?? 0))|0; // 0 exact
  let cells = [];
  if(tgt && tgt.kind==='range') cells = tgt.cells;
  else if(tgt && tgt.kind==='ref') cells = [{x:tgt.x,y:tgt.y,z:tgt.z,arrId:tgt.arrId}];
  let pos = 0;
  for(let i=0;i<cells.length;i++){
    const v = Formula.getCellValue(cells[i]);
    if(matchType===0){ if(String(v)===String(lookup)){ pos=i+1; break; } }
    else { const nv=(+v)||0, nl=(+lookup)||0; if((matchType>0 && nv<=nl) || (matchType<0 && nv>=nl)){ pos=i+1; } }
  }
  Actions.setCell(arr.id, anchor, pos, ast.raw, true);
});

// XLOOKUP(lookup, rangeKeys, rangeVals[, ifNotFound])
tag('XLOOKUP',['PURE'], (anchor,arr,ast)=>{
  const lookup = Formula.valOf(ast.args[0]);
  const keys = ast.args[1];
  const vals = ast.args[2];
  const ifNotFound = ast.args[3]!==undefined ? Formula.valOf(ast.args[3]) : '';
  const toList=(arg)=> (arg && arg.kind==='range') ? arg.cells : (arg && arg.kind==='ref') ? [arg] : [];
  const keyCells = toList(keys);
  const valCells = toList(vals);
  let out = ifNotFound;
  for(let i=0;i<keyCells.length;i++){
    if(String(Formula.getCellValue(keyCells[i]))===String(lookup)){
      const vc = valCells[i] || valCells[0];
      out = vc ? Formula.getCellValue(vc) : ifNotFound;
      break;
    }
  }
  Actions.setCell(arr.id, anchor, out, ast.raw, true);
});

// Matrix utilities + TRANSPOSE
function toMatrix(anchor, arr, arg){
  const val=(r)=> Formula.getCellValue({arrId:r.arrId||arr.id,x:r.x,y:r.y,z:r.z});
  try{
    if(arg && arg.kind==='range'){
      const cells=arg.cells||[]; if(cells.length===0) return [[""]];
      const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
      const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
      const z0=cells[0].z; const map=new Map();
      cells.forEach(c=>{ if(c.z===z0) map.set(`${c.x},${c.y}`, val(c)); });
      const M=[]; for(let yi=0; yi<ys.length; yi++){ const row=[]; for(let xi=0; xi<xs.length; xi++){ const k=`${xs[xi]},${ys[yi]}`; row.push(map.has(k)? map.get(k) : ""); } M.push(row);} return M;
    }
    if(arg && arg.kind==='ref') return [[ val(arg) ]];
    if(arg && arg.type==='FunctionCall' && String(arg.name||'').toUpperCase()==='ARRAY'){
      const mode= String(Formula.valOf(arg.arguments[0]||'list')||'list').toLowerCase();
      if(mode==='list'){ const items = arg.arguments.slice(1).map(a=> Formula.valOf(a)); return items.map(v=>[v]); }
      if(mode==='fill'){ const w=(+Formula.valOf(arg.arguments[1]||1))|0, h=(+Formula.valOf(arg.arguments[2]||1))|0; const v=Formula.valOf(arg.arguments[4]||""); const M=[]; for(let y=0;y<Math.max(1,h);y++){ const row=[]; for(let x=0;x<Math.max(1,w);x++) row.push(v); M.push(row);} return M; }
      return [[ String(Formula.valOf(arg.arguments[1]||'')) ]];
    }
    const maybeId=+Formula.valOf(arg);
    if(Number.isFinite(maybeId)){
      const A=Store.getState().arrays[maybeId]; if(A){ const z=Math.max(0,Math.min(A.size.z-1,anchor.z|0)); const M=[]; for(let y=0;y<A.size.y;y++){ const row=[]; for(let x=0;x<A.size.x;x++){ row.push(Formula.getCellValue({arrId:A.id,x,y,z})); } M.push(row);} return M; }
    }
  }catch{}
  return [[ Formula.valOf(arg) ]];
}

console.log('Registering TRANSPOSE function...');
tag('TRANSPOSE',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
  const __ownsTx = !tx; if(__ownsTx) tx = Write.start('transpose.auto','TRANSPOSE');
  console.log('=== TRANSPOSE DEBUG START ===');
  console.log('TRANSPOSE called with:', {
    anchor: `${anchor.x},${anchor.y},${anchor.z}`,
    arrayId: arr.id,
    astRaw: ast.raw,
    astFn: ast.fn,
    astArgs: ast.args,
    argCount: ast.args?.length,
    hasTx: !!tx,
    ownsTx: __ownsTx
  });
  // Debug: check if we have _astArgs (raw AST arguments)
  if(ast._astArgs) console.log('Raw AST args:', ast._astArgs);
  try{
    // Clear previously emitted cells from this anchor
    const S=Store.getState(); const ak=aKey(anchor);
    const prev=S.emittedByAnchor?.get?.(ak);
    if(prev){
      prev.forEach(ck=>{ try{ const [aid,rest]=ck.split(':'); const [cx,cy,cz]=rest.split(',').map(Number); Write.set(tx,+aid,{x:cx,y:cy,z:cz},{ value:'', formula:null, meta:{} }); S.sourceByCell?.delete?.(ck); }catch{} });
      S.emittedByAnchor?.delete?.(ak);
    }

    // Track emissions for proper cleanup and visuals
    const emitted = new Set();
    const recordEmit = (x,y,z)=>{ const ck=`${arr.id}:${x},${y},${z}`; emitted.add(ck); if(!S.sourceByCell) S.sourceByCell=new Map(); S.sourceByCell.set(ck,ak); };
  // Ensure array can hold target then write & record
  const ensureAndWrite = (x,y,z,v,isAnchorWrite)=>{
    if(z<0){ try{ Actions.expandZFront?.(arr, -z); }catch{} }
    try{ Actions.resizeArrayIfNeeded(arr, {x,y,z}); }catch{}
    const isAnchor=(x===anchor.x && y===anchor.y && z===anchor.z);
    if(!isAnchor || isAnchorWrite){
      Write.set(tx, arr.id, {x,y,z}, { value:v, formula:(isAnchor?ast.raw:null), meta:{generated:true, emitter:ak} });
      recordEmit(x,y,z);
    }
  };

    // Check if we have any arguments
    if(!ast.args || ast.args.length === 0){
      console.log('No arguments provided to TRANSPOSE, trying to parse raw formula');
      // Try to parse the raw formula string as fallback
      const raw = ast.raw || '';
      const match = raw.match(/transpose\s*\(\s*(.+)\s*\)/i);
      if(match){
        const argStr = match[1];
        console.log('Found raw argument string:', argStr);
        // Try to parse ARRAY(...) from string
        const arrayMatch = argStr.match(/array\s*\(\s*(.+)\s*\)/i);
        if(arrayMatch){
          const arrayContent = arrayMatch[1];
          console.log('Found ARRAY content:', arrayContent);
          // Split by comma and evaluate each part
          const parts = arrayContent.split(',').map(s => s.trim());
          console.log('ARRAY parts:', parts);
          const values = parts.map(p => {
            // Remove quotes if present
            const clean = p.replace(/^["']|["']$/g, '');
            const num = +clean;
            return Number.isNaN(num) ? clean : num;
          });
          console.log('Parsed values:', values);
          // Create column matrix
          const M = values.map(v => [v]);
          console.log('Created matrix from raw parsing:', M);
          
          // Skip to transpose logic
          const H=M.length; const W=M[0].length;
          console.log('Raw parse matrix dimensions:', {H, W, M});
          
          // Optional axis & dir  
          const axis = 0; // default XY
          const dir = 0; // default positive
          
          // The destination matrix has dimensions WxH (transpose)
          for(let r=0;r<W;r++){
            for(let c=0;c<H;c++){
              const v=(M[c]&&M[c][r]!==undefined)?M[c][r]:"";
              
              let txX=anchor.x + (dir ? -c : c);
              let txY=anchor.y + r;  
              let txZ=anchor.z;
              
              console.log(`Raw parse writing cell [${r},${c}]: value="${v}" to (${txX},${txY},${txZ})`);
              ensureAndWrite(txX,txY,txZ, v, (r===0&&c===0));
            }
          }
          
          // Record all emissions for cleanup
          if(emitted.size > 0){
            if(!S.emittedByAnchor) S.emittedByAnchor = new Map();
            S.emittedByAnchor.set(ak, emitted);
          }
          
          console.log('Raw parse TRANSPOSE completed, emitted:', emitted.size, 'cells');
          if(__ownsTx) Write.commit(tx);
          return;
        }
      }
      
      Write.set(tx, arr.id, anchor, { value: '!ERR:TRANSPOSE needs an argument', formula: ast.raw, meta: { emitter: ak } });
      if(__ownsTx) Write.commit(tx);
      return;
    }

    // Try to get matrix from input - handle both ranges and ARRAY() calls
    let M = null;
    let srcArg = ast.args[0];
    console.log('srcArg from ast.args[0]:', srcArg);
    
    // If ast.args[0] is undefined but we have _astArgs, use that instead
    if(!srcArg && ast._astArgs && ast._astArgs.length > 0) {
      srcArg = ast._astArgs[0];
      console.log('Using _astArgs[0] instead:', srcArg);
    }
    
    console.log('Final srcArg:', srcArg);
    
    // First try the toMatrix helper
    try { M = toMatrix(anchor,arr,srcArg); console.log('toMatrix result:', M); } catch(e){ console.log('toMatrix failed:', e); }
    
    // If that fails, handle ARRAY() calls manually
    // Also check for [object Object] which indicates toMatrix failed to parse the AST
    const isEmptyOrBadMatrix = !M || M.length === 0 || 
      (M.length === 1 && M[0].length === 1 && (M[0][0] === '' || String(M[0][0]).includes('[object Object]')));
    
    if(isEmptyOrBadMatrix) {
      console.log('toMatrix failed, trying manual parsing');
      // Check for AST-style ARRAY call
      if(srcArg && (srcArg.type === 'FunctionCall' || srcArg.fn) && String(srcArg.name || srcArg.fn || '').toUpperCase()==='ARRAY'){
        try{
          console.log('Handling ARRAY() call, srcArg:', srcArg);
          // Handle both AST-style (srcArg.arguments) and legacy-style (srcArg.args)
          const argList = srcArg.arguments || srcArg.args || [];
          console.log('ARRAY argList:', argList);
          const values = argList.map(a=> {
            // Handle different argument formats
            if(a && typeof a === 'object' && 'value' in a) return a.value;
            if(a && typeof a === 'object' && a.type === 'Literal') return a.value;
            return Formula.valOf(a);
          });
          console.log('ARRAY values:', values);
          M = values.map(v => [v]); // Convert to column matrix
          console.log('Created matrix:', M);
        }catch(e){ console.log('ARRAY parsing failed:', e); }
      } else if(srcArg && srcArg.kind==='range'){
        console.log('Handling range directly');
        // Handle range directly
        const cells = srcArg.cells||[];
        if(cells.length > 0){
          const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
          const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
          const z0=cells[0].z; const map=new Map();
          cells.forEach(c=>{ if(c.z===z0) map.set(`${c.x},${c.y}`, Formula.getCellValue({arrId:c.arrId||arr.id,x:c.x,y:c.y,z:c.z})); });
          M=[]; for(let yi=0; yi<ys.length; yi++){ const row=[]; for(let xi=0; xi<xs.length; xi++){ const k=`${xs[xi]},${ys[yi]}`; row.push(map.has(k)? map.get(k) : ""); } M.push(row);}
          console.log('Range matrix:', M);
        }
      } else {
        console.log('Fallback: treating as single value');
        const val = Formula.valOf(srcArg);
        M = [[val]];
        console.log('Single value matrix:', M);
      }
    }

    if (!M || M.length === 0 || M[0].length === 0) {
      console.log('No valid matrix, stamping anchor with empty value');
      // If still no valid input, stamp anchor with formula and empty value
      Write.set(tx, arr.id, anchor, { value: '', formula: ast.raw, meta: { emitter: ak } });
      if(__ownsTx) Write.commit(tx);
      return;
    }
    
    const H=M.length; const W=M[0].length;
    console.log('Final matrix dimensions:', {H, W, M});

    // Optional axis & dir - check both legacy args and _astArgs
    let axisRaw = 0, dirRaw = 0;
    if(ast.args && ast.args[1] !== undefined) {
      axisRaw = Formula.valOf(ast.args[1]);
    } else if(ast._astArgs && ast._astArgs[1]) {
      axisRaw = Formula.valOf(ast._astArgs[1]);
    }
    if(ast.args && ast.args[2] !== undefined) {
      dirRaw = Formula.valOf(ast.args[2]);
    } else if(ast._astArgs && ast._astArgs[2]) {
      dirRaw = Formula.valOf(ast._astArgs[2]);
    }
    
    const axisStr = String(axisRaw||'0').toUpperCase();
    // Axis: 0=XY (swap X<->Y, default), 1=XZ (swap X<->Z), 2=YZ (swap Y<->Z)
    const axis = (axisStr==='XY'||axisStr==='0') ? 0 : (axisStr==='XZ'||axisStr==='1') ? 1 : (axisStr==='YZ'||axisStr==='2') ? 2 : (+axisStr|0);
    // Direction: 0 positive (default), 1 negative (reversed)
    const dir = ((+dirRaw|0)===1) ? 1 : 0;
    console.log('Transpose params:', {axisRaw, dirRaw, axis, dir});

    // The destination matrix has dimensions WxH (transpose)
    for(let r=0;r<W;r++){ // r = destination row index (0 to W-1)
      for(let c=0;c<H;c++){ // c = destination col index (0 to H-1)
        const v=(M[c]&&M[c][r]!==undefined)?M[c][r]:""; // Value from source matrix at (row c, col r)

        let txX=anchor.x, txY=anchor.y, txZ=anchor.z;

        if(axis===0){ // XY: X <- c, Y <- r
          txX = anchor.x + (dir ? -c : c);
          txY = anchor.y + r;
          txZ = anchor.z;
        } else if(axis===1){ // XZ: X <- r, Z from anchor moving opposite when reversed
          txX = anchor.x + r;
          txY = anchor.y;
          txZ = dir ? (anchor.z - r) : (anchor.z + r);
        } else { // YZ: Y <- r, Z from anchor moving opposite when reversed
          txX = anchor.x;
          txY = anchor.y + r;
          txZ = dir ? (anchor.z - r) : (anchor.z + r);
        }
        
        console.log(`Writing cell [${r},${c}]: value="${v}" to (${txX},${txY},${txZ})`);
        // Write cell. Formula is only on the anchor cell itself.
        ensureAndWrite(txX,txY,txZ, v, (r===0&&c===0));
      }
    }
    
    // Record all emissions for cleanup
    if(emitted.size > 0){
      if(!S.emittedByAnchor) S.emittedByAnchor = new Map();
      S.emittedByAnchor.set(ak, emitted);
    }
    
    console.log('TRANSPOSE completed, emitted:', emitted.size, 'cells');
    if(__ownsTx) {
      console.log('Committing transaction');
      Write.commit(tx);
    }
    console.log('=== TRANSPOSE DEBUG END ===');
  }catch(e){ 
    console.error('TRANSPOSE error:', e); 
    console.log('=== TRANSPOSE DEBUG END (ERROR) ===');
    Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); 
  }
});

/* ===========================
   Formula Parser v2.0 - Lexer/Parser/AST System
=========================== */
// Token types for the lexer
const TokenTypes = {
  ILLEGAL: 'ILLEGAL',
  EOF: 'EOF',
  NUMBER: 'NUMBER',
  STRING: 'STRING', 
  IDENTIFIER: 'IDENTIFIER',
  CELL_REF: 'CELL_REF',     // A1α, B2β^1
  RANGE_REF: 'RANGE_REF',   // @[0,0,0,1]
  EQUALS: '=',
  LPAREN: '(',
  RPAREN: ')',
  COMMA: ',',
  COLON: ':'
};
// Lexer: converts formula text into tokens
class FormulaLexer {
  constructor(input) {
    this.input = input;
    this.position = 0;
    this.readPosition = 0;
    this.ch = '';
    this.readChar();
  }

  readChar() {
    if (this.readPosition >= this.input.length) {
      this.ch = null;
    } else {
      this.ch = this.input[this.readPosition];
    }
    this.position = this.readPosition;
    this.readPosition += 1;
  }

  peekChar() {
    if (this.readPosition >= this.input.length) {
      return null;
    }
    return this.input[this.readPosition];
  }

  nextToken() {
    this.skipWhitespace();
    let tok;

    switch (this.ch) {
      case '=': tok = { type: TokenTypes.EQUALS, value: this.ch }; break;
      case '(': tok = { type: TokenTypes.LPAREN, value: this.ch }; break;
      case ')': tok = { type: TokenTypes.RPAREN, value: this.ch }; break;
      case ',': tok = { type: TokenTypes.COMMA, value: this.ch }; break;
      case ':': tok = { type: TokenTypes.COLON, value: this.ch }; break;
      case '"':
        tok = { type: TokenTypes.STRING, value: this.readString() };
        break;
      case '@':
        tok = { type: TokenTypes.RANGE_REF, value: this.readRangeRef() };
        break;
      case null:
        tok = { type: TokenTypes.EOF, value: "" };
        break;
      default:
        if (this.isLetter(this.ch)) {
          const literal = this.readIdentifier();
          // After reading letters, current char holds the next symbol
          if (this.isDigit(this.ch)) {
            const number = this.readNumber();
            const greek = 'αβγδεζηθικλμνξοπρστυφχψω';
            let greekChar = '';
            let arrayId = '';
            // Greek Z-suffix at current char
            if (this.ch && greek.includes(this.ch)) {
              const g = this.ch; this.readChar(); greekChar = g;
            }
            // Array id suffix ^n at current char
            if (this.ch === '^') {
              this.readChar();
              arrayId = '^' + this.readNumber();
            }
            tok = { type: TokenTypes.CELL_REF, value: literal + number + greekChar + arrayId };
          } else {
            tok = { type: TokenTypes.IDENTIFIER, value: literal };
          }
          return tok;
        } else if (this.isDigit(this.ch)) {
          // Support identifiers that start with a digit when followed by letters/underscore (e.g., 3D_TRANSLATE)
          const start = this.position;
          let i = this.position; let hasAlpha=false; let ch=this.input[i];
          while (ch && ((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||(ch>='0'&&ch<='9')||ch==='_' )){ if((ch>='a'&&ch<='z')||(ch>='A'&&ch<='Z')||ch==='_') hasAlpha=true; i++; ch=this.input[i]; }
          if(hasAlpha){
            // consume to i
            while(this.position < i) this.readChar();
            tok = { type: TokenTypes.IDENTIFIER, value: this.input.substring(start, i) };
          } else {
            tok = { type: TokenTypes.NUMBER, value: this.readNumber() };
          }
          return tok;
        } else {
          tok = { type: TokenTypes.ILLEGAL, value: this.ch };
        }
    }

    this.readChar();
    return tok;
  }

  readString() {
    // Consume characters until the matching quote, honoring backslash escapes
    let out = '';
    // Start after opening quote
    while (true) {
      this.readChar();
      if (this.ch === null) {
        break;
      }
      if (this.ch === '"') {
        // End of string token
        break;
      }
      if (this.ch === '\\') {
        const next = this.peekChar();
        if (next === null) { out += '\\'; continue; }
        this.readChar();
        switch (this.ch) {
          case 'n': out += '\n'; break;
          case 'r': out += '\r'; break;
          case 't': out += '\t'; break;
          case '"': out += '"'; break;
          case '\\': out += '\\'; break;
          default: out += this.ch; break;
        }
        continue;
      }
      out += this.ch;
    }
    return out;
  }

  readIdentifier() {
    const position = this.position;
    while (this.isLetter(this.ch) || this.ch === '_') {
      this.readChar();
    }
    return this.input.substring(position, this.position);
  }
  
  readNumber() {
    const position = this.position;
    while (this.isDigit(this.ch) || this.ch === '.') {
      this.readChar();
    }
    return this.input.substring(position, this.position);
  }

  readRangeRef() {
    const position = this.position;
    while (this.ch !== null && this.ch !== ']') {
      this.readChar();
    }
    if (this.ch === ']') this.readChar(); // consume ']'
    return this.input.substring(position, this.position);
  }

  isLetter(ch) {
    return ch && (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));
  }

  isDigit(ch) {
    return ch && ('0' <= ch && ch <= '9');
  }
  skipWhitespace() {
    while (this.ch === ' ' || this.ch === '\t' || this.ch === '\n' || this.ch === '\r') {
      this.readChar();
    }
  }
}
// Parser: converts tokens into Abstract Syntax Tree
class FormulaParser {
  constructor(lexer, anchor) {
    this.lexer = lexer;
    this.anchor = anchor;
    this.errors = [];
    this.currentToken = null;
    this.peekToken = null;
    this.nextToken();
    this.nextToken();
  }

  nextToken() {
    this.currentToken = this.peekToken;
    this.peekToken = this.lexer.nextToken();
  }

  parseFormula() {
    if (this.currentToken.type !== TokenTypes.EQUALS) {
      return {
        type: 'Literal',
        value: this.lexer.input
      };
    }
    this.nextToken(); // consume '='
    return this.parseExpression();
  }

  parseExpression() {
    // Function call when IDENTIFIER followed by '('
    if (this.currentToken.type === TokenTypes.IDENTIFIER && this.peekToken.type === TokenTypes.LPAREN) {
      return this.parseFunctionCall();
    }
    // Otherwise parse primary (numbers, strings, refs, identifiers)
    return this.parsePrimary();
  }

  parseFunctionCall() {
    const node = {
      type: 'FunctionCall',
      name: this.currentToken.value.toUpperCase(),
      arguments: [],
      raw: this.lexer.input
    };
    this.nextToken(); // consume IDENTIFIER
    this.nextToken(); // consume '('
    // currentToken now points at first arg token or ')'
    node.arguments = this.parseArgumentList();
    // Recovery: advance until ')' if not currently on ')'
    if (this.currentToken.type !== TokenTypes.RPAREN) {
      while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
        this.nextToken();
      }
      if (this.currentToken.type !== TokenTypes.RPAREN) {
        this.errors.push(`Expected ')', got ${this.currentToken ? this.currentToken.type : 'EOF'}`);
        return null;
      }
    }
    this.nextToken(); // consume ')'
    return node;
  }
  parseArgumentList() {
    const args = [];
    // Handle empty argument list
    if (this.currentToken.type === TokenTypes.RPAREN) {
      return args;
    }

    while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
      const expr = this.parseExpression();
      if (expr !== undefined && expr !== null) args.push(expr);
      if (this.currentToken && this.currentToken.type === TokenTypes.COMMA) {
        this.nextToken();
        continue;
      }
      if (this.currentToken && this.currentToken.type === TokenTypes.RPAREN) break;
      // If the current token is neither comma nor RPAREN, parser will let parseExpression advance or we break for recovery
      if (this.currentToken && this.currentToken.type !== TokenTypes.COMMA) {
        break;
      }
    }
    return args;
  }

  parsePrimary() {
    switch (this.currentToken.type) {
      case TokenTypes.LPAREN:
        // Grouping: ( expr )
        this.nextToken();
        const inner = this.parseExpression();
        if (this.currentToken.type !== TokenTypes.RPAREN) {
          // Recover by advancing until ')'
          while (this.currentToken && this.currentToken.type !== TokenTypes.RPAREN && this.currentToken.type !== TokenTypes.EOF) {
            this.nextToken();
          }
        }
        if (this.currentToken.type === TokenTypes.RPAREN) this.nextToken();
        return inner;
      case TokenTypes.NUMBER:
        const num = parseFloat(this.currentToken.value);
        this.nextToken();
        return { type: 'Number', value: num };
      case TokenTypes.STRING:
        // String literals may contain embedded quotes and parentheses intended for downstream eval
        // Allow nested function-like strings e.g., "=EXEC_AT(..., \"=ssr()\")"
        const str = this.currentToken.value;
        this.nextToken();
        return { type: 'String', value: str };
      case TokenTypes.CELL_REF:
        const cellRef = this.parseCellRef(this.currentToken.value);
        this.nextToken();
        // Check for range syntax (A1:B2)
        if (this.currentToken && this.currentToken.type === TokenTypes.COLON) {
          this.nextToken(); // consume ':'
          if (this.currentToken.type === TokenTypes.CELL_REF) {
            const endRef = this.parseCellRef(this.currentToken.value);
            this.nextToken();
            return { type: 'Range', start: cellRef, end: endRef, kind: 'range' };
          }
        }
        return { type: 'CellRef', ...cellRef, kind: 'ref' };
      case TokenTypes.RANGE_REF:
        const rangeRef = this.parseRangeRef(this.currentToken.value);
        this.nextToken();
        return { type: 'RangeRef', ...rangeRef, kind: 'ref' };
      case TokenTypes.IDENTIFIER:
        // Handle nested function calls
        if (this.peekToken && this.peekToken.type === TokenTypes.LPAREN) {
          return this.parseFunctionCall();
        }
        // Check for named macros
        const name = this.currentToken.value.toUpperCase();
        const macro = Store.getState().namedMacros.get(name);
        this.nextToken();
        if (macro) {
          return { type: 'Macro', value: macro };
        }
        return { type: 'Identifier', value: name };
      default:
        this.errors.push(`Unexpected token: ${this.currentToken.type}`);
        const val = this.currentToken.value;
        this.nextToken();
        return { type: 'Literal', value: val };
    }
  }

  parseCellRef(s) {
    const t = String(s||'').trim();
    const m = /^([A-Za-z]+)(\d+)([\u03b1-\u03c9])?(?:\^(-?\d+))?$/.exec(t);
    if (!m) return null;
    let x = 0;
    const letters = m[1].toUpperCase();
    for (let i = 0; i < letters.length; i++) x = x * 26 + (letters.charCodeAt(i) - 64);
    x--;
    const y = +m[2] - 1;
    const G = 'αβγδεζηθικλμνξοπρστυφχψω';
    const z = m[3] ? G.indexOf(m[3]) : this.anchor.z;
    const arrId = m[4] !== undefined ? (+m[4]) : this.anchor.arrId;
    return { x, y, z, arrId };
  }

  parseRangeRef(s) {
    const cur = this.anchor || {x:0,y:0,z:0,arrId:0};
    const m = /^@\[(\-?\d+)?,(\-?\d+)?,(\-?\d+)?,(-?\d+)\]$/.exec(String(s).trim());
    if (!m) return null;
    const raw = [m[1], m[2], m[3]].map(v=> (v===undefined || v===null) ? '' : String(v));
    const toOneBased = (val, curComp)=>{
      if(val==='') return 1;
      const n=+val; if(n===0) return (curComp|0)+1; return n;
    };
    const xb = toOneBased(raw[0], cur.x);
    const yb = toOneBased(raw[1], cur.y);
    const zb = toOneBased(raw[2], cur.z);
    return { x: xb-1, y: yb-1, z: zb-1, arrId: +m[4] };
  }
}
// Evaluator: walks AST and computes values
class FormulaEvaluator {
  constructor(formulaAPI) {
    this.formulaAPI = formulaAPI;
  }

  evaluate(node) {
    if (!node) return null;

    switch (node.type) {
      case 'Literal':
        return node.value;
      case 'Number':
        return node.value;
      case 'String':
        return node.value;
      case 'Identifier':
        return node.value;
      case 'Macro':
        // Simple macro expansion - could be enhanced
        return node.value;
      case 'CellRef':
        return this.formulaAPI.getCellValue(node);
      case 'RangeRef':
        return this.formulaAPI.getCellValue(node);
      case 'Range':
        // Expand range into cells array
        const cells = [];
        const start = node.start, end = node.end;
        const xs = [start.x, end.x].sort((a,b) => a-b);
        const ys = [start.y, end.y].sort((a,b) => a-b);
        const zs = [start.z, end.z].sort((a,b) => a-b);
        for(let z = zs[0]; z <= zs[1]; z++) {
          for(let y = ys[0]; y <= ys[1]; y++) {
            for(let x = xs[0]; x <= xs[1]; x++) {
              cells.push({x, y, z, arrId: start.arrId, kind: 'ref'});
            }
          }
        }
        return { kind: 'range', cells };
      case 'FunctionCall':
        const fn = this.formulaAPI.Fn[node.name];
        if (!fn) {
          throw new Error(`Unknown function ${node.name}`);
        }
        
        // Convert args without auto-injecting modes; functions decide internally
        let convertedArgs = node.arguments.map(arg => this.convertAstToLegacy(arg));
        const lname = String(node.name||'').toUpperCase();

        // Create compatibility bridge with old function system
        const mockAst = {
          fn: node.name,
          args: convertedArgs,
          raw: node.raw || this.formulaAPI.rawFormula
        };
        
        // Call original function implementation
        const anchor = this.formulaAPI.currentAnchor;
        const arr = this.formulaAPI.currentArray;
        const tx = this.formulaAPI.currentTx;
        
        return fn.impl(anchor, arr, mockAst, tx);
    }
    return null;
  }

  // Convert new AST nodes to legacy format for backward compatibility
  convertAstToLegacy(node) {
    switch (node.type) {
      case 'Number':
        return node.value;
      case 'String':
        return node.value;
      case 'Literal':
        return node.value;
      case 'CellRef':
      case 'RangeRef':
        return { ...node, kind: 'ref' };
      case 'Range':
        return this.evaluate(node); // Returns {kind:'range', cells:[...]}
      case 'FunctionCall':
        // For nested function calls, evaluate them
        return this.evaluate(node);
      default:
        return node.value || '';
    }
  }

  // Extract dependencies from AST
  findDependencies(node) {
    const deps = new Set();
    const aKey = ({arrId, x, y, z}) => `${arrId}:${x},${y},${z}`;

    const walk = (n) => {
      if (!n) return;

      switch (n.type) {
        case 'CellRef':
        case 'RangeRef':
          deps.add(aKey(n));
          break;
        case 'Range':
          deps.add(aKey(n.start));
          deps.add(aKey(n.end));
          break;
        case 'FunctionCall':
          n.arguments.forEach(walk);
          break;
      }
    };

    walk(node);
    return deps;
  }
}

/* ===========================
   Formula Engine (deep deps)
=========================== */
const Formula = (()=>{
  // Create evaluator instance
  const evaluator = new FormulaEvaluator({
    getCellValue: null, // Will be set below
    Fn: Fn,
    currentAnchor: null,
    currentArray: null, 
    currentTx: null,
    rawFormula: ''
  });

  // New AST-based parse function
  const parse = (text, anchor) => {
    try {
      const lexer = new FormulaLexer(text);
      const parser = new FormulaParser(lexer, anchor);
      const ast = parser.parseFormula();
      
      if (parser.errors.length > 0) {
        console.warn('Parser errors:', parser.errors);
        // Treat as literal to avoid hard failure
        return { fn: null, args: [], raw: text };
      }
      
      // Convert AST to legacy format for compatibility
      if(ast.type === 'Literal') {
        const lit = String(ast.value||'').trim();
        if(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(/.test(lit)){
          // Treat bare function-looking literals as calls by auto-injecting '='
          const retry = '=' + lit;
          const lx = new FormulaLexer(retry);
          const px = new FormulaParser(lx, anchor);
          const node2 = px.parseFormula();
          if(px.errors.length===0 && node2 && node2.type==='FunctionCall'){
            let args = node2.arguments.map(arg => evaluator.convertAstToLegacy(arg));
            return { fn: node2.name, args, raw: retry };
          }
        }
        return { fn: null, args: [], raw: text };
      }
      
      if(ast.type === 'FunctionCall') {
        // Convert AST to legacy-expected args WITHOUT auto-injecting modes
        let args = ast.arguments.map(arg => evaluator.convertAstToLegacy(arg));
        return { fn: ast.name, args, raw: text };
      }
      
      // Fallback for other types
      return { fn: null, args: [], raw: text };
    } catch (e) {
      console.warn('AST parser failed, no legacy fallback:', e);
      return { fn: null, args: [], raw: text };
    }
  };
  // Enhanced dependency recording with AST support
  const recordDeps=(anchor, args, formula, ast=null)=>{
    const S=Store.getState(); const ak=aKey(anchor);
    let deps = new Set();
    
    // Use AST-based dependency extraction if available
    if(ast && evaluator) {
      try {
        deps = evaluator.findDependencies(ast);
      } catch(e) {
        console.warn('AST dependency extraction failed, using legacy:', e);
      }
    }
    
    // Fallback to legacy dependency extraction
    if(deps.size === 0) {
    const visit=a=>{ if(!a) return; if(Array.isArray(a)) return a.forEach(visit); if(a.kind==='ref') deps.add(aKey(a)); if(a.kind==='range') a.cells.forEach(c=>deps.add(aKey(c))); };
    args.forEach(visit);
    }
    
    // Track global state dependencies by parsing formula text for GET_GLOBAL calls
    const globalKeys = new Set();
    if(formula) {
      const globalMatches = formula.match(/GET_GLOBAL\s*\(\s*['"](.*?)['"]/g);
      if(globalMatches) {
        globalMatches.forEach(match => {
          const keyMatch = match.match(/GET_GLOBAL\s*\(\s*['"]([^'"]+)['"]/);
          if(keyMatch) globalKeys.add(keyMatch[1]);
        });
      }
    }
    
    // Clean up old dependencies
    const old=S.depsByAnchor.get(ak)||new Set();
    old.forEach(k=>{const s=S.anchorsByDep.get(k); if(s){s.delete(ak); if(!s.size) S.anchorsByDep.delete(k);}});
    
    // Clean up old global dependencies
    const oldGlobals = S.globalKeysByAnchor.get(ak) || new Set();
    oldGlobals.forEach(key => {
      const anchors = S.anchorsByGlobalKey.get(key);
      if(anchors) {
        anchors.delete(ak);
        if(anchors.size === 0) S.anchorsByGlobalKey.delete(key);
      }
    });
    
    // Set new cell dependencies
    S.depsByAnchor.set(ak,deps);
    deps.forEach(k=>{ if(!S.anchorsByDep.has(k)) S.anchorsByDep.set(k,new Set()); S.anchorsByDep.get(k).add(ak); });
    
    // Set new global dependencies
    S.globalKeysByAnchor.set(ak, globalKeys);
    globalKeys.forEach(key => {
      if(!S.anchorsByGlobalKey.has(key)) S.anchorsByGlobalKey.set(key, new Set());
      S.anchorsByGlobalKey.get(key).add(ak);
    });

    // Mark anchor dirty if its dependency set changed (edge change)
    try{
      const old = old || new Set(); // (defensive; old cleaned above)
      const now = deps;
      let changed = (old.size!==now.size);
      if(!changed){ for(const k of old){ if(!now.has(k)){ changed=true; break; } } }
      if(changed){
        const akStr = ak;
        // eslint-disable-next-line no-undef
        if(typeof markDirty==='function') markDirty(akStr);
      }
    }catch{}
  };

  const getCellValue=({arrId,x,y,z})=>{
    const arr=Store.getState().arrays[arrId]; if(!arr) return '';
    const key=keyChunk(...Object.values(chunkOf(x,y,z)));
    const ch=arr.chunks && arr.chunks[key]; if(!ch) return '';
    const c=ch.cells && ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c? (c.value ?? '') : '';
  };
  const getCell=({arrId,x,y,z})=>{
    const arr=Store.getState().arrays[arrId]; if(!arr) return {value:'',formula:null};
    const key=keyChunk(...Object.values(chunkOf(x,y,z)));
    const ch=arr.chunks && arr.chunks[key]; if(!ch) return {value:'',formula:null};
    const c=ch.cells && ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c||{value:'',formula:null};
  };
  const getCellNote=({arrId,x,y,z})=>{
    const c = getCell({arrId,x,y,z});
    return (c && c.meta && c.meta.noteText) ? c.meta.noteText : '';
  };
  
  // Wire up evaluator with formula API
  evaluator.formulaAPI.getCellValue = getCellValue;
  const valOf=(a)=>{ 
    if(a&&a.kind==='ref') {
      // Check if cell is protected by CANT_TARGET
      const cell = getCell(a);
      if(cell.meta && cell.meta.isTargetable === false) {
        return '!ERR:TARGET_PROTECTED';
      }
      return getCellValue(a); 
    } 
    if(a&&a.kind==='range') return a.cells.map(c=>getCellValue(c)); 
    return a; 
  };
  function setFormula(anchor,text){
    const arr=Store.getState().arrays[anchor.arrId]; if(!arr) return;
    // Normalize: auto-close missing ')' and allow bare =FN to map to =FN()
    if(text && text[0]==='='){
      const body = text.slice(1).trim();
      const m = body.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(?\s*\)?$/);
      if(m){ text = `=${m[1]}()`; }
      else {
        // naive paren balance: if more '(' than ')', pad closers at end
        const open=(text.match(/\(/g)||[]).length, close=(text.match(/\)/g)||[]).length;
        if(open>close) text += ')'.repeat(open-close);
      }
    } else if(text && /^[A-Za-z_][A-Za-z0-9_]*\s*\(/.test(text.trim())){
      // Auto-inject '=' for function-like inputs without leading '=' (e.g., create(1,1,1))
      text = '=' + text.trim();
    }
    const ch=arr.chunks[keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)))];
    const cell=ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
    if(cell) {
      // Revert previously applied 3D_ROTATE if this anchor was controlling one and not suppressed
      try{
        const ak=aKey(anchor);
        const S=Store.getState();
        let rec = (S.activeRotations||new Map()).get(ak);
        // Fallback to meta if after refresh
        if(!rec){
          const cell = Formula.getCell(anchor);
          if(cell && cell.meta && cell.meta.appliedRotate){ rec = cell.meta.appliedRotate; }
        }
        const suppressed = (S.suppress3DRotateRevert||new Set()).has(ak);
        if(rec && (!text || text==='') && !suppressed){
          const targ=S.arrays[rec.targetId];
          if(targ){
            const ids = rec.ids||[rec.targetId];
            // Ensure frames exist
            ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(!a._frame) Scene.renderArray(a); });
            // Rotate back by negative steps around the same pivot at current time
            const pivotWorld = Scene.cellWorldPos(targ, rec.pivot.x, rec.pivot.y, rec.pivot.z);
            const sx = -(rec.steps.sx||0), sy=-(rec.steps.sy||0), sz=-(rec.steps.sz||0);
            ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));
            ids.map(id=>S.arrays[id]).filter(Boolean).forEach(a=>{ if(a._frame){ a.offset={ x:Math.round(a._frame.position.x), y:Math.round(a._frame.position.y), z:Math.round(a._frame.position.z) }; }});
          }
          const map=new Map(S.activeRotations); map.delete(ak); Store.setState({activeRotations:map});
        }
        if(suppressed){ const sup=new Set(S.suppress3DRotateRevert); sup.delete(ak); Store.setState({suppress3DRotateRevert:sup}); }
      }catch{}
      // Revert previously applied 3D_TRANSLATE if this anchor controlled one and is now cleared
      try{
        const ak=aKey(anchor);
        const S=Store.getState();
        let recT = (S.activeTranslations||new Map()).get(ak);
        // Fallback to meta on refresh: read persisted appliedTranslate
        if(!recT){
          const cell = Formula.getCell(anchor);
          if(cell && cell.meta && cell.meta.appliedTranslate){ recT = cell.meta.appliedTranslate; }
        }
        const suppressedT = (S.suppress3DTranslateRevert||new Set()).has(ak);
        const clearing = (!text || text==='');
        if(recT && clearing && !suppressedT){
          const targ=S.arrays[recT.targetId];
          if(targ){
            // Differential revert: subtract only this cell's delta to preserve stacking
            const off = targ.offset||{x:0,y:0,z:0};
            const d = recT.delta || {dx:0,dy:0,dz:0};
            const nx = Math.round((off.x||0) - (d.dx||0));
            const ny = Math.round((off.y||0) - (d.dy||0));
            const nz = Math.round((off.z||0) - (d.dz||0));
            setArrayOffset(targ, {x:nx,y:ny,z:nz}, {interactive:true});
          }
          const map=new Map(S.activeTranslations); map.delete(ak); Store.setState({activeTranslations:map});
        }
        if(suppressedT){ const sup=new Set(S.suppress3DTranslateRevert); sup.delete(ak); Store.setState({suppress3DTranslateRevert:sup}); }
      }catch{}
      cell.formula=text;
      // Use new AST-based dependency tracking
      try {
        const lexer = new FormulaLexer(text);
        const parser = new FormulaParser(lexer, anchor);
        const ast = parser.parseFormula();
        recordDeps(anchor, [], text, ast);
      } catch(e) {
        console.warn('AST dependency tracking failed; recording minimal deps');
        recordDeps(anchor, [], text, null);
      }
    }
  }
  function executeAt(anchor,text,tx){
    // Make tx optional - use legacy Actions.setCell if no transaction
    const useLegacy = !tx;
    if(text) setFormula(anchor,text);
    const arr=Store.getState().arrays[anchor.arrId]; if(!arr) return;
    const chKey = keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)));
    let ch=arr.chunks[chKey];
    if(!ch){
      // Ensure the array has this chunk (e.g., expansion or first write)
      Actions.resizeArrayIfNeeded(arr, anchor);
      ch = arr.chunks[chKey];
      if(!ch) return; // still missing, abort gracefully
    }
    const cell=ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z) || {value:'',formula:null};
    const src=(cell?.formula)||text||(cell?.value??'');
    
    // Try new AST parser first, fallback to legacy
    let ast, useAST = false, astRoot = null;
    try {
      const lexer = new FormulaLexer(src);
      const parser = new FormulaParser(lexer, anchor);
      const astNode = parser.parseFormula();
      astRoot = astNode;
      
      if(parser.errors.length === 0 && astNode) {
        // Set up evaluator context
        evaluator.formulaAPI.currentAnchor = anchor;
        evaluator.formulaAPI.currentArray = arr;
        evaluator.formulaAPI.currentTx = tx;
        evaluator.formulaAPI.rawFormula = src;
        
        // Convert to legacy format for function compatibility
        if(astNode.type === 'Literal') {
          // If the literal looks like a function call without '=', auto-inject '=' and reparse
          const lit = String(astNode.value||'').trim();
          if(/^([A-Za-z_][A-Za-z0-9_]*)\s*\(/.test(lit)){
            const retry = '=' + lit;
            const lx = new FormulaLexer(retry);
            const px = new FormulaParser(lx, anchor);
            const node2 = px.parseFormula();
            if(px.errors.length===0 && node2 && node2.type==='FunctionCall'){
              ast = { fn: node2.name, args: node2.arguments.map(arg => evaluator.convertAstToLegacy(arg)), raw: retry };
            } else {
              ast = { fn: null, args: [], raw: src };
            }
          } else {
            ast = { fn: null, args: [], raw: src };
          }
          useAST = true;
        } else if(astNode.type === 'FunctionCall') {
          // Convert AST to legacy-expected args for all functions
          ast = {
            fn: astNode.name,
            args: astNode.arguments.map(arg => evaluator.convertAstToLegacy(arg)),
            raw: src
          };
          // Preserve raw AST args for special-case handling (e.g., ARRAY call with range)
          ast._astArgs = astNode.arguments;
          useAST = true;
        } else {
          ast = { fn: null, args: [], raw: src };
          useAST = true;
        }
      }
    } catch(e) {
      console.warn('AST parsing failed, using legacy:', e);
    }
    
    // Fallback to legacy parser
    if(!useAST) {
      const errorMsg = '!ERR:PARSE';
      if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
      else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||src });
      return;
    }

    if(!ast.fn) { 
      // Evaluate simple expressions like =A2 or =(A2) to their scalar value
      try{
        let result = evaluator.evaluate(astRoot);
        // If a range was produced, reduce to its first cell value
        if(result && typeof result==='object' && result.kind==='range'){
          const first = result.cells && result.cells[0];
          result = first ? Formula.getCellValue(first) : '';
        }
        if(useLegacy) Actions.setCell(arr.id, anchor, result, cell?.formula||src, true);
        else Write.set(tx, arr.id, anchor, { value: result, formula: cell?.formula||src });
      }catch{
        // Fall back to literal behavior
      if(useLegacy) Actions.setCell(arr.id, anchor, src, null, true);
      else Write.set(tx, arr.id, anchor, { value: src, formula: null });
      }
      return; 
    }
    if(!isAllowed(arr, ast.fn)) { 
      const errorMsg = `!ERR:FN_DENIED ${ast.fn}`;
      if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
      else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
      return; 
    }

    try{ 
      if(!Fn[ast.fn]) { 
        // Check for macro expansion
        const macro = Store.getState().namedMacros.get(ast.fn.toUpperCase());
        if(macro) {
          // Simple positional expansion: $1, $2 ... replaced by evaluated args
          const args = ast.args.map(a => {
            const v = valOf(a);
            return (typeof v === 'string') ? `"${v}"` : `${v}`;
          });
          const expanded = macro.replace(/\$(\d+)/g, (_,i)=> args[(+i)-1] ?? '');
          return executeAt(anchor, expanded, tx); // re-enter with expanded text and same tx
        }
        const errorMsg = `!ERR:Unknown ${ast.fn}`;
        if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, ast.raw, true);
        else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
        return; 
      }
      // Determine if function is pure or mutating by tags
      const tags = Fn[ast.fn]?.tags || new Set();
      const isPure = tags.has('PURE');
      if(isPure){
        // Special-case: TRANSPOSE should treat ARRAY(...) with a range child as a range input
        if(ast.fn==='TRANSPOSE' && Array.isArray(ast._astArgs) && ast._astArgs.length>0){
          try{
            const firstArg = ast._astArgs[0];
            // Pattern: ARRAY(call) where child is range or cell-ref range
            const isArrayCall = firstArg && firstArg.type==='FunctionCall' && String(firstArg.name||'').toUpperCase()==='ARRAY';
            const hasRangeChild = isArrayCall && firstArg.arguments && firstArg.arguments.some(a=> a && (a.type==='Range' || a.type==='CellRef' || a.type==='RangeRef'));
            if(hasRangeChild){
              // Rebuild a legacy range arg from the child's first range-like argument
              const child = firstArg.arguments.find(a=> a && (a.type==='Range' || a.type==='CellRef' || a.type==='RangeRef'));
              let legacy;
              if(child.type==='Range'){
                // Expand to cells in legacy format
                const xs=[child.start.x,child.end.x].sort((a,b)=>a-b);
                const ys=[child.start.y,child.end.y].sort((a,b)=>a-b);
                const zs=[child.start.z,child.end.z].sort((a,b)=>a-b);
                const cells=[]; for(let z=zs[0]; z<=zs[1]; z++) for(let y=ys[0]; y<=ys[1]; y++) for(let x=xs[0]; x<=xs[1]; x++) cells.push({x,y,z,arrId:child.start.arrId,kind:'ref'});
                legacy = {kind:'range', cells};
              } else {
                legacy = { arrId: child.arrId, x:child.x, y:child.y, z:child.z, kind:'ref' };
              }
              const ast2 = { ...ast, args:[legacy, ...ast.args.slice(1)] };
              Fn[ast.fn].impl(anchor,arr,ast2,tx);
              return; // already wrote
            }
          }catch{}
        }
        // Evaluate pure function via implementation but capture returned value
        const result = Fn[ast.fn].impl(anchor,arr,ast,tx);
        // Some pure functions already write; only write when result is scalar
        if(result !== undefined){
          let adtx = tx;
          if(!adtx) adtx = Write.start('auto.pure','auto');
          Write.set(adtx, arr.id, anchor, { value: result, formula: cell?.formula||ast.raw });
          if(!tx) Write.commit(adtx);
        }
      } else {
        // Mutating/action functions use their implementation with tx
        if(!tx){ const adtx = Write.start(`auto.${ast.fn.toLowerCase()}`,'Auto-started tx'); Fn[ast.fn].impl(anchor,arr,ast,adtx); Write.commit(adtx); }
        else { Fn[ast.fn].impl(anchor,arr,ast,tx); }
      }
    }
    catch(e){ 
      const errorMsg = `!ERR:${e.message}`;
      if(useLegacy) Actions.setCell(arr.id, anchor, errorMsg, cell?.formula||null, true);
      else Write.set(tx, arr.id, anchor, { value: errorMsg, formula: cell?.formula||ast.raw });
    } finally {
      // Clean up evaluator context
      if(useAST) {
        evaluator.formulaAPI.currentAnchor = null;
        evaluator.formulaAPI.currentArray = null;
        evaluator.formulaAPI.currentTx = null;
        evaluator.formulaAPI.rawFormula = '';
      }
    }
  }

  // --- runOnceAt: execute a formula at an anchor without stamping ---
  function runOnceAt(anchor, text, tx){
    const arr = Store.getState().arrays[anchor.arrId]; if(!arr) return;
    const chKey = keyChunk(...Object.values(chunkOf(anchor.x,anchor.y,anchor.z)));
    let ch = arr.chunks[chKey];
    if(!ch){ Actions.resizeArrayIfNeeded(arr, anchor); ch = arr.chunks[chKey]; if(!ch) return; }
    const idx = ch.cells.findIndex(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
    if(idx<0){ ch.cells.push({x:anchor.x,y:anchor.y,z:anchor.z,value:'',formula:null}); }
    const cell = ch.cells.find(c=>c.x===anchor.x&&c.y===anchor.y&&c.z===anchor.z);
    const prevFormula = cell.formula;
    try{
      cell.formula = text;                 // temporary set
      executeAt(anchor, undefined, tx);    // execute without stamping
    } finally {
      cell.formula = prevFormula;          // restore
    }
  }

  function notifyCellChanged(dep){
    const depK=aKey(dep);
    // Defer to recompute engine with proper batching
    recomputeAnchors([depK]);
  }

  // Incremental SCC-based recompute with fingerprint short-circuit
  let recomputeDepth = 0; let inRecompute = false;
  const NodeMeta = { byKey:new Map(), dirtyQ:new Set() };
  function metaOf(ak){ let m=NodeMeta.byKey.get(ak); if(!m){ m={version:0,inputFP:'',dirty:false}; NodeMeta.byKey.set(ak,m);} return m; }
  function markDirty(ak){ const m=metaOf(ak); m.dirty=true; NodeMeta.dirtyQ.add(ak); }
  function bumpVersion(ak){ const m=metaOf(ak); m.version++; const users=Store.getState().anchorsByDep.get(ak)||new Set(); users.forEach(u=>markDirty(u)); }
  function fingerprintFor(ak){ const deps=Store.getState().depsByAnchor.get(ak)||new Set(); if(deps.size===0) return '0'; let s=''; deps.forEach(d=>{ s+=d+'@'+(metaOf(d).version||0)+';'; }); return s; }

  // Wrap Write.set once to bump versions on actual value change
  if(!Write.__versionWrapped){
    Write.__versionWrapped = true;
    const __set = Write.set.bind(Write);
    Write.set = function(tx, arrId, coord, next){
      const ak = `${arrId}:${coord.x},${coord.y},${coord.z}`;
      const arr = Store.getState().arrays[arrId];
      const ch = arr && arr.chunks && arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
      const prevCell = ch && ch.cells.find(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
      const prevVal = prevCell ? prevCell.value : undefined;
      __set(tx, arrId, coord, next);
      const arr2 = Store.getState().arrays[arrId];
      const ch2 = arr2 && arr2.chunks && arr2.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
      const c2 = ch2 && ch2.cells.find(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
      const newVal = c2 ? c2.value : undefined;
      if(!Object.is(prevVal, newVal)) bumpVersion(ak);
    };
  }

  function recomputeAnchors(startKeys){
    if(recomputeDepth>10){ console.warn('Recompute depth exceeded'); return; }
    recomputeDepth++;
    try{
    inRecompute = true;
      startKeys.forEach(k=> NodeMeta.dirtyQ.add(k));
      const affected = collectAffected(NodeMeta.dirtyQ);
      NodeMeta.dirtyQ.clear(); if(affected.size===0){ return; }
      const { sccs, dagOrder } = buildSCCs(affected);
      const rtx = Write.start('recompute','dependency propagation');
      for(const compId of dagOrder){
        const scc = sccs[compId];
        if(scc.length===1 && !hasSelfLoop(scc[0])){ evalNodeIfNeeded(scc[0], rtx); }
        else{ const MAX=1000; for(let i=0;i<MAX;i++){ let any=false; for(const ak of scc) any = evalNodeIfNeeded(ak, rtx) || any; if(!any) break; } }
      }
      Write.commit(rtx);
    } finally { recomputeDepth--; inRecompute=(recomputeDepth>0); }
  }

  function evalNodeIfNeeded(ak, tx){
    const m=metaOf(ak); if(!m.dirty) return false;
    const fp=fingerprintFor(ak); if(fp===m.inputFP){ m.dirty=false; return false; }
    const [arrId,rest]=ak.split(':'); const [x,y,z]=rest.split(',').map(Number);
    executeAt({arrId:+arrId,x,y,z}, undefined, tx);
    m.inputFP=fp; m.dirty=false; return true;
  }
  function hasSelfLoop(ak){ const deps=Store.getState().depsByAnchor.get(ak)||new Set(); return deps.has(ak); }
  function collectAffected(seed){
    const seen=new Set(seed); const stack=[...seed]; const usersMap=Store.getState().anchorsByDep;
    while(stack.length){ const k=stack.pop(); const users=usersMap.get(k)||new Set(); users.forEach(u=>{ if(!seen.has(u)){ seen.add(u); stack.push(u); } }); }
    return seen;
  }
  function buildSCCs(affected){
    const adj=new Map(); affected.forEach(k=> adj.set(k, []));
    const usersMap=Store.getState().anchorsByDep;
    affected.forEach(k=>{ const outs=adj.get(k); (usersMap.get(k)||new Set()).forEach(u=>{ if(affected.has(u)) outs.push(u); }); });
    const ids=new Map(), low=new Map(), onStack=new Map(), stack=[]; let time=0; const comps=[];
    function dfs(v){ ids.set(v,time); low.set(v,time); time++; stack.push(v); onStack.set(v,true);
      for(const w of adj.get(v)){ if(!ids.has(w)){ dfs(w); low.set(v, Math.min(low.get(v), low.get(w))); } else if(onStack.get(w)){ low.set(v, Math.min(low.get(v), ids.get(w))); } }
      if(low.get(v)===ids.get(v)){ const comp=[]; let w=null; do{ w=stack.pop(); onStack.set(w,false); comp.push(w); }while(w!==v); comps.push(comp); }
    }
    affected.forEach(v=>{ if(!ids.has(v)) dfs(v); });
    const compIndex=new Map(); comps.forEach((c,i)=> c.forEach(v=> compIndex.set(v,i)));
    const dagAdj=new Map(); comps.forEach((_,i)=> dagAdj.set(i,new Set()));
    affected.forEach(v=>{ const i=compIndex.get(v); for(const w of adj.get(v)){ const j=compIndex.get(w); if(i!==j) dagAdj.get(i).add(j); } });
    const indeg=new Map(); comps.forEach((_,i)=> indeg.set(i,0)); dagAdj.forEach((outs,i)=> outs.forEach(j=> indeg.set(j, indeg.get(j)+1)));
    const q=[]; indeg.forEach((d,i)=>{ if(d===0) q.push(i); }); const order=[]; while(q.length){ const i=q.shift(); order.push(i); dagAdj.get(i).forEach(j=>{ indeg.set(j, indeg.get(j)-1); if(indeg.get(j)===0) q.push(j); }); }
    return { sccs: comps, dagOrder: order };
  }
  return {parse,setFormula,executeAt,notifyCellChanged,recomputeAnchors,valOf,getCellValue,getCell,getCellNote, isRecomputing:()=>inRecompute, runOnceAt};
})();
/* ===========================
   Docking Utility
=========================== */
function dockOffsetFor(host, port='east', pad=1.0){
  const {x:W,y:H,z:D} = host.size, o = host.offset || {x:0,y:0,z:0};
  const P = String(port||'east').toLowerCase();
  const offs = (P==='north')  ? {x:0,       y:0,        z: ( D/2 + pad)} :
               (P==='south')  ? {x:0,       y:0,        z:-( D/2 + pad)} :
               (P==='east')   ? {x:( W/2 + pad), y:0,   z:0} :
               (P==='west')   ? {x:-(W/2 + pad), y:0,   z:0} :
               (P==='top')    ? {x:0,       y:( H/2 + pad), z:0} :
                               {x:0,       y:-(H/2 + pad), z:0}; // bottom
  return {x:o.x+offs.x, y:o.y+offs.y, z:o.z+offs.z};
}

/* ===========================
   Function Implementations
=========================== */
// Provide a shared alias for Formula.valOf so all function impls can access it
const valOf = Formula.valOf;
// PURE BLOCK
tag('ARRAY',["ACTION","BLOCK"], (anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('ARRAY requires active transaction');
  const S = Store.getState();
  const ak = aKey(anchor);

  const prevEmitted = S.emittedByAnchor.get(ak);
  if(prevEmitted) {
    prevEmitted.forEach(ck => {
      const [arrId, coords] = ck.split(':');
      const [x, y, z] = coords.split(',').map(Number);
      Write.set(tx, +arrId, {x, y, z}, { value: '', formula: null, meta: {} });
      S.sourceByCell.delete(ck);
    });
    S.emittedByAnchor.delete(ak);
  }

  const args = ast.args;
  // Accept ranges: if first arg is a range or ref, treat as list data
  if(args.length>0 && (args[0]?.kind==='range' || args[0]?.kind==='ref')){
    const src = args[0];
    // Clear previous emissions
    const prevEmitted2 = S.emittedByAnchor.get(ak);
    if(prevEmitted2){
      prevEmitted2.forEach(ck => { try{ const [arrId, coords]=ck.split(':'); const [x,y,z]=coords.split(',').map(Number); Write.set(tx, +arrId, {x,y,z}, { value:'', formula:null, meta:{} }); S.sourceByCell.delete(ck); }catch{} });
      S.emittedByAnchor.delete(ak);
    }
    const cells = src.kind==='range' ? src.cells : [src];
    // Determine bounds to emit compactly preserving relative order (row-major by y then x within each z)
    const xs=[...new Set(cells.map(c=>c.x))].sort((a,b)=>a-b);
    const ys=[...new Set(cells.map(c=>c.y))].sort((a,b)=>a-b);
    const zs=[...new Set(cells.map(c=>c.z))].sort((a,b)=>a-b);
    let wrote=false;
    for(let zi=0; zi<zs.length; zi++){
      for(let yi=0; yi<ys.length; yi++){
        for(let xi=0; xi<xs.length; xi++){
          const x=xs[xi], y=ys[yi], z=zs[zi];
          const v = Formula.getCellValue({arrId:cells[0].arrId,x,y,z});
          const dx = xi, dy = yi, dz = zi;
          const isAnchor=(dx===0&&dy===0&&dz===0);
          Write.set(tx, arr.id, {x:anchor.x+dx, y:anchor.y+dy, z:anchor.z+dz}, { value:v, formula:isAnchor?ast.raw:null, meta:{generated:true, emitter:ak} });
          wrote=true;
        }
      }
    }
    return;
  }
  const firstVal = args.length>0 ? valOf(args[0]) : undefined;
  const isModeString = typeof firstVal === 'string';
  let mode = isModeString ? String(firstVal).trim().toLowerCase() : 'list';
  let dataArgs = isModeString ? args.slice(1) : args;

  const knownModes = ['fill','set','csv','list'];
  if(isModeString && !knownModes.includes(mode) && !S.namedBlocks.has(mode.toUpperCase())){
    mode = 'list';
    dataArgs = args;
  }

  switch(mode){
    case 'fill':{
      const w=+valOf(dataArgs[0])||1, h=+valOf(dataArgs[1])||1, d=+valOf(dataArgs[2]||1)||1;
      const fillValue = (dataArgs[3]!==undefined)? valOf(dataArgs[3]) : 1;
      for(let z=0;z<d;z++) for(let y=0;y<h;y++) for(let x=0;x<w;x++){
        const coord={x:anchor.x+x, y:anchor.y+y, z:anchor.z+z};
        const isAnchor=(x===0&&y===0&&z===0);
        Write.set(tx, arr.id, coord, { value: fillValue, formula:isAnchor?ast.raw:null, meta:{generated:true, emitter:ak} });
      }
      break;
    }
    case 'csv':{
      const raw=String(valOf(dataArgs[0]||''));
      const rows=raw.split(/\r?\n/); let wroteAnchor=false, ry=0;
      for(const line of rows){
        const cols=line.split(',');
        for(let i=0;i<cols.length;i++){
          const isFirst=!wroteAnchor;
          Write.set(tx, arr.id, {x:anchor.x+i, y:anchor.y+ry, z:anchor.z}, { value: cols[i], formula:isFirst?ast.raw:null, meta:{generated:true, emitter:ak} });
          wroteAnchor=true;
        }
        ry++;
      }
      break;
    }
    case 'set':
    case 'list':
    default:{
      const named=S.namedBlocks.get(String(mode).toUpperCase());
      if(named){
        const values=named.data[0].flat();
        for(let i=0;i<values.length;i++){
          Write.set(tx, arr.id, {x:anchor.x,y:anchor.y+i,z:anchor.z}, { value:values[i], formula:i===0?ast.raw:null, meta:{generated:true, emitter:ak} });
        }
      } else {
        const values = dataArgs.map(valOf);
        for(let i=0;i<values.length;i++){
          const coord={x:anchor.x, y:anchor.y+i, z:anchor.z};
          Write.set(tx, arr.id, coord, { value: values[i], formula: i===0?ast.raw:null, meta:{generated:true, emitter:ak} });
        }
      }
    }
  }
});
tag('STORE_ARRAY',['PURE'],(anchor,arr,ast)=>{
  // Collect values then produce nested formula: =STORE_ARRAY(ARRAY("list", ...))[,"name"]
  let name='Block', data=[], size={x:1,y:1,z:1}, flat=[];
  const esc=(s)=> String(s).replace(/\\/g,'\\\\').replace(/"/g,'\\\"');
  const pushFlat=(v)=>{ flat.push((typeof v==='string')?`"${esc(v)}"`:`${v}`); };
  const arg0=ast.args[0];
  if(typeof arg0==='number'){
    const w=+valOf(ast.args[0])||1, h=+valOf(ast.args[1])||1, d=+valOf(ast.args[2])||1;
    name=ast.args[3]?String(valOf(ast.args[3])):'Block';
    size={x:w,y:h,z:d};
    for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
      const cell=Formula.getCell({arrId:arr.id,x:anchor.x+xx,y:anchor.y-yy,z:anchor.z+zz});
      pushFlat(cell.value||'');
    }
  } else if(arg0&&arg0.kind==='range'){
    const src=arg0; name=ast.args[1]?String(valOf(ast.args[1])):'Block';
    const xs=src.cells.map(c=>c.x), ys=src.cells.map(c=>c.y), zs=src.cells.map(c=>c.z);
    const minX=Math.min(...xs), minY=Math.min(...ys), minZ=Math.min(...zs), maxX=Math.max(...xs), maxY=Math.max(...ys), maxZ=Math.max(...zs);
    size={x:maxX-minX+1,y:maxY-minY+1,z:maxZ-minZ+1};
    for(let z=minZ; z<=maxZ; z++) for(let y=minY; y<=maxY; y++) for(let x=minX; x<=maxX; x++){
      const cell=Formula.getCell({arrId:src.cells[0].arrId,x,y,z}); pushFlat(cell.value||'');
    }
  } else {
    // Inline values: =STORE_ARRAY(v1,v2,...[,"name"]) -> flatten inputs
    const raw=ast.args.slice();
    if(typeof raw[raw.length-1]==='string' || (typeof raw[raw.length-1]==='object' && raw[raw.length-1]?.kind!==undefined)){
      const last = raw[raw.length-1];
      const nm = String(valOf(last));
      if(nm) { name = nm; raw.pop(); }
    }
    const values=raw.map(valOf);
    size={x:1,y:values.length,z:1};
    values.forEach(pushFlat);
  }
  // Save to library as before
  const lib=new Map(Store.getState().namedBlocks); 
  // Rebuild data cube from flat for persistence (row-major per layer)
  data=[]; { let i=0; for(let z=0; z<size.z; z++){ const layer=[]; for(let y=0; y<size.y; y++){ const row=[]; for(let x=0; x<size.x; x++){ row.push((flat[i++]||'').toString().replace(/^"|"$/g,'')); } layer.push(row); } data.push(layer);} }
  lib.set(name.toUpperCase(),{size,data}); 
  Store.setState({namedBlocks:lib});
  // Emit nested formula string into anchor
  const nested = `=STORE_ARRAY(ARRAY(\"list\", ${flat.join(', ')}), \"${esc(name)}\")`;
  Actions.setCell(arr.id, anchor, nested, ast.raw, true);
});
// DOCK(modeOrList, list...)
// Usage:
// =DOCK("Parent", @[x,y,z,id], id2, ...)
// =DOCK(@[x,y,z,id], id2, ...)  // default mode "Children" (parent mode)
// Mode "Parent": treat first as parent; moves/rotations of a parent apply to later members; a child does not affect parents.
// Mode "All": any member's transform applies to all members.
tag('DOCK',["SCENE","ACTION"], (anchor,arr,ast,tx)=>{
  const S=Store.getState();
  let mode='parent';
  let args = ast.args.slice();
  const first = Formula.valOf(args[0]);
  if(typeof first==='string'){
    const m = String(first||'').toLowerCase();
    mode = (m==='all')?'all':'parent';
    args = args.slice(1);
  }
  const toArrId = (a)=>{
    if(a && a.kind==='ref') return a.arrId;
    const v = Formula.valOf(a);
    if(typeof v==='string'){
      const p = v.match(/@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/);
      if(p) return +p[4];
      const n = +v; if(!isNaN(n)) return n;
    }
    const n = +v; if(!isNaN(n)) return n;
    return null;
  };
  const members = args.map(toArrId).filter(id=> id!=null);
  if(members.length===0){ Actions.setCell(arr.id,anchor,'!ERR:DOCK:EMPTY',ast.raw,true); return; }
  const groupId = `g:${Date.now()}:${Math.random().toString(36).slice(2)}`;
  const group = {mode, members:[...new Set(members)], parentId: members[0]};
  const newGroups = new Map(S.dockGroups||new Map());
  newGroups.forEach((g,k)=>{ if(g.members.some(id=>group.members.includes(id))) newGroups.delete(k); });
  newGroups.set(groupId, group);
  const ak = aKey(anchor);
  const newByAnchor = new Map(S.dockGroupsByAnchor||new Map());
  newByAnchor.set(ak, groupId);
  Store.setState({dockGroups:newGroups, dockGroupsByAnchor:newByAnchor});
  Actions.setCell(arr.id, anchor, `Dock:${mode} ${group.members.join(',')}`, ast.raw, true);
});
// Removed TRANSPONSe alias to avoid confusion
tag('SHIFT',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('SHIFT requires an active transaction');
  const input=ast.args[0]; const dx=+Formula.valOf(ast.args[1])|0, dy=ast.args[2]!==undefined?(+Formula.valOf(ast.args[2])|0):0, dz=ast.args[3]!==undefined?(+Formula.valOf(ast.args[3])|0):0;
  const values=(input&&input.kind==='range')?input.cells.map(c=>Formula.valOf(c)):[Formula.valOf(input)];
  values.forEach((v,i)=> {
    Write.set(tx, arr.id, {x:anchor.x+dx,y:anchor.y+dy+i,z:anchor.z+dz}, { value: v, formula: null, meta:{generated:true, emitter:aKey(anchor)} });
  });
  Write.set(tx, arr.id, anchor, { value: 'SHIFT:OK', formula: ast.raw });
});

// ROTATE(rangeOrArray, axis)
// axis: 0=XY, 1=YZ, 2=XZ. Rotates 90° around anchor on that plane.
console.log('Registering ROTATE function...');
tag('ROTATE',['PURE','BLOCK'], (anchor,arr,ast,tx)=>{
  const __ownsTx = !tx; if(__ownsTx) tx = Write.start('rotate.auto','ROTATE');
  console.log('=== ROTATE DEBUG START ===');
  console.log('ROTATE called with:', {
    anchor: `${anchor.x},${anchor.y},${anchor.z}`,
    arrayId: arr.id,
    astRaw: ast.raw,
    astFn: ast.fn,
    astArgs: ast.args,
    argCount: ast.args?.length,
    hasTx: !!tx,
    ownsTx: __ownsTx
  });
  if(ast._astArgs) console.log('Raw AST args:', ast._astArgs);
  
  // Handle AST parsing issues like TRANSPOSE
  let srcArg = ast.args[0];
  console.log('srcArg from ast.args[0]:', srcArg);
  
  // If ast.args[0] is undefined but we have _astArgs, use that instead
  if(!srcArg && ast._astArgs && ast._astArgs.length > 0) {
    srcArg = ast._astArgs[0];
    console.log('Using _astArgs[0] instead:', srcArg);
  }
  
  // Handle axis parameter from both sources
  let axisRaw = 0;
  if(ast.args && ast.args[1] !== undefined) {
    axisRaw = Formula.valOf(ast.args[1]);
  } else if(ast._astArgs && ast._astArgs[1]) {
    axisRaw = Formula.valOf(ast._astArgs[1]);
  }
  
  const axisStr = String(axisRaw||'0').toUpperCase();
  const axis = (axisStr==='XY'||axisStr==='0') ? 0 : (axisStr==='YZ'||axisStr==='1') ? 1 : (axisStr==='XZ'||axisStr==='2') ? 2 : (+axisStr|0);
  console.log('ROTATE params:', {axisRaw, axis});
  const S=Store.getState(); const ak=aKey(anchor);
  // Clear previously emitted from this anchor
  try{ const prev=S.emittedByAnchor?.get?.(ak); if(prev){ prev.forEach(ck=>{ try{ const [aid,rest]=ck.split(':'); const [cx,cy,cz]=rest.split(',').map(Number); Write.set(tx,+aid,{x:cx,y:cy,z:cz},{value:'',formula:null,meta:{}}); S.sourceByCell?.delete?.(ck);}catch{} }); S.emittedByAnchor?.delete?.(ak);} }catch{}

  // Track new emissions similar to TRANSPOSE
  const emittedKeys = new Set();
  const recordEmission = (x,y,z)=>{ const ck=`${arr.id}:${x},${y},${z}`; try{ if(!S.sourceByCell || !S.sourceByCell.set){ S.sourceByCell = new Map(S.sourceByCell||[]); } S.sourceByCell.set(ck, ak); emittedKeys.add(ck); }catch{} };
  const finalizeEmissions = ()=>{ try{ if(emittedKeys.size){ if(!S.emittedByAnchor || !S.emittedByAnchor.set){ S.emittedByAnchor = new Map(S.emittedByAnchor||[]); } S.emittedByAnchor.set(ak, emittedKeys); } }catch{} };

  const writeAt=(x,y,z,v,isAnchorWrite)=>{ 
    // If writing in front of alpha (z<0), request a front expansion by shifting all layers forward
    if(z<0){ try{ Actions.expandZFront?.(arr, -z); }catch{} }
    try{ Actions.resizeArrayIfNeeded(arr, {x,y,z}); }catch{}
    const isAnchor=(x===anchor.x&&y===anchor.y&&z===anchor.z); 
    if(!isAnchor||isAnchorWrite){ 
      Write.set(tx, arr.id, {x,y,z}, { value:v, formula:(isAnchor?ast.raw:null), meta:{generated:true, emitter:ak} }); 
      recordEmission(x,y,z);
    } 
  };
  if(srcArg && srcArg.kind==='range'){
    const cells=srcArg.cells; const xs=cells.map(c=>c.x), ys=cells.map(c=>c.y), zs=cells.map(c=>c.z);
    const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys), minZ=Math.min(...zs), maxZ=Math.max(...zs);
    let first=null;
    for(let z=minZ; z<=maxZ; z++){
      for(let y=minY; y<=maxY; y++){
        for(let x=minX; x<=maxX; x++){
          const v=Formula.getCellValue({arrId:cells[0].arrId,x,y,z}); if(first===null) first=v;
          let nx=anchor.x, ny=anchor.y, nz=anchor.z;
          if(axis===0){ // XY plane: (x,y)->(y', -x') relative swap around anchor
            const dx=x-minX, dy=y-minY;
            nx = anchor.x + dy;
            ny = anchor.y + (maxX-minX - dx);
            nz = anchor.z + (z-minZ);
          } else if(axis===1){ // YZ plane: (y,z)->(z', -y')
            const dy=y-minY, dz=z-minZ;
            nx = anchor.x + (x-minX);
            ny = anchor.y + dz;
            nz = anchor.z + (maxY-minY - dy);
          } else { // XZ plane: (x,z)->(z', -x')
            const dx=x-minX, dz=z-minZ;
            nx = anchor.x + dz;
            ny = anchor.y + (y-minY);
            nz = anchor.z + (maxX-minX - dx);
          }
          writeAt(nx,ny,nz,v,false);
        }
      }
    }
    writeAt(anchor.x,anchor.y,anchor.z,(first??''),true);
    finalizeEmissions();
    if(__ownsTx) Write.commit(tx);
    return;
  }
  // Handle ARRAY() calls manually (like TRANSPOSE)
  let values = [];
  if(srcArg && (srcArg.type === 'FunctionCall' || srcArg.fn) && String(srcArg.name || srcArg.fn || '').toUpperCase()==='ARRAY'){
    try{
      console.log('Handling ARRAY() call in ROTATE, srcArg:', srcArg);
      // Handle both AST-style (srcArg.arguments) and legacy-style (srcArg.args)
      const argList = srcArg.arguments || srcArg.args || [];
      console.log('ROTATE ARRAY argList:', argList);
      values = argList.map(a=> {
        // Handle different argument formats
        if(a && typeof a === 'object' && 'value' in a) return a.value;
        if(a && typeof a === 'object' && a.type === 'Literal') return a.value;
        return Formula.valOf(a);
      });
      console.log('ROTATE ARRAY values:', values);
    }catch(e){ console.log('ROTATE ARRAY parsing failed:', e); }
  } else {
    // Fallback: rotate a 1D list along axis
    const raw=Formula.valOf(srcArg); 
    values = Array.isArray(raw)?raw.flat():[raw];
    console.log('ROTATE fallback values:', values);
  }
  
  for(let i=0;i<values.length;i++){
    let nx=anchor.x, ny=anchor.y, nz=anchor.z;
    if(axis===0){ ny = anchor.y + i; }
    else if(axis===1){ nz = anchor.z + i; }
    else { nx = anchor.x + i; }
    console.log(`ROTATE writing cell [${i}]: value="${values[i]}" to (${nx},${ny},${nz})`);
    writeAt(nx,ny,nz,values[i], i===0);
  }
  
  finalizeEmissions();
  console.log('ROTATE completed, values written:', values.length);
  if(__ownsTx) {
    console.log('ROTATE committing transaction');
    Write.commit(tx);
  }
  console.log('=== ROTATE DEBUG END ===');
});

tag('OFFSET',['PURE'], (anchor,arr,ast)=>{
  // Excel-style OFFSET: retrieve value from relative position.
  // y increases downward (top-down grid, flipped 3D Y), so +dy moves down.
  const baseRef=ast.args[0]; // reference cell or default to anchor
  const dx=+valOf(ast.args[1])|0, dy=+valOf(ast.args[2])|0, dz=+valOf(ast.args[3])|0;
  
  // Determine start position
  let startPos = {x:anchor.x, y:anchor.y, z:anchor.z, arrId:anchor.arrId};
  if(baseRef && baseRef.kind==='ref'){
    startPos = {x:baseRef.x, y:baseRef.y, z:baseRef.z, arrId:baseRef.arrId};
  } else {
    const maybe = typeof baseRef==='string' ? parseAlt(String(baseRef)) : null;
    if(maybe){ startPos = {x:maybe.x,y:maybe.y,z:maybe.z,arrId:maybe.arrId}; }
  }
  
  // Apply offsets
  const targetCoord = { x:startPos.x+dx, y:startPos.y+dy, z:startPos.z+dz, arrId:startPos.arrId };
  const value = Formula.getCellValue(targetCoord);
  return value;
});
tag('GET',['PURE'], (anchor,arr,ast)=>{
  // GET reads a ref or first of range; writes scalar to anchor.
  const ref=ast.args[0]; if(ref&&ref.kind==='ref'){ const v=valOf(ref); Actions.setCell(arr.id,anchor, v, ast.raw, true); return; }
  throw new Error('GET needs a ref');
});
tag('ADDRESS',['PURE'],(anchor,arr,ast)=>{
  const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
  Actions.setCell(arr.id,anchor, `${A1(t.x)}${t.y+1}${greek(t.z)}`, ast.raw,true);
});
// SELF: returns anchor's absolute ref coordinates
tag('SELF',['PURE'],(anchor,arr,ast)=>{
  // Return absolute reference string so it works as an argument (e.g., DELETE(SELF()))
  return `@[${anchor.x},${anchor.y},${anchor.z},${anchor.arrId}]`;
});
// IS_SELECTED([ref]): 1 if the provided ref (or self) is the focused cell
tag('IS_SELECTED',['PURE'],(anchor,arr,ast)=>{
  const s=Store.getState().selection; if(!s?.arrayId||!s.focus){ Actions.setCell(arr.id,anchor,0,ast.raw,true); return; }
  const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
  const v=(s.arrayId===t.arrId && s.focus.x===t.x && s.focus.y===t.y && s.focus.z===t.z)?1:0;
  Actions.setCell(arr.id,anchor, v, ast.raw, true);
});
tag('ALT_ADDRESS',['PURE'],(anchor,arr,ast)=>{
  const t=(ast.args[0]&&ast.args[0].kind==='ref')?ast.args[0]:anchor;
  Actions.setCell(arr.id,anchor, `@[${t.x},${t.y},${t.z},${t.arrId}]`, ast.raw,true);
});
tag('IF',['PURE'],(anchor,arr,ast)=>{
  const evalArg = (a)=> Formula.valOf(a);
  const isTruthy=(v)=>{
    if (v===null || v===undefined) return false;
    if (typeof v==='boolean') return v;
    if (Array.isArray(v)) return v.some(isTruthy);
    const n = Number(v);
    if(!Number.isNaN(n) && String(v).trim()!=='') return n!==0;
    const s = String(v).trim().toLowerCase();
    return !(s==='' || s==='false' || s==='0');
  };
  const cond = evalArg(ast.args[0]);
  const out = isTruthy(cond) ? evalArg(ast.args[1]) : (ast.args[2]!==undefined ? evalArg(ast.args[2]) : '');
  return out;
});
tag('REVERSE',['PURE'],(anchor,arr,ast)=>{

  const a=valOf(ast.args[0]); const out=Array.isArray(a)?[...a].reverse():String(a).split('').reverse().join('');
  Actions.setCell(arr.id,anchor, Array.isArray(out)?`[${out.join(',')}]`:out, ast.raw,true);
});
tag('ADD',['PURE'],(anchor,arr,ast)=>{

  const sum=(ast.args.map(valOf).flat()).reduce((a,b)=>a+(+b||0),0);
  Actions.setCell(arr.id,anchor,sum,ast.raw,true);
});
tag('MUL',['PURE'],(anchor,arr,ast)=>{

  const prod=(ast.args.map(valOf).flat()).reduce((a,b)=>a*(+b||1),1);
  Actions.setCell(arr.id,anchor,prod,ast.raw,true);
});
// LOGICALS & COMPARISONS & MATH
tag('AND',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=ast.args.map(valOf).flat().every(x=>!!x)?1:0; Actions.setCell(arr.id,anchor,v,ast.raw,true); });
tag('OR',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=ast.args.map(valOf).flat().some(x=>!!x)?1:0; Actions.setCell(arr.id,anchor,v,ast.raw,true); });
tag('NOT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const v=!valOf(ast.args[0]); Actions.setCell(arr.id,anchor,v?1:0,ast.raw,true); });
tag('EQ',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf); Actions.setCell(arr.id,anchor,(a==b)?1:0,ast.raw,true); });
tag('NEQ',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf); Actions.setCell(arr.id,anchor,(a!=b)?1:0,ast.raw,true); });
tag('GT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a>b)?1:0,ast.raw,true); });
tag('GTE',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a>=b)?1:0,ast.raw,true); });
tag('LT',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a<b)?1:0,ast.raw,true); });
tag('LTE',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const [a,b]=ast.args.map(valOf).map(Number); Actions.setCell(arr.id,anchor,(a<=b)?1:0,ast.raw,true); });
tag('CLAMP',['PURE'],(anchor,arr,ast)=>{ const valOf=Formula.valOf; const x=+valOf(ast.args[0])||0, mn=(+valOf(ast.args[1])||0), mx=(+valOf(ast.args[2])||0); Actions.setCell(arr.id,anchor, Math.min(mx,Math.max(mn,x)), ast.raw,true); });

// WRITE HELPERS
tag('SET',['ACTION'],(anchor,arr,ast,tx)=>{ 
  if(!tx) throw new Error('SET requires an active transaction');
  const target=ast.args[0]; const value=ast.args[1]; const overwrite=ast.args[2]!==undefined?!!valOf(ast.args[2]):true;
  let tref=null;
  if(target&&target.kind==='ref'){ 
    tref = {x:target.x,y:target.y,z:target.z,arrId:target.arrId};
  } else if(typeof target==='string'){
    const parsed = parseAlt(String(target));
    if(parsed) tref = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId};
  } else {
    const sval = valOf(target);
    if(typeof sval==='string'){
      const parsed = parseAlt(String(sval));
      if(parsed) tref = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId};
    }
  }
  if(tref){
    const v=valOf(value); 
    const cell=Formula.getCell({arrId:tref.arrId,x:tref.x,y:tref.y,z:tref.z});
    const isEmpty = (val) => val === '' || val === null || val === undefined;
    if(overwrite || isEmpty(cell.value)){
      Write.set(tx, tref.arrId, {x:tref.x,y:tref.y,z:tref.z}, { value: v, formula: null });
    }
    return; 
  } 
  throw new Error('SET needs target ref'); 
});
// DISPLAY_AS(displayText[, refOrSelf]) — set display-only text in meta without changing value
tag('DISPLAY_AS',['ACTION'],(anchor,arr,ast)=>{
  const text = String(valOf(ast.args[0]||''));
  const t = (ast.args[1]&&ast.args[1].kind==='ref')?ast.args[1]:anchor;
  const ch=arr.chunks[keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)))];
  const idx=ch?.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z) ?? -1;
  if(idx<0||!ch){ Actions.setCell(arr.id,anchor,'DISPLAY_AS:FAIL',ast.raw,true); return; }
  const prev=ch.cells[idx];
  ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), displayText:text}};
  // trigger re-render of 2D and 3D sprites
  UI.renderSheetCell(arr, t.x, t.y, t.z);
  Scene.updateValueSprite(arr, t.x, t.y, t.z, ch.cells[idx]);
  // silent: do not stamp anchor
});
// ONCLICK([targetRefOrRange], actionFormulaOrBlock) — bind click to execute nested action(s)
tag('ONCLICK',['ACTION'],(anchor,arr,ast)=>{
  const parseRawArgs=(raw)=>{
    if(!raw || typeof raw!=='string') return [];
    const open=raw.indexOf('(');
    const close=raw.lastIndexOf(')');
    if(open<0||close<=open) return [];
    const inner=raw.slice(open+1, close);
    const args=[];
    let current='';
    let depth=0;
    let quote=null;
    let escape=false;
    for(let i=0;i<inner.length;i++){
      const ch=inner[i];
      if(escape){ current+=ch; escape=false; continue; }
      if(quote){
        current+=ch;
        if(ch==='\\'){ escape=true; continue; }
        if(ch===quote){ quote=null; }
        continue;
      }
      if(ch==='"' || ch==="'"){ quote=ch; current+=ch; continue; }
      if(ch==='('){ depth++; current+=ch; continue; }
      if(ch===')'){
        if(depth>0){ depth--; current+=ch; continue; }
      }
      if(ch===',' && depth===0){ args.push(current.trim()); current=''; continue; }
      current+=ch;
    }
    if(current.trim().length || inner.trim().length===0){ args.push(current.trim()); }
    return args;
  };
  const normalizeActionString=(raw)=>{
    if(!raw) return '';
    let trimmed=String(raw).trim();
    if(!trimmed) return '';
    if((trimmed.startsWith('"') && trimmed.endsWith('"'))){
      try{ trimmed = JSON.parse(trimmed); }
      catch{}
    }
    trimmed = String(trimmed||'').trim();
    if(!trimmed) return '';
    if(trimmed.startsWith('=') || /^B64:/i.test(trimmed) || /^\d+:/.test(trimmed)) return trimmed;
    return `=${trimmed}`;
  };
  const resolveTargetArg=(arg)=>{
    if(!arg) return null;
    if(arg.kind==='range' || arg.kind==='ref') return arg;
    try{
      const raw = Formula.valOf(arg);
      if(raw==null) return null;
      const text = String(raw).trim();
      if(!text) return null;
      if(text.toLowerCase()==='self') return anchor;
      const parsed = parseAlt(text, anchor) || parseA1g(text, arr.id);
      if(parsed) return parsed;
    }catch{}
    return null;
  };

  const rawArgs = parseRawArgs(ast?.raw||'');
  const actionRawStr = rawArgs.length>=2 ? rawArgs[1] : (rawArgs[0]||'');
  const actionFormula = normalizeActionString(actionRawStr);
  if(!actionFormula){ return; }

  const targetArg = ast.args.length>=2 ? ast.args[0] : null;
  const resolvedTarget = resolveTargetArg(targetArg) || anchor;

  const register = (t)=>{
    const arrId = t.arrId ?? arr.id;
    const targetArr = Store.getState().arrays[arrId];
    if(!targetArr) return;
    const coord = {x:t.x, y:t.y, z:t.z};
    const chKey = keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)));
    const ch=targetArr.chunks[chKey];
    const idx=ch?.cells.findIndex(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z) ?? -1;
    if(idx<0||!ch) return;
    const prev=ch.cells[idx];
    ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), onClick:actionFormula, onClickBusy:false}};
    UI.renderSheetCell(targetArr, coord.x, coord.y, coord.z);
    try{ ch.markDirty?.(); Scene.renderArray(targetArr); }catch{}
  };

  const markClickable=(coord)=>{
    const td=document.querySelector(`td.cell[data-x="${coord.x}"][data-y="${coord.y}"][data-z="${coord.z}"]`);
    if(td) td.classList.add('clickable');
  };

  if(resolvedTarget && resolvedTarget.kind==='range'){
    const xs=resolvedTarget.cells.map(c=>c.x), ys=resolvedTarget.cells.map(c=>c.y);
    const minX=Math.min(...xs), maxY=Math.max(...ys);
    resolvedTarget.cells.forEach(c=> markClickable(c));
    register({x:minX,y:maxY,z:resolvedTarget.cells[0].z, arrId: resolvedTarget.cells[0].arrId});
  } else if(resolvedTarget && resolvedTarget.kind==='ref'){
    markClickable(resolvedTarget);
    register(resolvedTarget);
  } else {
    if(resolvedTarget && resolvedTarget!==anchor){ markClickable(resolvedTarget); }
    register({...resolvedTarget, arrId: resolvedTarget.arrId ?? arr.id});
  }
  // Silent registration
});
// TOAST(message[, duration]) — show toast notification (diegetic, 2D-only)
tag('TOAST',['ACTION'],(anchor,arr,ast)=>{
  const message = String(valOf(ast.args[0]||''));
  const duration = (+valOf(ast.args[1])||3000);
  showToast(message);
  setTimeout(()=>{ const toast=document.getElementById('toast'); if(toast) toast.style.display='none'; }, duration);
  // Silent: do not stamp anchor
});
// ONCLICK_WRAPPER(actionFormulaOrBlock, targetRef?) — helper to add onClick meta easily
tag('ONCLICK_WRAPPER',['ACTION'],(anchor,arr,ast)=>{
  const action = String(valOf(ast.args[0]||''));
  const target = ast.args[1] || anchor;
  const t = (target&&target.kind)? target : anchor;
  const targetArr = Store.getState().arrays[t.arrId || arr.id];
  if(!targetArr) return;
  // Attach meta.onClick and refresh cell rendering in target array
  const ch=targetArr.chunks[keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)))]; if(!ch) return;
  const idx=ch.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z); if(idx<0) return;
  const prev=ch.cells[idx]; ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), onClick:action}};
  const s=Store.getState().selection; const currentId = s.arrayId ?? (Store.getState().arrays[1]?1:-1);
  if(currentId === (t.arrId||arr.id) && window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, t.x, t.y, t.z);
});
// NOTE(text[, targetRefOrRange]) — add note visible only in 2D; highlights range and stores note at top-left
 tag('NOTE',['ACTION'],(anchor,arr,ast)=>{
   const noteText = String(valOf(ast.args[0]||''));
   const target = ast.args[1] || anchor;
   const applyNote = (t)=>{
     const targetArr = Store.getState().arrays[t.arrId || arr.id];
     if(!targetArr){ console.warn('NOTE: target array missing', t); return; }
     const chKey = keyChunk(...Object.values(chunkOf(t.x,t.y,t.z)));
     let ch = targetArr.chunks[chKey];
     if(!ch){
       Actions.resizeArrayIfNeeded(targetArr, t);
       ch = targetArr.chunks[chKey];
       if(!ch){ console.warn('NOTE: chunk still missing', t); return; }
     }
     let idx = ch.cells.findIndex(c=>c.x===t.x&&c.y===t.y&&c.z===t.z);
     if(idx<0){ ch.cells.push({x:t.x, y:t.y, z:t.z, value:'', formula:null, meta:{}}); idx = ch.cells.length - 1; }
     const prev = ch.cells[idx];
     ch.cells[idx] = {...prev, meta:{...(prev.meta||{}), noteText}};
     console.log('NOTE: set meta', {arrId:targetArr.id, x:t.x, y:t.y, z:t.z, meta:ch.cells[idx].meta});
     const s=Store.getState().selection; const currentId = s.arrayId ?? (Store.getState().arrays[1]?1:-1);
     if(currentId === (t.arrId||arr.id) && window.UI?.renderSheetCell) window.UI.renderSheetCell(targetArr, t.x, t.y, t.z);
   };
   if(target && target.kind==='range'){
     target.cells.forEach(c=>{
       const td=document.querySelector(`td.cell[data-x="${c.x}"][data-y="${c.y}"][data-z="${c.z}"]`);
       if(td) td.classList.add('note-hl');
     });
     const xs=target.cells.map(c=>c.x), ys=target.cells.map(c=>c.y);
     const minX=Math.min(...xs), maxY=Math.max(...ys);
     applyNote({x:minX,y:maxY,z:target.cells[0].z, arrId:target.cells[0].arrId});
   } else if(target && target.kind==='ref'){
     const td=document.querySelector(`td.cell[data-x="${target.x}"][data-y="${target.y}"][data-z="${target.z}"]`);
     if(td) td.classList.add('note-hl');
     applyNote(target);
   } else {
     applyNote({...anchor});
   }
   // Silent: do not stamp anchor
 });

// META (legacy helper) — renamed to avoid overriding ACTION CREATE
tag('CREATE_META',['META'],(anchor,arr,ast)=>{
  // Defaults if omitted: 6x4x6 at origin
  const x=(ast.args[0]!==undefined)?(+valOf(ast.args[0])|0):6;
  const y=(ast.args[1]!==undefined)?(+valOf(ast.args[1])|0):4;
  const z=(ast.args[2]!==undefined)?(+valOf(ast.args[2])|0):6;
  const name=ast.args[3]!==undefined?String(valOf(ast.args[3])):'Array';
  const explicitId=ast.args[4]!==undefined?(+valOf(ast.args[4])|0):undefined;
  const newArr=Actions.createArray({size:{x,y,z},name,id:explicitId,offset:{x:0,y:0,z:0}});
  // Write a minimal confirmation; do not overwrite anchor with header text
  Actions.setCell(arr.id,anchor,`${name} #${newArr.id}`,null,true);
});
tag('NAME',['META'],(anchor,arr,ast)=>{

  if(ast.args.length===1){ arr.name=String(valOf(ast.args[0])); Scene.refreshArray?.(arr); Actions.setCell(arr.id,anchor,`Name:${arr.name}`,ast.raw,true); return; }
  // =NAME(alias, formula) - store macro
  const alias=String(valOf(ast.args[0])); const formula=String(valOf(ast.args[1]));
  Store.setState(s=>({namedMacros:new Map([...s.namedMacros,[alias,formula]])}));
  Actions.setCell(arr.id,anchor,`Macro:${alias}`,ast.raw,true);
});
tag('PARAMETERS',['META'],(anchor,arr,ast)=>{

  if(ast.args.length===1){ const j=JSON.parse(String(valOf(ast.args[0])||'{}')); arr.params={...(arr.params||{}), ...j}; Actions.setCell(arr.id,anchor,'PARAMETERS:OK',ast.raw,true); return; }
  // =PARAMETERS(formula, arg1, arg2, ...) - pre-bind args
  const formula=String(valOf(ast.args[0])); const boundArgs=ast.args.slice(1).map(valOf);
  const prebound=`${formula}(${boundArgs.map(a=>typeof a==='string'?`"${a}"`:a).join(',')})`;
  Actions.setCell(arr.id,anchor,prebound,ast.raw,true);
});
tag('FUNCTIONS',['META'],(anchor,arr,ast)=>{

  // =FUNCTIONS(mode, ...items)  items can be names or tags like ":PURE"
  const mode=(String(valOf(ast.args[0])||'ALLOW_ALL')).toUpperCase();
  const pol={mode, allow:new Set(), deny:new Set(), tags:new Set()};
  const items=ast.args.slice(1).map(valOf).flat().map(String);
  items.forEach(it=>{ if(it.startsWith(':')) pol.tags.add(it.slice(1).toUpperCase()); else (mode==='ALLOW_ONLY'?pol.allow:pol.deny).add(it.toUpperCase()); });
  arr.fnPolicy=pol;
  Actions.setCell(arr.id,anchor,'FUNCTIONS:OK',ast.raw,true);
});
tag('LOCK',['META'],(anchor,arr,ast)=>{

  const state=!!valOf(ast.args[0]); if(!state){arr.locks.clear(); Actions.setCell(arr.id,anchor,'LOCK:OFF',ast.raw,true); return;}
  const add=(r)=>{ if(r.kind==='ref') arr.locks.add(aKey(r)); if(r.kind==='range') r.cells.forEach(c=>arr.locks.add(aKey(c))); };
  ast.args.slice(1).forEach(a=>{ if(a?.kind) add(a); });
  Actions.setCell(arr.id,anchor,`LOCK:${arr.locks.size}`,ast.raw,true);
});
// CA (toy)
tag('CA',['PURE'],(anchor,arr,ast)=>{
  const type=String(valOf(ast.args[0])||'life').toLowerCase();
  const steps=+valOf(ast.args[1])||1; const axis=String(valOf(ast.args[2])||'Y').toUpperCase(); const index=+valOf(ast.args[3])|0;
  if(type!=='life') throw new Error('Only life supported');
  CA.runLife2D(arr,{axis,index,steps});
  Actions.setCell(arr.id,anchor,`CA:life ${steps} ${axis}=${index}`,ast.raw,true);
});
// NAVIGATION CONTROL FUNCTIONS
tag('OCCLUDE',['SCENE'],(anchor,arr,ast)=>{
  const mode=String(valOf(ast.args[0])||'auto').toLowerCase(); // 'auto', 'array', 'cell', 'off'
  const style=String(valOf(ast.args[1])||'translucent').toLowerCase(); // 'translucent', 'solid', 'wireframe'
  const intensity=+valOf(ast.args[2])||0.4; // 0.0-1.0 opacity
  arr.occlusionMode={mode,style,intensity};
  Actions.setCell(arr.id,anchor,`Occlude:${mode}/${style}/${intensity}`,ast.raw,true);
});
tag('CAMERA_LOCK',['SCENE'],(anchor,arr,ast)=>{
  const axis=String(valOf(ast.args[0])||'').toUpperCase(); // 'X', 'Y', 'Z', or '' for free
  const angle=+valOf(ast.args[1])||0; // fixed angle in degrees
  Scene.setCameraLock(arr,{axis,angle});
  Actions.setCell(arr.id,anchor,`CameraLock:${axis||'free'}/${angle}°`,ast.raw,true);
});

// GLOBAL STATE FUNCTIONS
tag('GET_GLOBAL',['PURE'],(anchor,arr,ast)=>{
  const key = String(valOf(ast.args[0]) || '');
  if(!key) throw new Error('GET_GLOBAL requires a key');
  const value = Store.getState().globalState.get(key);
  Actions.setCell(arr.id, anchor, value !== undefined ? value : '', ast.raw, true);
});

tag('SET_GLOBAL',['ACTION'],(anchor,arr,ast)=>{
  const key = String(valOf(ast.args[0]) || '');
  const value = valOf(ast.args[1]);
  if(!key) throw new Error('SET_GLOBAL requires a key');
  
  // Write to global state
  Store.getState().globalState.set(key, value);
  
  // Trigger re-computation for all dependent anchors
  const dependents = Store.getState().anchorsByGlobalKey.get(key) || new Set();
  if(dependents.size > 0) {
    Formula.recomputeAnchors([...dependents]);
  }
  
  Actions.setCell(arr.id, anchor, `Global[${key}] = ${value}`, ast.raw, true);
});

// GET_NEXT_ID(): returns the next array id (does not allocate by itself)
tag('GET_NEXT_ID',["PURE"],(anchor,arr,ast)=>{
  const S=Store.getState();
  return S.nextArrayId || 1;
});

// VALUE_AT(x,y,z, arrIdExpr): returns the value at absolute coordinates without writing
tag('VALUE_AT',["PURE"],(anchor,arr,ast)=>{
  const ax = Number(Formula.valOf(ast.args[0]));
  const ay = Number(Formula.valOf(ast.args[1]));
  const az = Number(Formula.valOf(ast.args[2]));
  const a4 = Formula.valOf(ast.args[3]);
  const arrId = Number(a4);
  if(!Number.isFinite(arrId)) return '';
  const x = (ax===0) ? (anchor?.x|0) : (Number.isFinite(ax) ? (ax-1) : (anchor?.x|0));
  const y = (ay===0) ? (anchor?.y|0) : (Number.isFinite(ay) ? (ay-1) : (anchor?.y|0));
  const z = (az===0) ? (anchor?.z|0) : (Number.isFinite(az) ? (az-1) : (anchor?.z|0));
  return Formula.getCellValue({arrId, x, y, z});
});

// --- Tiny Formula-AST helpers for FORMULIZE ---
function V(v){ return { value:v }; }
function F(name){ return { fn:String(name||'').toUpperCase(), args:[...Array.prototype.slice.call(arguments,1)] }; }
function escForStringLiteral(s){ return String(s).replace(/\\/g,'\\\\').replace(/"/g,'\\\"'); }
function astToString(node, top=true){
  if(node && Object.prototype.hasOwnProperty.call(node,'value')){
    const v=node.value;
    if(typeof v==='string') return `"${escForStringLiteral(v)}"`;
    if(v===true) return 'TRUE';
    if(v===false) return 'FALSE';
    if(v===null || v===undefined) return '""';
    if(Number.isFinite(+v)) return String(+v);
    return `"${escForStringLiteral(String(v))}"`;
  }
  if(node && node.fn){
    const args=(node.args||[]).map(n=>astToString(n,false)).join(', ');
    return (top? '=' : '') + `${node.fn}(${args})`;
  }
  return '""';
}
function remapFormulaIds(f, ids, idIndexOf, varsIdExprStr){
  let out=String(f||'');
  ids.forEach(oldId=>{
    const idx = idIndexOf.get(oldId);
    if(idx===undefined) return;
    const valueAtCall = `VALUE_AT(${idx},0,0, ${varsIdExprStr})`;
    // ^<oldId>
    out = out.replace(new RegExp(`\\^${oldId}\\b`,'g'), `^" & ${valueAtCall} & "`);
    // @[x,y,z,<oldId>]
    out = out.replace(new RegExp(`@\\[(-?\\d+),(-?\\d+),(-?\\d+),${oldId}\\]`,'g'), `@[" & $1 & "," & $2 & "," & $3 & "," & ${valueAtCall} & "]`);
  });
  return out;
}

// FORMULIZE: Build a DO(...) program using AST and serialize once
tag('FORMULIZE',["ACTION"],(anchor,arr,ast)=>{
  try{
    const S=Store.getState();
    // 1) Collect reachable array ids via BFS based on formula references
    const startId = arr.id;
    const seen=new Set(); const q=[startId]; seen.add(startId);
    const refRe = /@\[(-?\d+),(-?\d+),(-?\d+),(-?\d+)\]/g; // capture arrId at group 4
    const caretRe = /\^(\-?\d+)\b/g;
    while(q.length){
      const aid=q.shift(); const A=S.arrays[aid]; if(!A) continue;
      Object.values(A.chunks||{}).forEach(ch=>{
        (ch.cells||[]).forEach(c=>{
          const f=c.formula||''; let m;
          while((m=refRe.exec(f))){ const id=+m[4]; if(Number.isFinite(id) && !seen.has(id)){ seen.add(id); q.push(id);} }
          while((m=caretRe.exec(f))){ const id=+m[1]; if(Number.isFinite(id) && !seen.has(id)){ seen.add(id); q.push(id);} }
        });
      });
    }
    const ids=[...seen];

    // 2) Prepare index map for oldId -> vars cell index
    const idIndexOf = new Map();
    ids.forEach((id,i)=> idIndexOf.set(id,i));

    // 3) Build commands AST
    const commands=[]; // FNode[]

    // Seed: store base next-id on the builder anchor for later reference (N)
    commands.push( F('SET', F('SELF'), F('GET_NEXT_ID')) );
    // Also store into a temporary global key for robust retrieval in nested VALUE_AT
    commands.push( F('SET_GLOBAL', V('FORMULIZE_BASE_ID'), F('SELF')) );

    // Create VARS array with explicit id = base N captured at anchor
    const varsW = ids.length, varsH = 1, varsD = 1;
    const varsIdExpr = F('VALUE_AT', V(anchor.x+1), V(anchor.y+1), V(anchor.z+1), V(anchor.arrId));
    commands.push( F('CREATE', V(varsW), V(varsH), V(varsD), V('FORMULIZE_VARS'), varsIdExpr) );

    // Populate mapping cells with upcoming ids (GET_NEXT_ID() will advance as we CREATE later)
    ids.forEach((oldId, idx)=>{
      const innerText = astToString( F('SET', F('SELF'), F('GET_NEXT_ID')) );
      commands.push( F('EXEC_AT', V(idx), V(0), V(0), varsIdExpr, V(innerText)) );
    });

    const varsIdCallStr = astToString(varsIdExpr, true).slice(1); // strip leading '=' for string interpolation context

    // CREATE arrays with size, name, and explicit id read from VARS[idx]
    ids.forEach((oldId, idx)=>{
      const A=S.arrays[oldId]; if(!A) return; const name=A.name||'Array';
      const explicitIdExpr = F('VALUE_AT', V(idx), V(0), V(0), varsIdExpr);
      commands.push( F('CREATE', V(A.size.x), V(A.size.y), V(A.size.z), V(name), explicitIdExpr) );
    });

    // Helper to exec at a coordinate on target array id held in global
    const execAt = (oldId, x,y,z, nestedFormulaText)=>{
      commands.push( F('EXEC_AT', V(x), V(y), V(z), F('GET_GLOBAL', V(idMap.get(oldId))), V(nestedFormulaText) ) );
    };

    // 4) Populate scalar values (no formulas) and replicate color meta
    ids.forEach((oldId, idx)=>{
      const A=S.arrays[oldId]; if(!A) return;
      Object.values(A.chunks||{}).forEach(ch=>{
        (ch.cells||[]).forEach(c=>{
          const hasValue = (c.value!=='' && c.value!==null && c.value!==undefined);
          if(hasValue && !c.formula){
            const innerSet = F('SET', F('SELF'), V(c.value));
            const hasColor = !!(c.meta && c.meta.color);
            const innerAst = hasColor
              ? F('DO', innerSet, F('COLOR', V(String(c.meta.color||'#ffffff')), F('SELF')))
              : innerSet;
            const innerText = astToString(innerAst); // "=SET(SELF(), ...)" or DO(...)
            const targetIdExpr = F('VALUE_AT', V(idx), V(0), V(0), varsIdExpr);
            commands.push( F('EXEC_AT', V(c.x), V(c.y), V(c.z), targetIdExpr, V(innerText)) );
          }
        });
      });
    });

    // 5) Stamp formulas with id remapping
    ids.forEach((oldId, idx)=>{
      const A=S.arrays[oldId]; if(!A) return;
      Object.values(A.chunks||{}).forEach(ch=>{
        (ch.cells||[]).forEach(c=>{
          const f=c.formula; if(!f) return;
          const remapped = remapFormulaIds(f, ids, idIndexOf, varsIdCallStr);
          const formulaText = remapped.startsWith('=') ? remapped : ('='+remapped);
          const targetIdExpr = F('VALUE_AT', V(idx), V(0), V(0), varsIdExpr);
          commands.push( F('EXEC_AT', V(c.x), V(c.y), V(c.z), targetIdExpr, V(formulaText)) );
        });
      });
    });

    // 6) Restore world positions
    ids.forEach((oldId, idx)=>{
      const A=S.arrays[oldId]; if(!A) return; const off=A.offset||{x:0,y:0,z:0};
      const targetIdExpr = F('VALUE_AT', V(idx), V(0), V(0), varsIdExpr);
      commands.push( F('SET_ARRAY_POS', targetIdExpr, V(Math.round(off.x||0)), V(Math.round(off.y||0)), V(Math.round(off.z||0))) );
    });

    // 7) Self-cleanup: clear the builder cell value
    commands.push( F('SET', F('SELF'), V('')) );

    // 8) Serialize in one DO(...) payload and stamp
    const doArgs = commands.map(cmd=> V(astToString(cmd, true)));
    const doAst = F('DO', ...doArgs);
    const out = astToString(doAst);
    Actions.setCell(arr.id, anchor, out, ast.raw, true);
  }catch(e){
    Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
  }
});
// COMBINE(0|1): toggle global gobbling interactions
tag('COMBINE',["ACTION","META"],(anchor,arr,ast)=>{
  const enable = !!Formula.valOf(ast.args[0]);
  const S=Store.getState();
  Store.setState(s=>({ interactions:{ ...(s.interactions||{}), gobblingEnabled: enable } }));
  Actions.setCell(arr.id, anchor, `Combine Mode: ${enable?'ON':'OFF'}`, ast.raw, true);
});

// Import handler for CSV/TSV/XLSX (using SheetJS)
async function handleImportedData(data, fileName = 'PastedData'){
  try{
    const S = Store.getState();
    let workbook;
    if (typeof data === 'string') {
      workbook = XLSX.read(data, { type: 'string' });
    } else {
      workbook = XLSX.read(data, { type: 'array' });
    }
    const sheetNames = workbook.SheetNames||[]; if(sheetNames.length===0){ showToast('Import failed: No sheets'); return; }
    const sheets = sheetNames.map(name=> XLSX.utils.sheet_to_json(workbook.Sheets[name], { header:1, defval:'' }));
    let maxX=0,maxY=0; const maxZ=sheets.length;
    sheets.forEach(sh=>{ maxY=Math.max(maxY, sh.length); sh.forEach(r=>{ maxX=Math.max(maxX, r.length); }); });
    if(maxX===0||maxY===0){ showToast('Import failed: Empty'); return; }
    const baseName = String(fileName||'Data').split('.')[0].replace(/_/g,' ');
    const dataArray = Actions.createArray({ name: baseName, size:{x:maxX,y:maxY,z:maxZ} });
    const labelArray = Actions.createArray({ name: `${baseName} Labels`, size:{x:1,y:1,z:maxZ} });
    const tx = Write.start('importer.create', `Import ${fileName}`);
    sheets.forEach((sheetData, z)=>{
      Write.set(tx, labelArray.id, {x:0,y:0,z}, { value: sheetNames[z], formula:null });
      sheetData.forEach((row,y)=>{
        row.forEach((val,x)=>{
          if(val!=='' && val!=null){ Write.set(tx, dataArray.id, {x,y,z}, { value:String(val), formula:null }); }
        });
      });
    });
    Write.commit(tx);
    // Position near host
    const host = (typeof UI!=='undefined' && UI.currentArray) ? UI.currentArray() : Object.values(Store.getState().arrays)[0];
    try{
      const pos = dockOffsetFor(host||dataArray,'east',2.0);
      Scene.setArrayOffset(dataArray,pos);
      const labelPos = dockOffsetFor(dataArray,'top',1.0);
      Scene.setArrayOffset(labelArray,labelPos);
    }catch{}
    Actions.setSelection(dataArray.id,{x:0,y:0,z:0},null,'3d');
    Scene.centerOnArray?.(dataArray);
    showToast(`Imported ${sheetNames.length} sheet(s)`);
  }catch(e){ console.error('Import Error', e); showToast(`Import failed: ${e.message}`); }
}

// COLOR(hexColor, [targetRefOrRange]) - sets the background color of cells.
tag('COLOR',["ACTION"], (anchor, arr, ast, tx) => {
  if (!tx) throw new Error('COLOR requires an active transaction');
  const colorValRaw = Formula.valOf(ast.args[0] || '#ffffff');
  const colorVal = String(colorValRaw==null?'#ffffff':colorValRaw).trim();
  if (!/^#[0-9a-fA-F]{6}$/.test(colorVal)) {
    Actions.setCell(arr.id, anchor, '!ERR:COLOR_FORMAT', ast.raw, true);
    return;
  }

  const targetArg = ast.args[1] || anchor;
  const targets = [];
  if (targetArg && targetArg.kind === 'range') {
    targets.push(...targetArg.cells);
  } else if (targetArg && targetArg.kind === 'ref') {
    targets.push(targetArg);
  } else {
    targets.push(anchor);
  }

  targets.forEach(t => {
    const cell = Formula.getCell(t);
    Write.set(tx, t.arrId, { x: t.x, y: t.y, z: t.z }, {
      value: cell.value,
      formula: (t.arrId===anchor.arrId && t.x === anchor.x && t.y === anchor.y && t.z === anchor.z) ? (cell.formula ?? ast.raw) : cell.formula,
      meta: { ...(cell.meta||{}), color: colorVal }
    });
  });
  // Silent: no stamp
});

// GETCOLOR([targetRef]) - returns the hex color of a cell.
tag('GETCOLOR',["PURE"], (anchor, arr, ast) => {
  const target = (ast.args[0] && ast.args[0].kind === 'ref') ? ast.args[0] : anchor;
  const cell = Formula.getCell(target);
  return (cell && cell.meta && cell.meta.color) ? cell.meta.color : '#3b82f6';
});

// EVENT BUS FUNCTIONS
tag('ON_EVENT',['META'],(anchor,arr,ast)=>{
  const eventName = String(valOf(ast.args[0]) || '');
  const actionFormula = String(valOf(ast.args[1]) || '');
  if(!eventName || !actionFormula) throw new Error('ON_EVENT requires eventName and actionFormula');
  
  const listeners = Store.getState().eventListeners;
  if(!listeners.has(eventName)) listeners.set(eventName, []);
  
  const listenerObj = {
    anchor: {...anchor}, // Store anchor location
    actionFormula,
    arrId: arr.id
  };
  
  listeners.get(eventName).push(listenerObj);
  Actions.setCell(arr.id, anchor, `Listen[${eventName}]: ${actionFormula}`, ast.raw, true);
});
tag('FIRE_EVENT',['ACTION'],(anchor,arr,ast,tx)=>{
  const eventName = String(valOf(ast.args[0]) || '');
  const payload = ast.args[1] !== undefined ? valOf(ast.args[1]) : null;
  if(!eventName) throw new Error('FIRE_EVENT requires eventName');
  
  // Store payload in global state temporarily for listeners to access
  if(payload !== null) {
    Store.getState().globalState.set(`event.payload.${eventName}`, payload);
  }
  
  const listeners = Store.getState().eventListeners.get(eventName) || [];
  
  // Execute all listener formulas
  listeners.forEach(listener => {
    try {
      const targetAnchor = {arrId: listener.arrId, ...listener.anchor};
      // Reuse provided tx if present; otherwise create a scoped one per event
      if(tx){
        Formula.executeAt(targetAnchor, listener.actionFormula, tx);
      } else {
        const etx = Write.start(`event.${eventName}`,'Event dispatch');
        Formula.executeAt(targetAnchor, listener.actionFormula, etx);
        Write.commit(etx);
      }
    } catch(e) {
      console.error(`Event listener error for ${eventName}:`, e);
    }
  });
  
  Actions.setCell(arr.id, anchor, `Fired[${eventName}]${payload ? ` with ${payload}` : ''}`, ast.raw, true);
});

// INFORMATION & INTERACTION CONTROL
tag('GET_PLAYER_FOCUS',['PURE'],(anchor,arr,ast)=>{
  const selection = Store.getState().selection;
  if(!selection.focus || !selection.arrayId) {
    Actions.setCell(arr.id, anchor, '', ast.raw, true);
    return;
  }
  
  const address = `@[${selection.focus.x},${selection.focus.y},${selection.focus.z},${selection.arrayId}]`;
  Actions.setCell(arr.id, anchor, address, ast.raw, true);
});
tag('CANT_TARGET',['META'],(anchor,arr,ast)=>{
  const target = ast.args[0];
  if(!target) throw new Error('CANT_TARGET requires a range or reference');
  
  const markUntargetable = (x, y, z, arrId) => {
    const targetArr = Store.getState().arrays[arrId];
    if(!targetArr) return;
    const ch = targetArr.chunks[keyChunk(...Object.values(chunkOf(x, y, z)))];
    if(!ch) return;
    const cell = ch.cells.find(c => c.x === x && c.y === y && c.z === z);
    if(cell) {
      if(!cell.meta) cell.meta = {};
      cell.meta.isTargetable = false;
    }
  };
  
  if(target.kind === 'ref') {
    markUntargetable(target.x, target.y, target.z, target.arrId);
  } else if(target.kind === 'range') {
    target.cells.forEach(cell => {
      markUntargetable(cell.x, cell.y, cell.z, cell.arrId);
    });
  }
  
  Actions.setCell(arr.id, anchor, 'Protected cells marked', ast.raw, true);
});

// GAME HELPER FUNCTIONS
tag('GET_ARRAY_POS',["PURE"],(anchor,arr,ast)=>{
  const target=ast.args[0]&&ast.args[0].kind==='ref'? Store.getState().arrays[ast.args[0].arrId] : arr;
  if(!target){ Actions.setCell(arr.id,anchor,'',ast.raw,true); return; }
  const o = target.offset||{x:0,y:0,z:0};
  Actions.setCell(arr.id, anchor, `{"x":${o.x},"y":${o.y},"z":${o.z}}`, ast.raw, true);
});
tag('SET_ARRAY_POS',["SCENE","ACTION"],(anchor,arr,ast)=>{
  let target=null;
  if(ast.args[0] && ast.args[0].kind==='ref'){
    target = Store.getState().arrays[ast.args[0].arrId];
  } else {
    const maybeId = +Formula.valOf(ast.args[0]);
    if(Number.isInteger(maybeId)) target = Store.getState().arrays[maybeId];
    if(!target) target = arr;
  }
  const x=(+Formula.valOf(ast.args[1])||0), y=(+Formula.valOf(ast.args[2])||0), z=(+Formula.valOf(ast.args[3])||0);
  if(!target) { Actions.setCell(arr.id,anchor,'!ERR:ARR',ast.raw,true); return; }
  Scene.setArrayOffset(target,{x,y,z});
  Actions.setCell(arr.id,anchor,`Pos:${x},${y},${z}`,ast.raw,true);
});
// Backward-compatible alias: TRANSLATE_ARRAY delegates to 3D_TRANSLATE
tag('TRANSLATE_ARRAY',["SCENE"],(anchor,arr,ast)=> Fn['3D_TRANSLATE'].impl(anchor,arr,ast));
// 3D_ROTATE(stepsY) or 3D_ROTATE(stepsX,stepsY,stepsZ)
tag('3D_ROTATE',["SCENE"],(anchor,arr,ast)=>{
  // Parse args
  const sx = ast.args[1]!==undefined ? ((+Formula.valOf(ast.args[0])||0)|0) : 0;
  const sy = ast.args[1]!==undefined ? ((+Formula.valOf(ast.args[1])||0)|0) : ((+Formula.valOf(ast.args[0])||0)|0);
  const sz = ast.args[2]!==undefined ? ((+Formula.valOf(ast.args[2])||0)|0) : 0;
  const cont = !!((+Formula.valOf(ast.args[3]||0))|0);

  const S=Store.getState();
  const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(arr.id));
  const ids = group
    ? (group.mode==='parent'
        ? [arr.id, ...group.members.filter(id=> id!==arr.id && group.members.indexOf(id) > group.members.indexOf(arr.id))]
        : [...group.members])
    : [arr.id];
  const arrays = ids.map(id=>S.arrays[id]).filter(Boolean);

  // If timed gamestate is active on the host, queue high-level rotate and exit
  let timed0 = null; try{ if(typeof Scene!=='undefined' && Scene.ensureTimedState) timed0 = Scene.ensureTimedState(arr); }catch{}
  if(!timed0){ try{ arr.params = arr.params || {}; arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null }; timed0 = arr.params.timed; }catch{} }
  const G0=(Store.getState().scene||{}).timed3D;
  if((timed0 && timed0.previewInArray) || (G0&&G0.preview)){
    // In preview, do not apply or stamp; animation system will parse formulas and animate
    return;
  }
  // Non-repeat executable: if this anchor already applied a rotation, skip
  try{
    const ak=aKey(anchor);
    const existing=(Store.getState().activeRotations||new Map()).get(ak);
    if(existing && !cont){ Actions.setCell(arr.id, anchor, `3D_Rotate:skip`, (ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`)); return; }
  }catch{}
  // Ensure frames exist for all arrays so transforms apply
  arrays.forEach(a=>{ if(!a._frame) Scene.renderArray(a); });

  // Compute world-space pivot at the CENTER of the anchor cell
  const pivotWorld = Scene.cellWorldPos(arr, anchor.x, anchor.y, anchor.z);

  // Optional: compute group bounds from extreme cell centers (min/max per axis)
  const boundsOf = (a)=>{
    const xs=[0,Math.max(0,a.size.x-1)], ys=[0,Math.max(0,a.size.y-1)], zs=[0,Math.max(0,a.size.z-1)];
    let minX= Infinity,minY= Infinity,minZ= Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
    xs.forEach(ix=> ys.forEach(iy=> zs.forEach(iz=>{
      const p=Scene.cellWorldPos(a, ix, iy, iz);
      if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.z<minZ)minZ=p.z;
      if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; if(p.z>maxZ)maxZ=p.z;
    })));
    return {minX,minY,minZ,maxX,maxY,maxZ};
  };
  const pre = arrays.reduce((acc,a)=>{ const b=boundsOf(a); return {
    minX:Math.min(acc.minX,b.minX), minY:Math.min(acc.minY,b.minY), minZ:Math.min(acc.minZ,b.minZ),
    maxX:Math.max(acc.maxX,b.maxX), maxY:Math.max(acc.maxY,b.maxY), maxZ:Math.max(acc.maxZ,b.maxZ)
  }; }, {minX:Infinity,minY:Infinity,minZ:Infinity,maxX:-Infinity,maxY:-Infinity,maxZ:-Infinity});

  // Apply atomic rotation around pivot to all arrays
  arrays.forEach(a=> Scene.rotateArrayAround(a, pivotWorld, sx, sy, sz));

  // After rotation, do a light snap and ensure offsets are consistent
  arrays.forEach(a=>{
    if(a._frame){
      a.offset = { x: Math.round(a._frame.position.x), y: Math.round(a._frame.position.y), z: Math.round(a._frame.position.z) };
    }
  });

  // Recompute bounds post-rotation (for correctness/visual sanity)
  const post = arrays.reduce((acc,a)=>{ const b=boundsOf(a); return {
    minX:Math.min(acc.minX,b.minX), minY:Math.min(acc.minY,b.minY), minZ:Math.min(acc.minZ,b.minZ),
    maxX:Math.max(acc.maxX,b.maxX), maxY:Math.max(acc.maxY,b.maxY), maxZ:Math.max(acc.maxZ,b.maxZ)
  }; }, {minX:Infinity,minY:Infinity,minZ:Infinity,maxX:-Infinity,maxY:-Infinity,maxZ:-Infinity});

  const clampSteps=(n)=>(((n%4)+4)%4);
  const degX = clampSteps(sx)*90, degY = clampSteps(sy)*90, degZ = clampSteps(sz)*90;
  Actions.setCell(arr.id,anchor,`3D_Rotate:${sx},${sy},${sz}`,(ast.raw||`=3D_ROTATE(${sx},${sy},${sz})`));
  // Persist for refresh-time revert
  try{
    const ak=aKey(anchor);
    const S=Store.getState();
    const rec={targetId:targetArr.id, ids:[...ids], pivot:{...anchor, arrId:arr.id}, steps:{sx,sy,sz}};
    const map=new Map(S.activeRotations||new Map()); map.set(ak, rec); Store.setState({activeRotations:map});
    const txw = Write.start('mark.3d.rotate','mark');
    const cell = Formula.getCell(anchor) || {value:'',formula:null,meta:{}};
    Write.set(txw, arr.id, {x:anchor.x,y:anchor.y,z:anchor.z}, { value: cell.value, formula: cell.formula, meta:{...(cell.meta||{}), appliedRotate: rec } });
    Write.commit(txw);
  }catch{}
});
// Backward-compatible alias: ROTATE_ARRAY delegates to 3D_ROTATE
tag('ROTATE_ARRAY',["SCENE"],(anchor,arr,ast)=>{
  return Fn['3D_ROTATE'].impl(anchor,arr,ast);
});
tag('VECTOR_TO',['PURE'],(anchor,arr,ast)=>{
  const fromAddr = String(valOf(ast.args[0]) || '');
  const toAddr = String(valOf(ast.args[1]) || '');
  
  // Parse addresses like @[x,y,z,arrId] or cell references
  const parseAddr = (addr) => {
    const m = /@\[(-?\d+)?,(-?\d+)?,(-?\d+)?,(-?\d+)\]/.exec(String(addr).trim());
    if(!m) return null;
    // Use 0 => current component; missing => 1
    const toOneBased=(val,cur)=>{ if(val===undefined||val===null||val==='') return 1; const n=+val; return n===0? (cur+1) : n; };
    const xb=toOneBased(m[1], from.x), yb=toOneBased(m[2], from.y), zb=toOneBased(m[3], from.z);
    return {x: xb-1, y: yb-1, z: zb-1, arrId:+m[4]};
  };
  
  const from = parseAddr(fromAddr);
  const to = parseAddr(toAddr);
  
  if(!from || !to) {
    Actions.setCell(arr.id, anchor, '{"gravity":[0,0,0]}', ast.raw, true);
    return;
  }
  
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const dz = to.z - from.z;
  const mag = Math.sqrt(dx*dx + dy*dy + dz*dz);
  
  if(mag === 0) {
    Actions.setCell(arr.id, anchor, '{"gravity":[0,0,0]}', ast.raw, true);
    return;
  }
  
  const nx = dx / mag;
  const ny = dy / mag;
  const nz = dz / mag;
  
  const vector = `{"gravity":[${nx.toFixed(3)},${ny.toFixed(3)},${nz.toFixed(3)}]}`;
  Actions.setCell(arr.id, anchor, vector, ast.raw, true);
});
tag('PLATFORMER_PHYSICS',['ACTION'],(anchor,arr,ast)=>{
  // Simple platformer physics implementation
  const currentPos = Store.getState().globalState.get('platformer.pos') || '@[4,3,0,1]';
  const input = Store.getState().globalState.get('platformer.input') || 'none';
  
  const parsePos = (pos) => {
    const m = /@\[(-?\d+)?,(-?\d+)?,(-?\d+)?,(-?\d+)\]/.exec(String(pos).trim());
    if(m){
      const toOneBased=(v,cur)=>{ if(v===undefined||v===null||v==='') return 1; const n=+v; return n===0? (cur+1) : n; };
      const xb=toOneBased(m[1], 4), yb=toOneBased(m[2], 3), zb=toOneBased(m[3], 0); // defaults if 0 used outside anchor
      return {x: xb-1, y: yb-1, z: zb-1, arrId:+m[4]};
    }
    return {x: 4, y: 3, z: 0, arrId: 1};
  };
  
  const pos = parsePos(currentPos);
  let newPos = {...pos};
  
  // Handle input
  switch(input) {
    case 'left': newPos.x = Math.max(0, pos.x - 1); break;
    case 'right': newPos.x = Math.min(7, pos.x + 1); break;
    case 'up': newPos.y = Math.min(3, pos.y + 1); break;
    case 'down': newPos.y = Math.max(0, pos.y - 1); break;
  }
  
  // Clear old position and set new position
  if(newPos.x !== pos.x || newPos.y !== pos.y) {
    try {
      Actions.setCell(pos.arrId, {x: pos.x, y: pos.y, z: pos.z}, '', null, true);
      Actions.setCell(newPos.arrId, {x: newPos.x, y: newPos.y, z: newPos.z}, '🎮', null, true);
      Store.getState().globalState.set('platformer.pos', `@[${newPos.x},${newPos.y},${newPos.z},${newPos.arrId}]`);
    } catch(e) {
      console.error('Platformer physics error:', e);
    }
  }
  
  Actions.setCell(arr.id, anchor, `Player: ${newPos.x},${newPos.y}`, ast.raw, true);
});
// GAME FUNCTIONS
tag('FISH',['GAME'],(anchor,arr,ast)=>{
  // Initialize FISH game state and setup
  Actions.begin();
  
  // Set up game state
  Store.getState().globalState.set('fish.state', 'IDLE');
  Store.getState().globalState.set('fish.timer', 0);
  Store.getState().globalState.set('player.score', 0);
  
  // Create game UI at anchor
  Actions.setCell(arr.id, anchor, '🎣 FISH GAME', ast.raw, true);
  Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y,z:anchor.z}, '=ON_SELECT(SELF(),"=FIRE_EVENT(\\"CAST\\")")', null, true);
  Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y,z:anchor.z}, '=ON_SELECT(SELF(),"=IF(GET_GLOBAL(\\"fish.state\\")=\\"BITING\\",FIRE_EVENT(\\"CATCH\\"))")', null, true);
  Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("fish.state")', null, true);
  Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("fish.timer")', null, true);
  Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("player.score")', null, true);
  
  // Set up event listeners
  Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("CAST","=SET_GLOBAL(\\"fish.state\\",\\"WAITING\\")")', null, true);
  Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("TICK","=IF(AND(GET_GLOBAL(\\"fish.state\\")=\\"WAITING\\",GT(GET_GLOBAL(\\"fish.timer\\"),0)),SET_GLOBAL(\\"fish.timer\\",ADD(GET_GLOBAL(\\"fish.timer\\"),-1)))")', null, true);
  Actions.setCell(arr.id, {x:anchor.x+2,y:anchor.y-2,z:anchor.z}, '=ON_EVENT("CATCH","=SET_GLOBAL(\\"player.score\\",ADD(GET_GLOBAL(\\"player.score\\"),1))")', null, true);
  
  Actions.end();
});
tag('GALAXY',['GAME'],(anchor,arr,ast)=>{
  // Initialize GALAXY puzzle game
  Actions.begin();
  
  // Set up game state
  Store.getState().globalState.set('galaxy.active', 1);
  Store.getState().globalState.set('galaxy.gravityWell', `@[${anchor.x+1},${anchor.y+2},${anchor.z},${arr.id}]`);
  
  // Create gravity well
  Actions.setCell(arr.id, anchor, '🌌 GALAXY PUZZLE', ast.raw, true);
  Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y+2,z:anchor.z}, '🌎', null, true);
  
  // Set up physics system
  Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-1,z:anchor.z}, '=ON_EVENT("TICK","=SET_GLOBAL(\\"galaxy.gravityVector\\",VECTOR_TO(GET_PLAYER_FOCUS(),GET_GLOBAL(\\"galaxy.gravityWell\\")))")', null, true);
  Actions.setCell(arr.id, {x:anchor.x+1,y:anchor.y-1,z:anchor.z}, '=GET_GLOBAL("galaxy.gravityVector")', null, true);
  
  // Goal condition
  Actions.setCell(arr.id, {x:anchor.x,y:anchor.y-2,z:anchor.z}, '=IF(EQ(GET_PLAYER_FOCUS(),GET_GLOBAL("galaxy.gravityWell")),"🎯 WIN!","Navigate to 🌎")', null, true);
  
  Actions.end();
});
// SOKOBAN puzzle generator and step logic
tag('SOKO_STEP',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('SOKO_STEP requires an active transaction');
  const memRefArg = ast.args[0];
  const dx = (+Formula.valOf(ast.args[1])|0) || 0;
  const dy = (+Formula.valOf(ast.args[2])|0) || 0;
  if(!memRef || memRef.kind !== 'ref') throw new Error('SOKO_STEP needs memory ref');
  const memVal = Formula.getCellValue(memRef);
  const pos = parseAlt(String(memVal)||'');
  if(!pos) return; // nothing to do
  const boardId = pos.arrId; const px = pos.x; const py = pos.y; const pz = pos.z||0;
  const board = Store.getState().arrays[boardId]; if(!board) return;
  const inBounds=(x,y)=> x>=0 && y>=0 && x<board.size.x && y<board.size.y;
  const at=(x,y)=> inBounds(x,y)? Formula.getCellValue({arrId:boardId,x,y,z:pz}) : '█';
  const WALL='█', BOX='📦', PLAYER='🙂', EMPTY='';
  const nx=px+dx, ny=py+dy; const nnx=px+dx*2, nny=py+dy*2;
  const t1 = at(nx,ny);
  if(t1===WALL) return;
  if(t1===BOX){
    const t2 = at(nnx,nny);
    if(t2!==EMPTY) return; // cannot push
    // push box
    Write.set(tx, boardId, {x:nnx,y:nny,z:pz}, { value: BOX, formula:null });
    Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
    Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
    // update memory
    const newRef = `@[${nx},${ny},${pz},${boardId}]`;
    Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
    return;
  }
  // simple move into empty
  if(t1===EMPTY){
    Write.set(tx, boardId, {x:nx ,y:ny ,z:pz}, { value: PLAYER, formula:null });
    Write.set(tx, boardId, {x:px ,y:py ,z:pz}, { value: EMPTY, formula:null });
    const newRef = `@[${nx},${ny},${pz},${boardId}]`;
    Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
  }
});

// SOKOBAN2: Diegetic rules via Rules array and dispatcher
tag('SOKO_STEP2',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('SOKO_STEP2 requires an active transaction');
  const memRefArg = ast.args[0];
  const dx = (+Formula.valOf(ast.args[1])|0) || 0;
  const dy = (+Formula.valOf(ast.args[2])|0) || 0;
  if(!memRef || memRef.kind !== 'ref') throw new Error('SOKO_STEP2 needs memory ref');
  // Set global context for rules
  Store.getState().globalState.set('soko.dx', dx);
  Store.getState().globalState.set('soko.dy', dy);
  Store.getState().globalState.set('soko.memRef', `@[${memRef.x},${memRef.y},${memRef.z},${memRef.arrId}]`);
  // Execute the MOVE rule at the MOVE anchor (stored at Rules[0,0])
  const memVal = Formula.getCellValue(memRef);
  const pos = parseAlt(String(memVal)||''); if(!pos) return;
  const boardId = pos.arrId; const pz = pos.z||0;
  // Find Rules array by convention: same board name + " Rules" or first array with params.sokoRules
  const rulesArr = Object.values(Store.getState().arrays).find(a=>a.params?.sokoRules && a.params?.boardId===boardId);
  if(!rulesArr) { Actions.setCell(arr.id, anchor, '!ERR:No Rules', ast.raw, true); return; }
  // MOVE anchor stored in params
  const mv = rulesArr.params?.moveAnchor || {x:0,y:rulesArr.size.y-1,z:0,arrId:rulesArr.id};
  Formula.executeAt({arrId:mv.arrId,x:mv.x,y:mv.y,z:mv.z}, undefined, tx);
  Actions.setCell(arr.id, anchor, 'SOKO:STEP', ast.raw, true);
});
// Stephen's Sausage Roll (SSR) – minimal PoC
// Board movement in depth; avatar is 2×1 footprint aligned along facing
// SSR(boardMem, dir) where dir in {"left","right","forward","back"}
tag('SSR_STEP',['GAME','ACTION'],(anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('SSR_STEP requires an active transaction');
  const memRefArg = ast.args[0];
  // Robust direction parsing: handle identifiers, numbers, quoted strings, or missing arg
  let dirRaw;
  try{ dirRaw = Formula.valOf(ast.args[1]||''); }catch{ dirRaw=''; }
  let dir = String(dirRaw==null? '': dirRaw).trim().toLowerCase().replace(/^['"]|['"]$/g,'');
  if(dir==='0') dir='forward';
  else if(dir==='1') dir='back';
  else if(dir==='2') dir='left';
  else if(dir==='3') dir='right';
  // Fallback: infer direction from controller button position if arg missing/malformed
  if(!['forward','back','left','right'].includes(dir)){
    try{
      const cx = anchor.x, cy = anchor.y; // controller grid is 3x3 with center at (1,1)
      if(cx===1 && cy===2) dir='forward';
      else if(cx===1 && cy===0) dir='back';
      else if(cx===0 && cy===1) dir='left';
      else if(cx===2 && cy===1) dir='right';
    }catch{}
  }
  // Accept ref or absolute address string for memory pointer
  let memRef;
  if(memRefArg && memRefArg.kind==='ref'){
    memRef = memRefArg;
  } else {
    const addrStr = String(Formula.valOf(memRefArg)||'').trim();
    const parsed = parseAlt(addrStr);
    if(parsed){ memRef = {x:parsed.x,y:parsed.y,z:parsed.z,arrId:parsed.arrId, kind:'ref'}; }
  }
  if(!memRef) throw new Error('SSR_STEP needs memory ref');
  const memVal = Formula.getCellValue(memRef);
  const m = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]\|(\w+)$/i.exec(String(memVal||''));
  if(!m) return; // memory format: @[x,y,z,boardId]|FACING
  let x=+m[1], y=0, z=+m[3], boardId=+m[4]; let facing=String(m[5]||'north').toLowerCase();
  const board = Store.getState().arrays[boardId]; if(!board) return;
  const rotateLeft = f=> ({north:'west', west:'south', south:'east', east:'north'})[f];
  const rotateRight= f=> ({north:'east', east:'south', south:'west', west:'north'})[f];
  const dirVec = f=> ({north:{dx:0,dy:0,dz:-1}, east:{dx:1,dy:0,dz:0}, south:{dx:0,dy:0,dz:1}, west:{dx:-1,dy:0,dz:0}})[f] || {dx:0,dy:0,dz:-1};
  // Sausage registry lives on board.params.sausages: [{id, ax, az, bx, bz, orient:'x'|'z', side:'A'|'B'}]
  board.params = board.params||{}; board.params.sausages = board.params.sausages||[];
  const findSausAt=(qx,qz)=> board.params.sausages.find(s=> (s.ax===qx&&s.az===qz) || (s.bx===qx&&s.bz===qz));
  const occupy=(qx,qz)=> Formula.getCellValue({arrId:boardId,x:qx,y:0,z:qz})!=='';
  const drawBoard=()=>{
    // clear all then redraw sausages and avatar
    // lightweight: only update sausage cells
    board.params.sausages.forEach(s=>{
      Write.set(tx, boardId, {x:s.ax,y:0,z:s.az}, { value:'⚪', formula:null });
      Write.set(tx, boardId, {x:s.bx,y:0,z:s.bz}, { value:(s.side==='A'?'◉':'◎'), formula:null });
    });
  };
  if(dir==='left' || dir==='right'){
    // Tank-style rotation around the HEAD (player) cell.
    // Head stays fixed; tail moves to the orthogonal cell based on new facing.
    const newFacing = (dir==='left') ? rotateLeft(facing) : rotateRight(facing);
    const vnew = dirVec(newFacing);
    const ntx = x - vnew.dx, ntz = z - vnew.dz; // new tail position relative to head
    // bounds check for new tail
    if(ntx<0||ntx>=board.size.x||ntz<0||ntz>=board.size.z){ return; }
    // block rotation if target tail cell is occupied (simple rule)
    if(occupy(ntx,ntz)){
      const hit = findSausAt(ntx,ntz);
      // For now, do not push/roll on rotation; require free orthogonal cell
      if(hit){ return; }
      return;
    }
    facing = newFacing; // keep head at (x,z)
  }
  else if(dir==='forward' || dir==='back'){
    const v = dirVec(facing); const step = (dir==='forward'?1:-1);
    // Check interaction with sausages
    const nx=x+v.dx*step, nz=z+v.dz*step;
    const hit = findSausAt(nx,nz);
    if(hit){
      // Determine hit from side or short end
      const alongX = (hit.orient==='x');
      const sideHit = (alongX && v.dx===0) || (!alongX && v.dz===0);
      if(sideHit){
        // roll perpendicular by one cell and flip side
        const pdx = alongX? 0 : v.dx|| (step>0?1:-1); // if facing north/south roll in x
        const pdz = alongX? (v.dz|| (step>0?1:-1)) : 0;
        const tx1 = hit.ax+pdx, tz1 = hit.az+pdz;
        const tx2 = hit.bx+pdx, tz2 = hit.bz+pdz;
        if(tx1>=0&&tx1<board.size.x&&tz1>=0&&tz1<board.size.z&&tx2>=0&&tx2<board.size.x&&tz2>=0&&tz2<board.size.z && !occupy(tx1,tz1) && !occupy(tx2,tz2)){
          // apply roll
          Write.set(tx, boardId, {x:hit.ax,y:0,z:hit.az}, { value:'', formula:null });
          Write.set(tx, boardId, {x:hit.bx,y:0,z:hit.bz}, { value:'', formula:null });
          hit.ax=tx1; hit.az=tz1; hit.bx=tx2; hit.bz=tz2; hit.side = (hit.side==='A'?'B':'A');
          drawBoard();
        }
      } else {
        // push along its orientation (short-end push)
        const odx = alongX? (v.dx!==0? v.dx*step : (hit.bx>hit.ax?1:-1)) : 0;
        const odz = !alongX? (v.dz!==0? v.dz*step : (hit.bz>hit.az?1:-1)) : 0;
        const nx1=hit.ax+odx, nz1=hit.az+odz, nx2=hit.bx+odx, nz2=hit.bz+odz;
        if(nx1>=0&&nx1<board.size.x&&nz1>=0&&nz1<board.size.z&&nx2>=0&&nx2<board.size.x&&nz2>=0&&nz2<board.size.z && !occupy(nx1,nz1) && !occupy(nx2,nz2)){
          Write.set(tx, boardId, {x:hit.ax,y:0,z:hit.az}, { value:'', formula:null });
          Write.set(tx, boardId, {x:hit.bx,y:0,z:hit.bz}, { value:'', formula:null });
          hit.ax=nx1; hit.az=nz1; hit.bx=nx2; hit.bz=nz2;
          drawBoard();
        }
      }
      // avatar advances into previously occupied spot only if now clear
      if(!occupy(nx,nz)){ x=nx; z=nz; }
    } else {
      x = nx; z = nz;
    }
  }
  // Constrain to board
  x=Math.max(0,Math.min(board.size.x-1,x)); y=Math.max(0,Math.min(board.size.y-1,y)); z=Math.max(0,Math.min(board.size.z-1,z));
  // Clear previous avatar footprint (both head and tail regardless of turn or move)
  try{
    const old = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]/.exec(String(memVal))||[];
    const ox=+old[1], oy=+old[2], oz=+old[3];
    if(Number.isFinite(ox)){
      // Remove old head cell
      Write.set(tx, boardId, {x:ox,y:0,z:oz}, { value:'', formula:null });
      // Remove old tail cell; determine old facing from previous memory
      const mf = /^@\[(\d+),(\d+),(\d+),(\-?\d+)\]\|(\w+)$/i.exec(String(memVal||''));
      const prevF = mf ? String(mf[5]||'north').toLowerCase() : 'north';
      const pv = dirVec(prevF);
      Write.set(tx, boardId, {x:ox - pv.dx, y:0, z:oz - pv.dz}, { value:'', formula:null });
    }
  }catch{}
  // Draw 2×1 avatar: head at (x,y,z), tail one cell behind facing
  const v2 = dirVec(facing);
  Write.set(tx, boardId, {x:x,y:0,z:z}, { value:'🍴', formula:null });
  Write.set(tx, boardId, {x:x - v2.dx, y:0, z:z - v2.dz}, { value:'─', formula:null });
  // Update memory
  const newRef = `@[${x},${y},${z},${boardId}]|${facing}`;
  Write.set(tx, memRef.arrId, {x:memRef.x,y:memRef.y,z:memRef.z}, { value:newRef, formula:null });
  Actions.setCell(arr.id, anchor, `SSR:${facing}`, ast.raw, true);
});

tag('SSR',['GAME','META'],(anchor,arr,ast)=>{
  try{
    // Build a compact 3D board with depth emphasis
    const size = {x:8,y:1,z:8};
    const board = Actions.createArray({name:'SSR Board', size, hidden:false});
    const mem   = Actions.createArray({name:'SSR Mem', size:{x:2,y:1,z:1}, hidden:true});
    const ctrl  = Actions.createArray({name:'SSR Ctrl', size:{x:3,y:3,z:1}, hidden:false});
    Actions.begin();
    // Seed avatar at center facing north
    const start = {x:Math.floor(size.x/2), y:0, z:Math.floor(size.z/2)};
    Actions.setCell(board.id, start, '🙂', null, true);
    Actions.setCell(board.id, {x:start.x, y:start.y, z:start.z+1}, '─', null, true); // tail behind (south when facing north)
    Actions.setCell(mem.id, {x:0,y:0,z:0}, `@[${start.x},0,${start.z},${board.id}]|north`, null, true);
    // Place a demo sausage (2x1) horizontal, side A
    board.params = board.params||{}; board.params.sausages=[{id:1, ax:start.x+2, az:start.z, bx:start.x+3, bz:start.z, orient:'x', side:'A'}];
    // draw sausage
    Actions.setCell(board.id, {x:start.x+2,y:0,z:start.z}, '⚪', null, true);
    Actions.setCell(board.id, {x:start.x+3,y:0,z:start.z}, '◉', null, true);
    // Controller arrows (depth-oriented)
    Actions.setCell(ctrl.id,{x:1,y:2,z:0},'↑',null,true);
    Actions.setCell(ctrl.id,{x:0,y:1,z:0},'↺',null,true);
    Actions.setCell(ctrl.id,{x:1,y:1,z:0},'🎮',null,true);
    Actions.setCell(ctrl.id,{x:2,y:1,z:0},'↻',null,true);
    Actions.setCell(ctrl.id,{x:1,y:0,z:0},'↓',null,true);
    // Memory ref stored at [1,1,1] within mem array by convention
    const mref = `@[1,1,1,${mem.id}]`;
    // Bind ONCLICK actions directly so interactivity is immediate
    const bind = (x,y,dir)=>{
      const call = `=SSR_STEP(${mref},"${dir}")`;
      const enc = btoa(call);
      const txBind = Write.start('ssr.onclick','bind');
      const prev = Formula.getCell({arrId:ctrl.id,x,y,z:0});
      Write.set(txBind, ctrl.id, {x,y,z:0}, { value: prev?.value ?? (dir==='forward'?'↑':dir==='back'?'↓':dir==='left'?'↺':'↻'), formula: null, meta:{ ...(prev?.meta||{}), onClick:`B64:${enc}` } });
      Write.commit(txBind);
    };
    bind(1,2,'forward');
    bind(1,0,'back');
    bind(0,1,'left');
    bind(2,1,'right');
    // remove extra ONCLICK clones; handled in bind()
    Actions.end();
    // Smart docking relative to source array with 1-cell gap (right of source)
    (function smartDock(){
      const src = Store.getState().arrays[anchor.arrId] || arr;
      const gap = 1;
      const srcOff = src.offset||{x:0,y:0,z:0};
      // Align Z centers and Y centers; place board to the right of source with one cell gap
      const boardX = srcOff.x + (src.size.x + board.size.x)/2 + gap;
      const boardY = srcOff.y;
      const boardZ = srcOff.z;
      Scene.setArrayOffset(board,{x:boardX,y:boardY,z:boardZ});
      // Place controller to the right of board with the same gap, z-aligned
      const ctrlX = boardX + (board.size.x + ctrl.size.x)/2 + gap;
      Scene.setArrayOffset(ctrl,{x:ctrlX,y:boardY,z:boardZ});
    })();
    // Finalize: mark clickable now and force render/refresh without needing a reload
    try{
      Object.values(ctrl.chunks||{}).forEach(ch=> ch.cells.forEach(c=>{
        if(c.value){ c.meta = {...(c.meta||{}), onClick: c.meta?.onClick || ''}; }
      }));
    }catch{}
    Scene.renderArray(board); Scene.renderArray(ctrl);
    // Stamp anchor without triggering immediate recompute loop (prevents duplicate creation)
    const tx=Write.start('ssr.status','SSR status');
    Write.set(tx, arr.id, anchor, { value:`SSR:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
    Write.commit(tx);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
tag('SOKOBAN2',['GAME','META'],(anchor,arr,ast)=>{
  try{
    const size = {x:10,y:8,z:1};
    const board = Actions.createArray({name:'Sokoban2', size, hidden:false});
    const mem   = Actions.createArray({name:'SokoMem2', size:{x:2,y:1,z:1}, hidden:true});
    const rules = Actions.createArray({name:'SokoRules', size:{x:4,y:6,z:1}, hidden:true});
    const ctrl  = Actions.createArray({name:'SokoCtrl2', size:{x:3,y:3,z:1}, hidden:false});
    const PSTART = {x:2,y:2,z:0};
    const BOX='📦', WALL='█', PLAYER='🙂', GOAL='•';
    Actions.begin();
    // walls border
    for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
    for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
    // place player, box and goal
    Actions.setCell(board.id,PSTART,PLAYER,null,true);
    Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
    Actions.setCell(board.id,{x:7,y:2,z:0},GOAL,null,true);
    // memory: player ref string at (0,0)
    Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
    // Rules array params and MOVE rule (diegetic formulas)
    rules.params = { ...(rules.params||{}), sokoRules:true, boardId:board.id };
    const mvAnchor = {x:0,y:rules.size.y-1,z:0};
    rules.params.moveAnchor = {arrId:rules.id, ...mvAnchor};
    const memStr = `@[0,0,0,${mem.id}]`;
    // Compute current and next positions
    const curRef = `=OFFSET(${memStr},0,0,0)`;
    const dxRef = `=GET_GLOBAL("soko.dx")`;
    const dyRef = `=GET_GLOBAL("soko.dy")`;
    Actions.setCell(rules.id, {x:0,y:rules.size.y-1,z:0}, 'MOVE', `=DO(
      "=SET_GLOBAL(\"soko.pos\", ${curRef})",
      "=SET_GLOBAL(\"soko.next\", OFFSET(GET_GLOBAL(\\\"soko.pos\\\"), ${dxRef}, ${dyRef}, 0))",
      "=SET_GLOBAL(\"soko.nnext\", OFFSET(GET_GLOBAL(\\\"soko.pos\\\"), MUL(${dxRef},2), MUL(${dyRef},2), 0))",
      "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"█\"), \"BLOCK\", \"OK\")",
      "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"📦\"), IF(EQ(GET_GLOBAL(\"soko.nnext\"), \"\"), DO(\"=SET(GET_GLOBAL(\\\"soko.nnext\\\"), \"📦\")\", \"=SET(GET_GLOBAL(\\\"soko.next\\\"), \"🙂\")\", \"=SET(GET_GLOBAL(\\\"soko.pos\\\"), \"\" )\", \"=SET(${memStr}, GET_GLOBAL(\\\"soko.next\\\"))\"), \"BLOCK\"), \"OK\")",
      "=IF(EQ(GET_GLOBAL(\"soko.next\"), \"\"), DO(\"=SET(GET_GLOBAL(\\\"soko.next\\\"), \"🙂\")\", \"=SET(GET_GLOBAL(\\\"soko.pos\\\"), \"\" )\", \"=SET(${memStr}, GET_GLOBAL(\\\"soko.next\\\"))\"), \"OK\")"
    )`, true);
    // controller arrows using SOKO_STEP2(memRef,dx,dy)
    const mref = memStr;
    Actions.setCell(ctrl.id,{x:1,y:2,z:0},'↑',null,true);
    Actions.setCell(ctrl.id,{x:0,y:1,z:0},'←',null,true);
    Actions.setCell(ctrl.id,{x:2,y:1,z:0},'→',null,true);
    Actions.setCell(ctrl.id,{x:1,y:0,z:0},'↓',null,true);
    Actions.setCell(ctrl.id,{x:1,y:2,z:0}, '↑', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},0,1)")`, true);
    Actions.setCell(ctrl.id,{x:0,y:1,z:0}, '←', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},-1,0)")`, true);
    Actions.setCell(ctrl.id,{x:2,y:1,z:0}, '→', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},1,0)")`, true);
    Actions.setCell(ctrl.id,{x:1,y:0,z:0}, '↓', `=ON_SELECT(SELF(), "=SOKO_STEP2(${mref},0,-1)")`, true);
    Actions.end();
    // Dock controller near board
    const pos = dockOffsetFor(board,'east',1.0);
    Scene.setArrayOffset(ctrl,pos);
    Actions.setCell(arr.id, anchor, `Sokoban2:#${board.id}`, ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
tag('SOKOBAN',['GAME','META'],(anchor,arr,ast)=>{
  // Generate a tiny Sokoban board, memory, and controller
  try{
    const size = {x:10,y:8,z:1};
    const board = Actions.createArray({name:'Sokoban', size, hidden:false});
    const mem   = Actions.createArray({name:'SokoMem', size:{x:2,y:1,z:1}, hidden:true});
    const ctrl  = Actions.createArray({name:'SokoCtrl', size:{x:3,y:3,z:1}, hidden:false});
    const PSTART = {x:2,y:2,z:0};
    const BOX='📦', WALL='█', PLAYER='🙂', GOAL='•';
    Actions.begin();
    // walls border
    for(let x=0;x<size.x;x++){ Actions.setCell(board.id,{x,y:size.y-1,z:0},WALL,null,true); Actions.setCell(board.id,{x,y:0,z:0},WALL,null,true); }
    for(let y=0;y<size.y;y++){ Actions.setCell(board.id,{x:0,y,z:0},WALL,null,true); Actions.setCell(board.id,{x:size.x-1,y,z:0},WALL,null,true); }
    // place player, box and goal
    Actions.setCell(board.id,PSTART,PLAYER,null,true);
    Actions.setCell(board.id,{x:4,y:2,z:0},BOX,null,true);
    Actions.setCell(board.id,{x:7,y:2,z:0},GOAL,null,true);
    // memory: player ref string at (0,0)
    Actions.setCell(mem.id,{x:0,y:0,z:0},`@[${PSTART.x},${PSTART.y},${PSTART.z},${board.id}]`,null,true);
    // controller arrows with ON_SELECT to call SOKO_STEP(memRef,dx,dy)
    const mref = `@[0,0,0,${mem.id}]`;
    Actions.setCell(ctrl.id,{x:1,y:2,z:0},'↑',null,true);
    Actions.setCell(ctrl.id,{x:0,y:1,z:0},'←',null,true);
    Actions.setCell(ctrl.id,{x:2,y:1,z:0},'→',null,true);
    Actions.setCell(ctrl.id,{x:1,y:0,z:0},'↓',null,true);
    Actions.setCell(ctrl.id,{x:1,y:2,z:0}, '↑', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},0,1)")`, true);
    Actions.setCell(ctrl.id,{x:0,y:1,z:0}, '←', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},-1,0)")`, true);
    Actions.setCell(ctrl.id,{x:2,y:1,z:0}, '→', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},1,0)")`, true);
    Actions.setCell(ctrl.id,{x:1,y:0,z:0}, '↓', `=ON_SELECT(SELF(), "=SOKO_STEP(${mref},0,-1)")`, true);
    Actions.end();
    // Dock controller near board
    const pos = dockOffsetFor(board,'east',1.0);
    Scene.setArrayOffset(ctrl,pos);
    // Write to anchor without triggering immediate recompute loop
    const tx=Write.start('sokoban.status','SOKOBAN status');
    Write.set(tx, arr.id, anchor, { value:`Sokoban:#${board.id}`, formula: ast.raw, meta:{skip_recompute:true} });
    Write.commit(tx);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

tag('VIEW_MODE',['SCENE'],(anchor,arr,ast)=>{
  const mode=String(valOf(ast.args[0])||'3d').toLowerCase(); // '3d', '2d', 'ortho', 'isometric'
  const distance=+valOf(ast.args[1])||10; // camera distance
  Scene.setViewMode(arr,{mode,distance});
  Actions.setCell(arr.id,anchor,`View:${mode}/${distance}`,ast.raw,true);
});
tag('SANDBOX',['META'],(anchor,arr,ast)=>{
  if(Store.getState().arrays[2]){
    Actions.setCell(arr.id,anchor,'Sandbox:EXISTS',ast.raw,true);
    return;
  }
  const sb = Actions.createArray({id:2,name:'Sandbox', size:{x:12,y:8,z:12}, hidden:false});
  Actions.setCell(arr.id,anchor,`Sandbox:OK (#${sb.id})`,ast.raw,true);
  Scene.centerOnArray(sb);
});

// UI Control Functions
tag('UI_CONTROL',['META'],(anchor,arr,ast)=>{
  const controlType=String(valOf(ast.args[0])||'').toLowerCase(); // 'insert_buttons', 'function_drawer', etc.
  const state=!!valOf(ast.args[1]); // true/false
  arr.uiControls = arr.uiControls || {};
  arr.uiControls[controlType] = state;
  Actions.setCell(arr.id,anchor,`UI:${controlType}=${state}`,ast.raw,true);
});

// MINIMIZE(flag): 1 to minimize the 2D viewport, 0 to restore to previous position
tag('MINIMIZE',["ACTION"],(anchor,arr,ast)=>{
  try{
    const flag = !!Formula.valOf(ast.args[0]);
    const sheet = document.getElementById('sheet');
    if(!sheet){ Actions.setCell(arr.id,anchor,'!ERR:NO_SHEET',ast.raw,true); return; }
    if(flag){
      if(!sheet.dataset.prevTransform){
        sheet.dataset.prevLeft = sheet.style.left||'';
        sheet.dataset.prevTop = sheet.style.top||'';
        sheet.dataset.prevBottom = sheet.style.bottom||'';
        sheet.dataset.prevTransform = sheet.style.transform||'';
        sheet.dataset.prevOpacity = sheet.style.opacity||'';
        sheet.dataset.prevPointer = sheet.style.pointerEvents||'';
      }
      sheet.style.transform = (sheet.style.transform.includes('translateX(-50%)')? 'translateX(-50%)' : '') + ' translateY(12px) scale(0.92)';
      sheet.style.opacity='0.0';
      sheet.style.pointerEvents='none';
    } else {
      if(sheet.dataset.prevTransform!==undefined){
        sheet.style.left = sheet.dataset.prevLeft;
        sheet.style.top = sheet.dataset.prevTop;
        sheet.style.bottom = sheet.dataset.prevBottom;
        sheet.style.transform = sheet.dataset.prevTransform;
        sheet.style.opacity = sheet.dataset.prevOpacity;
        sheet.style.pointerEvents = sheet.dataset.prevPointer;
        delete sheet.dataset.prevLeft; delete sheet.dataset.prevTop; delete sheet.dataset.prevBottom;
        delete sheet.dataset.prevTransform; delete sheet.dataset.prevOpacity; delete sheet.dataset.prevPointer;
      } else {
        sheet.style.opacity='1'; sheet.style.pointerEvents='auto';
        if(sheet.style.transform.includes('translateX(-50%)')){ sheet.style.transform='translateX(-50%)'; } else { sheet.style.transform=''; }
      }
    }
    Actions.setCell(arr.id, anchor, `Minimize:${flag?1:0}`, ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});
// ON_SELECT: register a per-cell (or range) selection hook
// =ON_SELECT([rangeOrRef], actionFormulaString)
// The action must be a *string* and should start with '='.
tag('ON_SELECT',['META'],(anchor,arr,ast)=>{
  // Turn off hook for this anchor
  if(ast.args.length===1 && typeof ast.args[0]==='string'){
    const t=String(ast.args[0]||'').toLowerCase();
    if(t==='off'||t==='none'||t==='0'||t==='false'){
      arr.onSelectHooks = (arr.onSelectHooks||[]).filter(h=>!(h.anchor.x===anchor.x && h.anchor.y===anchor.y && h.anchor.z===anchor.z));
      Actions.setCell(arr.id, anchor, 'OnSelect:OFF', ast.raw, true);
      return;
    }
  }

  let rangeArg=null;
  // We DO NOT valOf() the action; we store it as a literal formula string.
  const rawAction = (ast.args.length>=2 ? ast.args[1] : ast.args[0]);
  let action = (typeof rawAction === 'string') ? rawAction : String(rawAction||'');
  if(action && action[0] !== '=') action = `=${action}`;  // normalize to formula string

  // Build cell set for matching
  const cells = new Set();
  if(ast.args.length>=2) rangeArg = ast.args[0];
  if(rangeArg && rangeArg.kind==='range'){
    rangeArg.cells.forEach(c=>cells.add(`${c.x},${c.y},${c.z}`));
  } else if(rangeArg && rangeArg.kind==='ref'){
    cells.add(`${rangeArg.x},${rangeArg.y},${rangeArg.z}`);
  } else {
    cells.add(`${anchor.x},${anchor.y},${anchor.z}`); // default self
  }

  arr.onSelectHooks = arr.onSelectHooks || [];
  // replace any existing hook at this anchor
  arr.onSelectHooks = arr.onSelectHooks.filter(h=>!(h.anchor.x===anchor.x && h.anchor.y===anchor.y && h.anchor.z===anchor.z));
  arr.onSelectHooks.push({ anchor:{x:anchor.x,y:anchor.y,z:anchor.z}, cells, action });

  // Silent registration; do not stamp the cell
});
tag('OVERLAP',['SCENE'],(anchor,arr,ast)=>{
  const targetArr=ast.args[0]; // array ref or ID
  const mode=String(valOf(ast.args[1])||'detect').toLowerCase(); // 'detect', 'count', 'list'
  // Placeholder: check if this array's cells overlap with target array's cells in 3D space
  const overlaps = 0; // TODO: implement actual overlap detection
  Actions.setCell(arr.id,anchor,`Overlap:${overlaps}`,ast.raw,true);
});
tag('EVALUATE',['META'],(anchor,arr,ast)=>{
  const condition=String(valOf(ast.args[0])); // formula to evaluate
  const result=!!valOf(ast.args[1]); // expected result
  // Simple condition evaluator for UI state control
  Actions.setCell(arr.id,anchor,result?'EVAL:TRUE':'EVAL:FALSE',ast.raw,true);
});

tag('IS_FOCUS_ARRAY',['PURE'],(anchor,arr,ast)=>{
  const targetId=ast.args[0] ? +valOf(ast.args[0]) : arr.id;
  const s=Store.getState().selection;
  const isFocused = s.arrayId === targetId;
  Actions.setCell(arr.id, anchor, isFocused?1:0, ast.raw, true);
});

// Diegetic UI Functions
// Note: A single TOAST(action) exists above (ACTION tag). Remove duplicate META variant to avoid override.
tag('AXES',['SCENE'],(anchor,arr,ast)=>{
  const m = String(Formula.valOf(ast.args[0] ?? '1')).toLowerCase();
  arr.axesVisible = (m==='1'||m==='true'||m==='on') ? true :
                    (m==='0'||m==='false'||m==='off') ? false : undefined; // "auto"
  Scene.syncVisibility(arr);
  Actions.setCell(arr.id, anchor, 
    `Axes:${arr.axesVisible===undefined?'AUTO':(arr.axesVisible?'ON':'OFF')}`,
    ast.raw, true
  );
});
tag('FOCUS_SET',['ACTION'],(anchor,arr,ast)=>{
  const s = Store.getState().selection;
  if(!s?.arrayId || !s.focus) throw new Error('No focus');
  
  // Support both old and new syntax: FOCUS_SET(content) or FOCUS_SET(mode, content)
  let mode = 'text', content = '';
  if(ast.args.length === 1){
    content = String(Formula.valOf(ast.args[0]||''));
    mode = content.startsWith('=') ? 'formula' : 'text';
  } else {
    mode = String(Formula.valOf(ast.args[0]||'text')).toLowerCase();
    content = String(Formula.valOf(ast.args[1]||''));
  }
  
  if(mode === 'clipboard'){
    // Copy content to clipboard
    try {
      navigator.clipboard.writeText(content);
      Actions.setCell(arr.id, anchor, `📋 Copied: ${content.slice(0,20)}`, ast.raw, true);
      showToast('Copied to clipboard');
    } catch(e) {
      Actions.setCell(arr.id, anchor, '📋 Copy failed', ast.raw, true);
      showToast('Copy failed');
    }
    return;
  }
  
  if(mode === 'formula' || content.startsWith('=')){
    Formula.setFormula({arrId:s.arrayId, ...s.focus}, content);
    Formula.executeAt({arrId:s.arrayId, ...s.focus});
  } else {
    Actions.setCell(s.arrayId, s.focus, content, null, true);
  }
  
  Actions.setCell(arr.id, anchor, 'OK', ast.raw, true);
});

// COPY(text): write text to clipboard (callable, composable)
tag('COPY',['IO','ACTION'],(anchor,arr,ast)=>{
  const text = String(Formula.valOf(ast.args[0]||''));
  try{
    navigator.clipboard.writeText(text);
    showToast('Copied to clipboard');
  }catch(e){
    showToast('Copy failed');
  }
});

// PREVIEW(inArray[, overworld]) — binary toggles for enabling animations
// inArray: 1/0 to show per-cell overlays and drive in-array timed plans
// overworld: 1/0 to enable global (3D) array movement
tag('PREVIEW',["SCENE"],(anchor,arr,ast)=>{
  try{
    const enableIn = !!Formula.valOf(ast.args[0]||0);
    const enable3D = !!Formula.valOf(ast.args[1]||0);
    let T = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(arr) : null;
    if(!T){
      try{
        arr.params = arr.params || {};
        arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null };
        T = arr.params.timed;
      }catch{}
    }
    if(T){
      // Build plan first, but always enable local preview; show placeholder if plan empty
      if(enableIn){
        try{ T.plan = []; }catch{}
        try{ Scene.buildTimedPlanFromArray?.(arr); }catch{}
        T.previewInArray = true;
        // Default looping animation if not configured by TIMED_TRANSLATION
        if(!(T.ticks>0)){ T.ticks = 120; }
        if(T.repeat==null) T.repeat = true;
        if(T.reverse==null) T.reverse = false;
        T.t = 0; T.dir = 1;
      } else {
        T.previewInArray = false;
      }
    }
    // The rest: overlay/mask handling unchanged
    if(enableIn && T){
      if(!T.overlay){
        T.overlay = { group:new THREE.Group(), cells:new Map() };
        try{ if(arr._frame){ arr._frame.add(T.overlay.group); } else { Scene.addToScene?.(T.overlay.group); } }catch{ try{ Scene.addToScene?.(T.overlay.group); }catch{} }
      }
      try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(arr, true); }catch{}
    } else if(T) {
      if(T.overlay){ try{ T.overlay.group.parent?.remove(T.overlay.group); }catch{ try{ Scene.removeFromScene?.(T.overlay.group); }catch{} } T.overlay=null; }
      try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(arr, false); }catch{}
    }
    const G = (typeof Scene!=='undefined' && Scene.ensureTimed3D) ? Scene.ensureTimed3D() : ((Store.getState().scene.timed3D=Store.getState().scene.timed3D||{configured:false,preview:false}), Store.getState().scene.timed3D);
    G.preview = enable3D;
    // If global preview is being disabled, immediately restore arrays to their captured base transforms
    if(!enable3D){
      try{
        const arrays = Object.values(Store.getState().arrays||{});
        arrays.forEach(a=>{
          try{
            const T = (typeof Scene!=='undefined' && Scene.ensureTimedState) ? Scene.ensureTimedState(a) : (a.params&&a.params.timed);
            if(T){
              // Restore base transforms if captured during preview
              if(T.baseOffset){ try{ Scene.setArrayOffset?.(a, {x:T.baseOffset.x,y:T.baseOffset.y,z:T.baseOffset.z}, {interactive:true}); }catch{} }
              if(a._frame && T.baseQuat){ try{ a._frame.quaternion.copy(T.baseQuat); }catch{} }
              T.t = 0; T.dir = 1;
              // Remove overlays and unmask content
              try{ if(T.overlay){ T.overlay.group.parent?.remove(T.overlay.group); T.overlay=null; } }catch{}
            }
            try{ if(typeof Scene!=='undefined' && Scene.maskArrayForPreview) Scene.maskArrayForPreview(a, false); }catch{}
          }catch{}
        });
        // Reset wait counter so next enable starts fresh
        try{ G._waitCounter = 0; }catch{}
      }catch{}
    }
    Actions.setCell(arr.id, anchor, `Preview:${enableIn?1:0}/${enable3D?1:0}`, ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?) — config only, no animation
tag('TIMED_TRANSLATION',["SCENE"],(anchor,arr,ast)=>{
  try{
    const ticks = (+Formula.valOf(ast.args[0]||60))|0;
    const repeat = !!Formula.valOf(ast.args[1]||0);
    const reverse = !!Formula.valOf(ast.args[2]||0);
    const reverseTicks = (ast.args[3]!==undefined) ? ((+Formula.valOf(ast.args[3])|0) || ticks) : null;
    const smooth = !!((+Formula.valOf(ast.args[4]||0))|0);
    const cfgFn = (typeof Scene!=='undefined' && Scene.configTimed) ? Scene.configTimed : (a,c)=>{ try{ /* fallback no-op */ }catch{} };
    cfgFn(arr, { ticks, repeat, reverse, reverseTicks, smooth });
    Actions.setCell(arr.id, anchor, `Timed:cfg(${ticks})`, ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// 3D_TIMED_TRANSLATION(ticks, repeat, reverse?, reverseTicks?) — global config
tag('3D_TIMED_TRANSLATION',["SCENE"],(anchor,arr,ast)=>{
  try{
    const ticks = (+Formula.valOf(ast.args[0]||60))|0;
    const repeat = !!Formula.valOf(ast.args[1]||0);
    const reverse = !!Formula.valOf(ast.args[2]||0);
    const reverseTicks = (ast.args[3]!==undefined) ? ((+Formula.valOf(ast.args[3])|0) || ticks) : null;
    const smooth = !!((+Formula.valOf(ast.args[4]||0))|0);
    // Robust ensure timed3D state
    let G = null;
    try{ if(typeof Scene!=='undefined' && Scene.ensureTimed3D) G = Scene.ensureTimed3D(); }catch{}
    if(!G){
      const S = Store.getState();
      const sceneState = S.scene || {};
      if(!sceneState.timed3D){ sceneState.timed3D = { configured:false, ticks:60, repeat:false, reverse:false, reverseTicks:null, t:0, dir:1, preview:false, smooth:false }; }
      Store.setState(s=>({ scene: { ...s.scene, timed3D: sceneState.timed3D } }));
      G = sceneState.timed3D;
    }
    G.configured = true; G.ticks=Math.max(1,ticks|0); G.repeat=repeat; G.reverse=reverse; G.reverseTicks=reverseTicks; G.t=0; G.dir=1; G.smooth = smooth;
    Actions.setCell(arr.id, anchor, `3D_Timed:cfg(${ticks})`, ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// OVERLAP(sortAscDesc, metric, mergeMode, alwaysExec)
// sortAscDesc: 0 asc, 1 desc (default 1)
// metric: 0 by value, 1 by array size (default 0)
// mergeMode: 0 then() wrap, 1 overwrite (default 1)
// alwaysExec: 0 only on combine, 1 on any overlap (default 0)
tag('OVERLAP',["ACTION"],(anchor,arr,ast,tx)=>{
  // Executed by InteractionManager with context in globalState.temp.overlap_target
  const S=Store.getState();
  const cfg={
    sort:(+Formula.valOf(ast.args[0])|0)||1,
    metric:(+Formula.valOf(ast.args[1])|0)||0,
    merge:(+Formula.valOf(ast.args[2])|0)||1,
    always:(+Formula.valOf(ast.args[3])|0)||0
  };
  const t=S.globalState.get('temp.overlap_target');
  if(!t) return;
  const own={ ref:anchor, arr:arr, cell: Formula.getCell(anchor) };
  const other={ ref:t, arr: S.arrays[t.arrId], cell: Formula.getCell(t) };
  let ownScore, otherScore;
  if(cfg.metric===1){
    ownScore = own.arr.size.x*own.arr.size.y*own.arr.size.z;
    otherScore = other.arr.size.x*other.arr.size.y*other.arr.size.z;
  } else {
    ownScore = parseFloat(own.cell.value)||0;
    otherScore = parseFloat(other.cell.value)||0;
  }
  let winner=own, loser=other;
  const cmp = cfg.sort===1 ? (ownScore>=otherScore) : (ownScore<=otherScore);
  if(!cmp){ winner=other; loser=own; }
  const ownsTx = !tx; if(ownsTx) tx=Write.start('overlap.resolve','OVERLAP');
  const esc=(s)=> String(s??'').replace(/"/g,'\\"');
  if(cfg.merge===0){ // then wrap
    const wC = winner.cell.formula || winner.cell.value; const lC = loser.cell.formula || loser.cell.value;
    const f=`=THEN("${esc(lC)}", "${esc(wC)}")`;
    Write.set(tx, winner.ref.arrId, {x:winner.ref.x,y:winner.ref.y,z:winner.ref.z}, { value:'', formula:f });
  } else {
    // overwrite with winner's existing content (no change)
    Write.set(tx, winner.ref.arrId, {x:winner.ref.x,y:winner.ref.y,z:winner.ref.z}, { value: winner.cell.value, formula: winner.cell.formula });
  }
  if(ownsTx) Write.commit(tx);
});

// THEN(refs...): sequentially executes refs/ranges and returns last result into anchor
tag('THEN',["ACTION"],(anchor,arr,ast,tx)=>{
  const ownsTx = !tx; if(ownsTx) tx = Write.start('then.sequence','THEN wrapper');
  let last='';
  const processRef=(ref)=>{
    const c = Formula.getCell(ref);
    const content = (c && c.formula) ? c.formula : (c ? c.value : '');
    if(String(content||'').startsWith('=')){
      Formula.runOnceAt(ref, content, tx);
      last = Formula.getCellValue(ref);
    } else { last = content; }
  };
  ast.args.forEach(a=>{
    if(a && a.kind==='ref') processRef(a);
    else if(a && a.kind==='range') a.cells.sort((a,b)=> a.y-b.y || a.x-b.x || a.z-b.z).forEach(processRef);
    else last = Formula.valOf(a);
  });
  Write.set(tx, arr.id, anchor, { value: last, formula: ast.raw });
  if(ownsTx) Write.commit(tx);
});

// HUSK(range): copy values, delete source array, leave remnants at anchor block
tag('HUSK',["ACTION","BLOCK"],(anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('HUSK requires an active transaction');
  const src=ast.args[0]; if(!src||src.kind!=='range') throw new Error('HUSK requires a range');
  const aid=src.cells[0].arrId; if(aid===arr.id) throw new Error('HUSK source must differ');
  const xs=[...new Set(src.cells.map(c=>c.x))].sort((a,b)=>a-b);
  const ys=[...new Set(src.cells.map(c=>c.y))].sort((a,b)=>a-b);
  const zs=[...new Set(src.cells.map(c=>c.z))].sort((a,b)=>a-b);
  const minX=xs[0], minY=ys[0], minZ=zs[0];
  const ak=aKey(anchor);
  zs.forEach(z=> ys.forEach(y=> xs.forEach(x=>{
    const v=Formula.getCellValue({arrId:aid,x,y,z});
    const dx=x-minX, dy=y-minY, dz=z-minZ;
    const tgt={x:anchor.x+dx,y:anchor.y+dy,z:anchor.z+dz};
    const isAnchor=(dx===0&&dy===0&&dz===0);
    Write.set(tx, arr.id, tgt, { value: v, formula: isAnchor? ast.raw : null, meta:{generated:true, emitter:ak} });
  })));
  setTimeout(()=>{ try{ Actions.deleteArray(aid); }catch{} }, 50);
});

// DO(f1[, f2[, ...]]): sequence multiple sub-formulas in order, return last
// Each arg should be a string formula (like "=SET(...)").
tag('DO',['ACTION'],(anchor,arr,ast,tx)=>{
  const ownsTx = !tx;
  if(ownsTx) tx = Write.start('do.sequence','DO wrapper');
  for(const a of ast.args){
    const f = String(Formula.valOf(a)||'');
    if(f && f[0] === '='){
      Formula.executeAt(anchor, f, tx);
  }
  }
  if(ownsTx) Write.commit(tx);
  // silent: do not stamp the cell
});

// EXEC_AT(x, y, z, arrId, formulaText) or EXEC_AT(ref, formulaText)
// Executes the provided formula text at the target anchor without stamping current cell
tag('EXEC_AT',["ACTION"],(anchor,arr,ast,tx)=>{
  if(!tx) throw new Error('EXEC_AT requires an active transaction (use inside DO)');
  const a0 = ast.args[0];
  const a1 = ast.args[1];
  let target=null, formula='';
  if(a1===undefined){
    throw new Error('EXEC_AT needs target and formula');
  }
  // Form 1: EXEC_AT(ref, formula)
  if(a0 && a0.kind==='ref'){
    target = {arrId:a0.arrId, x:a0.x, y:a0.y, z:a0.z};
    formula = String(Formula.valOf(a1)||'');
  } else if(ast.args.length>=5){
    // Form 2: EXEC_AT(x, y, z, arrIdExpr, formula)
    const x=(+Formula.valOf(ast.args[0])|0), y=(+Formula.valOf(ast.args[1])|0), z=(+Formula.valOf(ast.args[2])|0);
    const id = (+Formula.valOf(ast.args[3])|0);
    if(!Store.getState().arrays[id]) throw new Error('EXEC_AT: target array not found');
    target = {arrId:id, x, y, z};
    formula = String(Formula.valOf(ast.args[4])||'');
  } else if(typeof a0==='string' || typeof a0==='number'){
    // Allow dynamic absolute string like "@[x,y,z,id]"
    const parsed = parseAlt(String(Formula.valOf(a0)));
    if(!parsed) throw new Error('EXEC_AT: invalid target');
    target = {arrId:parsed.arrId, x:parsed.x, y:parsed.y, z:parsed.z};
    formula = String(Formula.valOf(a1)||'');
  } else {
    throw new Error('EXEC_AT: invalid arguments');
  }
  if(!formula || formula[0] !== '=') formula = `=${formula}`;
  Formula.executeAt(target, formula, tx);
});

// DELETE(...targets) — delete arrays by id or ref; default self
tag('DELETE',["ACTION"], (anchor,arr,ast)=>{
  try{
    const toArrId = (a)=>{
      if(a && a.kind==='ref') return a.arrId ?? arr.id;
      const v = Formula.valOf(a);
      if(v===undefined || v===null || v==='') return null;
      if(typeof v === 'string'){
        const lower = v.trim().toLowerCase();
        if(lower === 'self') return arr.id;
        // Accept A1-style without array id by defaulting to host
        const parsed = parseAlt(v) || parseA1g(v, arr.id);
        if(parsed) return parsed.arrId;
        const n = +v; if(Number.isFinite(n)) return Math.trunc(n);
        return null;
      }
      const n = +v; if(Number.isFinite(n)) return Math.trunc(n);
      return null;
    };

    let targets = ast.args.length ? ast.args.map(toArrId).filter(id=>id!=null) : [arr.id];
    // Unique and skip reserved (0, -1)
    targets = [...new Set(targets)].filter(id => id!=null && id !== 0 && id !== -1);

    if(targets.length === 0){
      Actions.setCell(arr.id, anchor, '!ERR:DELETE:NoTarget', ast.raw, true);
      return;
    }

    let ok = 0;
    targets.forEach(id=>{
      try{
        const A = Store.getState().arrays[id];
        if(A){ try{ Scene.startDatafallDelete?.(A); }catch{} }
        ok++;
      }catch{}
    });

    Actions.setCell(arr.id, anchor, `Deleted:${ok}`, ast.raw, true);
  }catch(e){
    Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
  }
});

// Short aliases
tag('DEL',["ACTION"], (anchor,arr,ast)=> Fn['DELETE'].impl(anchor,arr,ast));
tag('REMOVE',["ACTION"], (anchor,arr,ast)=> Fn['DELETE'].impl(anchor,arr,ast));

// CONNECT(ref1, ref2) => creates a visual line that acts as a zipline
tag('CONNECT',['SCENE', 'ACTION'],(anchor,arr,ast)=>{
  const ref1 = ast.args[0];
  const ref2 = ast.args[1];

  // Validate inputs
  if(!ref1 || ref1.kind !== 'ref' || !ref2 || ref2.kind !== 'ref'){
    Actions.setCell(arr.id, anchor, '!ERR:Requires 2 cell refs', ast.raw, true);
    Scene.removeConnection(anchor); // Clean up any old line
    return;
  }

  // Pass to the Scene module to handle rendering and physics state
  Scene.addConnection(anchor, ref1, ref2);
  Actions.setCell(arr.id, anchor, '🔗 Connected', ast.raw, true);
});

// GOAL(conditionRef) => register a goal condition
tag('GOAL',['META'],(anchor,arr,ast)=>{
  const conditionRef = ast.args[0];
  if(!conditionRef || conditionRef.kind !== 'ref') {
    Actions.setCell(arr.id, anchor, '!ERR:Requires condition ref', ast.raw, true);
    return;
  }
  
  const S = Store.getState();
  const goalKey = aKey(anchor);
  S.gameState.goals.set(goalKey, conditionRef);
  Actions.setCell(arr.id, anchor, '🎯 Goal Set', ast.raw, true);
});
// ONWIN(actionFormula) => register callback for when all goals are met
tag('ONWIN',['META'],(anchor,arr,ast)=>{
  const actionFormula = String(valOf(ast.args[0] || '')) || '';
  if(!actionFormula) {
    Actions.setCell(arr.id, anchor, '!ERR:Requires action formula', ast.raw, true);
    return;
  }
  
  const S = Store.getState();
  S.gameState.winCallbacks.push({
    anchor: {...anchor},
    callback: actionFormula
  });
  Actions.setCell(arr.id, anchor, '🏆 Win Handler Set', ast.raw, true);
});

function listAllowedFunctionsFor(arr){
  const names = Object.keys(Fn);
  const pol = arr.fnPolicy || {mode:'ALLOW_ALL', allow:new Set(), deny:new Set(), tags:new Set()};
  const has = (set, n)=> set && (set.has?.(n) || set.has?.(n.toUpperCase?.()||n));
  const matchesTags = (n)=> {
    if(!pol.tags || !pol.tags.size) return true;
    const tags = Fn[n]?.tags || new Set();
    for(const t of pol.tags) if(tags.has(t)) return true;
    return false;
  };

  let allowed = [];
  if(pol.mode==='ALLOW_ONLY'){
    const base = names.filter(n => has(pol.allow,n) || ALWAYS.has(n));
    allowed = base.filter(matchesTags);
  } else {
    allowed = names.filter(n => !has(pol.deny,n) || ALWAYS.has(n)).filter(matchesTags);
  }
  return [...new Set(allowed)].sort();
}
tag('FUNCTION_UI',['META'],(anchor,arr,ast)=>{
  // Batch to coalesce all writes into a single transaction
  Actions.begin();
  const port = String(Formula.valOf(ast.args[0] ?? 'east')).toLowerCase();
  const filterSub = String(Formula.valOf(ast.args[1] ?? '')||'').toLowerCase();
  const page = Math.max(0, (+Formula.valOf(ast.args[2] ?? 0)|0));
  const perPage = Math.max(5, (+Formula.valOf(ast.args[3] ?? 12)|0));

  const host = Store.getState().arrays[anchor.arrId];
  // Idempotence guard: reuse an existing Function Browser mount if present
  const existingMount = (host._uiMounts||[]).find(m=>m.name==='Function Browser');
  if(existingMount && Store.getState().arrays[existingMount.id]){
    const ui=Store.getState().arrays[existingMount.id];
    ui.hidden=false; Scene.syncVisibility(ui);
    const p = dockOffsetFor(host, port, 1.0);
    Scene.setArrayOffset(ui, p);
    Actions.end();
    return;
  }
  const full = listAllowedFunctionsFor(host);
  const list = filterSub ? full.filter(n=>n.toLowerCase().includes(filterSub)) : full;

  // Group functions by category for collapsible interface
  const categories = {};
  const categoryInfo = {
    'GLOBAL': {icon: '🌐', name: 'Global State'},
    'EVENTS': {icon: '⚡', name: 'Events'},
    'GAMES': {icon: '🎮', name: 'Games'},
    'DATA': {icon: '📊', name: 'Data'},
    'LOGIC': {icon: '🔀', name: 'Logic'},
    'MATH': {icon: '🔢', name: 'Math'},
    'NAVIGATION': {icon: '🧭', name: 'Nav'},
    'INTERACTION': {icon: '👆', name: 'Input'},
    'SCENE': {icon: '🎬', name: 'Scene'},
    'IO': {icon: '💾', name: 'I/O'},
    'ADVANCED': {icon: '⚙️', name: 'Advanced'}
  };
  
  list.forEach(name => {
    const tags = [...(Fn[name]?.tags || [])];
    let category = 'OTHER';
    if(tags.includes('GLOBAL')) category = 'GLOBAL';
    else if(tags.includes('EVENT') || name.includes('EVENT')) category = 'EVENTS';
    else if(tags.includes('GAME') || name.includes('FISH') || name.includes('GALAXY')) category = 'GAMES';
    else if(tags.includes('PURE') && (name.includes('ARRAY') || name.includes('GET') || name.includes('SET') || name.includes('BLIT'))) category = 'DATA';
    else if(tags.includes('LOGIC') || name.includes('IF') || name.includes('AND') || name.includes('OR')) category = 'LOGIC';
    else if(tags.includes('MATH') || name.includes('ADD') || name.includes('MUL') || name.includes('CLAMP')) category = 'MATH';
    else if(name.includes('ADDRESS') || name.includes('SELF') || name.includes('OFFSET') || name.includes('SELECT')) category = 'NAVIGATION';
    else if(name.includes('ON_SELECT') || name.includes('SELECTED') || name.includes('TARGET')) category = 'INTERACTION';
    else if(tags.includes('SCENE') || name.includes('PHYSICS') || name.includes('HIGHLIGHT')) category = 'SCENE';
    else if(tags.includes('IO') || name.includes('COPY') || name.includes('EXPORT') || name.includes('IMPORT')) category = 'IO';
    else if(name.includes('VECTOR') || name.includes('FORMULA') || name.includes('PRIORITY')) category = 'ADVANCED';
    
    if(!categories[category]) categories[category] = [];
    categories[category].push(name);
  });

  // Calculate total rows needed: category headers + functions + some padding
  const categoryCount = Object.keys(categories).length;
  const functionCount = list.length;
  const totalRows = categoryCount * 2 + functionCount + 3; // headers + functions + padding
  
  const cols = 4;
  const ui = Actions.createArray({name:'Function Browser', size:{x:cols,y:totalRows, z:1}, hidden:false});

  let currentY = ui.size.y - 1;
  
  // Create collapsible category structure with ON_SELECT chains
  Object.entries(categories).forEach(([catName, funcs]) => {
    const info = categoryInfo[catName] || {icon: '📁', name: catName};
    
    // Store previous functions below using temporary storage approach
    const tempStorageY = currentY - funcs.length - 10; // Store below visible area
    
    // Category header with collapse/expand functionality  
    Actions.setCell(ui.id, {x:0,y:currentY,z:0}, info.icon, null, true);
    Actions.setCell(ui.id, {x:1,y:currentY,z:0}, info.name, null, true);
    Actions.setCell(ui.id, {x:2,y:currentY,z:0}, `${funcs.length} functions`, null, true);
    
    // Expand/Collapse toggle with sophisticated temporary array manipulation  
    const collapseState = `collapse_${catName}_${ui.id}`;
    const toggle = `=ON_SELECT(SELF(), DO(
      "=SET_GLOBAL(\\\"${collapseState}\\\", IF(GET_GLOBAL(\\\"${collapseState}\\\"), 0, 1))",
      "=IF(GET_GLOBAL(\\\"${collapseState}\\\"), ARRAY(\\\"set\\\", ${funcs.map(f => `\\\\\"${f}\\\\\"`).join(',')}), ARRAY(\\\"set\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\", \\\"\\\\\\\\\\\\\\\") )"
    ))`;
    
    Actions.setCell(ui.id, {x:3,y:currentY,z:0}, '▼', toggle, true);
    
    currentY--;
    
    // Function rows (initially collapsed)
    funcs.forEach((name, i) => {
      const y = currentY - i;
    const tags = [...(Fn[name]?.tags || [])].join(',');
      
      // Function name with insert action
    Actions.setCell(ui.id, {x:1,y,z:0}, name, null, true);
      Actions.setCell(ui.id, {x:2,y,z:0}, tags.slice(0,15), null, true);
      
      // Copy button
    const call = `=${name}()`;
      const copyAction = `=ON_SELECT(SELF(), DO("=COPY(\\\"${call}\\\")", "=TOAST(\\\"Copied ${name}()\\\")"))`;
      Actions.setCell(ui.id, {x:0,y,z:0}, '📋', copyAction, true);
      
      // Insert button that writes to focus
      const insertAction = `=ON_SELECT(SELF(), DO("=FOCUS_SET(\\\"formula\\\",\\\"${call}\\\")", "=TOAST(\\\"Inserted ${name}()\\\")"))`;
      Actions.setCell(ui.id, {x:3,y,z:0}, '▶', insertAction, true);
    });
    
    currentY -= funcs.length + 1; // Space between categories
  });
  // Force complete re-render after all cells are written (batched)
  console.log(`FUNCTION_UI: forcing render for array #${ui.id} with ${categoryCount} categories`);
  ui._layersRendered = false;
  Scene.renderArray(ui);
  
  // Then position it
  const p = dockOffsetFor(host, port, 1.0);
  Scene.setArrayOffset(ui, p);

  host._uiMounts = host._uiMounts || [];
  host._uiMounts.push({id:ui.id, name:'Function Browser', port});

  // Silent registration: do not stamp anchor to avoid re-evaluation loops
  Actions.end();
});
tag('INVENTORY',['META'],(anchor,arr,ast)=>{
  Actions.begin();
  const port = String(Formula.valOf(ast.args[0] ?? 'north')).toLowerCase();
  const title = String(Formula.valOf(ast.args[1] ?? 'Inventory'));

  const host = Store.getState().arrays[anchor.arrId];
  // Idempotence guard: reuse existing inventory mount
  const existing = (host._uiMounts||[]).find(m=>m.name==='Inventory');
  if(existing && Store.getState().arrays[existing.id]){
    const inv = Store.getState().arrays[existing.id];
    inv.hidden=false; Scene.syncVisibility(inv);
    const p = dockOffsetFor(host, port, 1.0);
    Scene.setArrayOffset(inv, p);
    Actions.end();
    return;
  }
  const rows = 6;
  const inv = Actions.createArray({name:title, size:{x:5, y:rows, z:1}, hidden:false});

  // Use Actions.setCell for immediate visibility like FUNCTION_UI
  const YT = inv.size.y-1;
  Actions.setCell(inv.id, {x:0,y:YT,z:0}, title, null, true);
  Actions.setCell(inv.id, {x:1,y:YT,z:0}, 'Item', null, true);
  Actions.setCell(inv.id, {x:2,y:YT,z:0}, 'Qty', null, true);
  Actions.setCell(inv.id, {x:3,y:YT,z:0}, '+1', null, true);
  Actions.setCell(inv.id, {x:4,y:YT,z:0}, '-1', null, true);

  const example = ['Iron','Water','Wood','Gears'];
  for(let i=0;i<example.length && i<rows-1;i++){
    const y = YT-1-i;
    const name = example[i];
    Actions.setCell(inv.id, {x:1,y,z:0}, name, null, true);
    Actions.setCell(inv.id, {x:2,y,z:0}, 0, null, true);

    // Working +/- buttons using ON_SELECT with SET to keep label stable
    const qtyRef = `@[2,${y},0,${inv.id}]`;
    const plus  = `=ON_SELECT(SELF(), "=DO(\\"=SET(${qtyRef}, ADD(OFFSET(${qtyRef},0,0,0),1))\\", \\"=DISPLAY_AS(\\"+\\", SELF())\\")")`;
    const minus = `=ON_SELECT(SELF(), "=DO(\\"=SET(${qtyRef}, CLAMP(ADD(OFFSET(${qtyRef},0,0,0),-1),0,999))\\", \\"=DISPLAY_AS(\\"-\\", SELF())\\")")`;
    Actions.setCell(inv.id, {x:3,y,z:0}, '+', plus, true);
    Actions.setCell(inv.id, {x:4,y,z:0}, '-', minus, true);

    // Enhanced use button with clipboard option
    const useIt = `=FOCUS_SET("text","${name}")`;
    const copyIt = `=FOCUS_SET("clipboard","${name}")`;
    Actions.setCell(inv.id, {x:0,y,z:0}, '▶', useIt, true);
  }

  // Force complete re-render after all cells are written (batched)
  console.log(`INVENTORY: forcing render for array #${inv.id}`);
  inv._layersRendered = false;
  Scene.renderArray(inv);
  
  // Then position it
  const p = dockOffsetFor(host, port, 1.0);
  Scene.setArrayOffset(inv, p);
  
  // Focus the inventory so it's selectable
  Actions.setSelection(inv.id, {x:1, y:YT-1, z:0}, null, '3d');

  host._uiMounts = host._uiMounts || [];
  host._uiMounts.push({id:inv.id, name:'Inventory', port});

  // Silent registration: do not stamp anchor to avoid re-evaluation loops
  Actions.end();
});
tag('UI_UNMOUNT',['META'],(anchor,arr,ast)=>{
  const host = Store.getState().arrays[anchor.arrId];
  const key = String(Formula.valOf(ast.args[0] ?? '')).toLowerCase();
  if(!host?._uiMounts?.length){ 
    Actions.setCell(arr.id, anchor, 'UI:None', ast.raw, true); 
    return; 
  }
  const matches = (m)=> !key || (String(m.id)===key || String(m.name||'').toLowerCase().includes(key));
  const toHide = host._uiMounts.filter(matches);
  toHide.forEach(m=>{
    const a = Store.getState().arrays[m.id];
    if(a){ a.hidden = true; Scene.syncVisibility(a); }
  });
  host._uiMounts = host._uiMounts.filter(m=>!matches(m));
  Actions.setCell(arr.id, anchor, `UI:Unmounted ${toHide.length}`, ast.raw, true);
});
// 2D Platformer System
tag('SET_SELECTED',['ACTION'],(anchor,arr,ast)=>{
  const direction = String(Formula.valOf(ast.args[0]||'none')).toLowerCase();
  const s = Store.getState().selection;
  if(!s?.arrayId || !s.focus) throw new Error('No focus for movement');
  
  const currentArr = Store.getState().arrays[s.arrayId];
  if(!currentArr) throw new Error('Current array not found');
  
  // Calculate offset based on direction from joystick
  let dx=0, dy=0, dz=0;
  if(direction==='up') dy=1;
  else if(direction==='down') dy=-1;
  else if(direction==='left') dx=-1;
  else if(direction==='right') dx=1;
  else if(direction==='forward') dz=-1;
  else if(direction==='back') dz=1;
  
  // Get target screen array (look for array with 'screen' in name or use next array)
  const screenArr = Object.values(Store.getState().arrays).find(a => 
    a.name.toLowerCase().includes('screen') || a.params?.isScreen
  );
  
  if(screenArr){
    // Find current avatar position (cell with "Hero" or similar)
    let avatarPos = null;
    Object.values(screenArr.chunks).forEach(ch => {
      ch.cells.forEach(c => {
        if(c.value === 'Hero' || c.value === '🦸' || c.value === '@'){
          avatarPos = {x:c.x, y:c.y, z:c.z};
        }
      });
    });
    
    if(avatarPos){
      const newPos = {x:avatarPos.x+dx, y:avatarPos.y+dy, z:avatarPos.z+dz};
      // Check bounds
      if(newPos.x>=0 && newPos.x<screenArr.size.x && newPos.y>=0 && newPos.y<screenArr.size.y && newPos.z>=0 && newPos.z<screenArr.size.z){
        // Clear old position
        Actions.setCell(screenArr.id, avatarPos, '', null, true);
        // Set new position
        Actions.setCell(screenArr.id, newPos, 'Hero', null, true);
        // Focus the new position
        Actions.setSelection(screenArr.id, newPos, null, '3d');
      }
    }
  }
  
  Actions.setCell(arr.id, anchor, `Move:${direction}`, ast.raw, true);
});

// SET_SELECT(ref): force jump to selection
tag('SET_SELECT',['ACTION'],(anchor,arr,ast)=>{
  const t=ast.args[0];
  if(!t || t.kind!=='ref') throw new Error('SET_SELECT needs a ref');
  Actions.setSelection(t.arrId,{x:t.x,y:t.y,z:t.z},null,'3d');
  Actions.setCell(arr.id, anchor, `Select:${A1(t.x)}${t.y+1}${greek(t.z)}`, ast.raw, true);
});
tag('LIGHT',['SCENE'],(anchor,arr,ast)=>{
  const toBool = (v)=>{
    if(v == null) return false;
    if(typeof v === 'boolean') return v;
    if(typeof v === 'number') return v !== 0;
    const s = String(v).trim().toLowerCase();
    if(!s) return false;
    return !['0','false','off','no'].includes(s);
  };
  try{
    const stateVal = Formula.valOf(ast.args[0]);
    const enabled = toBool(stateVal);
    const targetRef = (ast.args[1] && ast.args[1].kind==='ref') ? ast.args[1] : null;
    const lumensRaw = ast.args[2] ? Formula.valOf(ast.args[2]) : null;
    let lumens = (lumensRaw==null || lumensRaw==='') ? 800 : parseFloat(lumensRaw);
    if(!Number.isFinite(lumens)) lumens = 800;
    lumens = Math.max(0, lumens);
    const source = { arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z };
    if(!enabled || lumens<=0){
      try{ Scene.removeCellLight?.(source); }catch{}
      Actions.setCell(arr.id, anchor, 'LIGHT:OFF', ast.raw, true);
      return;
    }
    const cell = Formula.getCell({arrId:arr.id, x:anchor.x, y:anchor.y, z:anchor.z}) || {};
    const color = cell?.meta?.color || '#ffffff';
    try{
      Scene.upsertCellLight?.(source, {
        enabled:true,
        mode: targetRef ? 'spot' : 'point',
        targetRef,
        lumens,
        color
      });
    }catch(e){ console.warn('LIGHT() upsert failed', e); }
    Actions.setCell(arr.id, anchor, targetRef ? 'LIGHT:SPOT' : 'LIGHT:POINT', ast.raw, true);
  }catch(e){
    console.warn('LIGHT() failed', e);
    Actions.setCell(arr.id, anchor, `!ERR:${e.message||'LIGHT'}`, ast.raw, true);
  }
});
tag('CHIME',['AUDIO'],(anchor,arr,ast)=>{
  try{
    const noteVal = Formula.valOf(ast.args[0]);
    const parsed = ChimeSystem.parseNote(noteVal);
    if(!parsed){ Actions.setCell(arr.id, anchor, '!ERR:NOTE', ast.raw, true); return; }
    const octVal = ast.args[1] ? Formula.valOf(ast.args[1]) : null;
    const octave = ChimeSystem.toOctave(octVal);
    const durVal = ast.args[2] ? Number(Formula.valOf(ast.args[2])) : null;
    const duration = Number.isFinite(durVal) && durVal>0 ? durVal : 0.65;
    try{ ChimeSystem.play(parsed.offset, octave, duration); }catch(e){ console.warn('Chime playback error', e); }
    Actions.setCell(arr.id, anchor, `CHIME:${parsed.label}${octave}`, ast.raw, true);
  }catch(e){
    console.warn('CHIME() failed', e);
    Actions.setCell(arr.id, anchor, '!ERR:CHIME', ast.raw, true);
  }
});
tag('2D_PLATFORMER',['META'],(anchor,arr,ast)=>{
  console.log('2D_PLATFORMER: Starting execution...', anchor, arr.id);
  try {
    const port = String(Formula.valOf(ast.args[0] ?? 'east')).toLowerCase();
    const screenSize = {x:12, y:8, z:1}; // 2D screen dimensions
    
    const host = Store.getState().arrays[anchor.arrId];
    console.log(`2D_PLATFORMER: Host array #${host.id}`);
    
    // Create controller array (3x3 directional pad)
    const controller = Actions.createArray({name:'Controller', size:{x:3, y:3, z:1}, hidden:false});
    console.log(`2D_PLATFORMER: Created controller #${controller.id}`);

    // Stash init params on controller so chained init knows where to dock and host id
    controller.params = {
      ...(controller.params||{}),
      platformer: true,
      hostId: host.id,
      port,
      screenSize
    };
    
    // Set up controller layout with ON_SELECT hooks
    Actions.setCell(controller.id, {x:1,y:2,z:0}, '↑', null, true);
    Actions.setCell(controller.id, {x:0,y:1,z:0}, '←', null, true);
    // Center joystick doubles as locked init cell that spawns the screen (once, idempotent)
    Actions.setCell(controller.id, {x:1,y:1,z:0}, '🎮', null, true);
    Actions.setCell(controller.id, {x:2,y:1,z:0}, '→', null, true);
    Actions.setCell(controller.id, {x:1,y:0,z:0}, '↓', null, true);

    // Register ON_SELECT for each control cell
    Formula.executeAt({arrId:controller.id,x:1,y:2,z:0}, '=ON_SELECT("=SET_SELECTED(\"up\")")');
    Formula.executeAt({arrId:controller.id,x:0,y:1,z:0}, '=ON_SELECT("=SET_SELECTED(\"left\")")');
    Formula.executeAt({arrId:controller.id,x:2,y:1,z:0}, '=ON_SELECT("=SET_SELECTED(\"right\")")');
    Formula.executeAt({arrId:controller.id,x:1,y:0,z:0}, '=ON_SELECT("=SET_SELECTED(\"down\")")');
    Formula.executeAt({arrId:controller.id,x:1,y:1,z:0}, `=PLATFORMER_SPAWN_SCREEN()`);
    
    // Add some action buttons
    Actions.setCell(controller.id, {x:2,y:2,z:0}, 'A', '=FOCUS_SET("text","Action!")', true);
    Actions.setCell(controller.id, {x:0,y:0,z:0}, 'B', '=FOCUS_SET("text","Jump!")', true);

    // Lock the center cell so it can't be edited away
    controller.locks = controller.locks || new Set();
    controller.locks.add(`${controller.id}:1,1,0`);

    // Trigger chained init now so the screen is created immediately
    try { Formula.executeAt({arrId:controller.id, x:1, y:1, z:0}); } catch(e) { console.warn('Init cell eval failed', e); }

    // Force render controller only (screen will be spawned by the chained formula)
    controller._layersRendered = false;
    Scene.renderArray(controller);

    // Position controller relative to host
    const controllerPos = dockOffsetFor(host, port, 1.5);
    Scene.setArrayOffset(controller, controllerPos);

    // Remember mount
    host._uiMounts = host._uiMounts || [];
    host._uiMounts.push({id:controller.id, name:'Controller', port});

    // Focus the controller center by default
    Actions.setSelection(controller.id, {x:1,y:1,z:0}, null, '3d');

    Actions.setCell(arr.id, anchor, `2D Platformer: Controller #${controller.id}`, ast.raw, true);
    console.log('2D_PLATFORMER: Controller created and init cell armed.');
  } catch(e) {
    console.error('2D_PLATFORMER: Error during execution:', e);
    Actions.setCell(arr.id, anchor, `!ERR: ${e.message}`, ast.raw, true);
  }
});
// Add lowercase alias for easier typing
tag('2d_platformer',['META'],(anchor,arr,ast)=>{
  console.log('2d_platformer: Redirecting to 2D_PLATFORMER...');
  return Fn['2D_PLATFORMER'].impl(anchor,arr,ast);
});
// Chained initializer: runs inside the controller's locked cell to spawn the screen idempotently
tag('PLATFORMER_SPAWN_SCREEN',['META'],(anchor,arr,ast)=>{
  try{
    const ctrl = Store.getState().arrays[anchor.arrId];
    const p = ctrl?.params?.platformer ? ctrl.params : (ctrl.params||{});
    const hostId = p?.hostId ?? (Object.values(Store.getState().arrays).find(a=>a.id!==ctrl.id)?.id ?? arr.id);
    const port   = (p?.port || 'east');
    const screenSize = p?.screenSize || {x:12,y:8,z:1};

    let screen = Object.values(Store.getState().arrays).find(a => a.params?.isScreen && a.params?.ownerCtrlId===ctrl.id);
    if(!screen){
      screen = Actions.createArray({name:'Game Screen', size:screenSize, hidden:false});
      screen.params = { ...(screen.params||{}), isScreen:true, ownerCtrlId:ctrl.id };
      const Y = screen.size.y-1;
      Actions.begin();
      for(let x=0;x<screen.size.x;x++) Actions.setCell(screen.id, {x, y:0, z:0}, '▁', null, true);
      const hero = {x:Math.floor(screen.size.x/2), y:1, z:0};
      Actions.setCell(screen.id, hero, 'Hero', null, true);
      Actions.end();
    }

    const host = Store.getState().arrays[hostId] || arr;
    const offset = dockOffsetFor(host, port, 1.0);
    Scene.setArrayOffset(screen, offset);
    Actions.setSelection(screen.id, {x:Math.floor(screen.size.x/2), y:1, z:0}, null, '3d');
    Actions.setCell(arr.id, anchor, '🎮', ast.raw, true);
  }catch(e){
    Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true);
  }
});
// DEP_VIS(flag): toggle dependency curve visibility (simple straight lines for now)
tag('DEP_VIS',['SCENE'],(anchor,arr,ast)=>{
  const flag = !!Formula.valOf(ast.args[0]);
  try{
    // Toggle scene overlay
    const S = Store.getState();
    const sc = Scene.getScene?.();
    if(!sc){ Actions.setCell(arr.id, anchor, '!ERR:Scene', ast.raw, true); return; }
    // Store on global for quick access
    if(flag===true || flag===false){
      // Toggle global state so UI can reflect
      S.globalState.set('dep.vis', flag?1:0);
    }
    // Build dependency curves from current dependency graph
    const want = !!flag;
    let group = sc.children.find?.(c=>c.userData && c.userData.kind==='depGroup');
    if(!group){ group = new THREE.Group(); group.userData.kind='depGroup'; sc.add(group); }
    group.visible = want;
    // Rebuild contents every toggle or when enabling
    while(group.children.length){ const ch=group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
    if(want){
      const deps = Store.getState().anchorsByDep;
      const arrays = Store.getState().arrays;
      const mat = new THREE.LineBasicMaterial({color:0x06b6d4, transparent:true, opacity:0.5});
      deps.forEach((dependents, depKey)=>{
        dependents.forEach(toKey=>{
          const [a1, r1] = depKey.split(':'); const [x1,y1,z1]=r1.split(',').map(Number);
          const [a2, r2] = toKey.split(':'); const [x2,y2,z2]=r2.split(',').map(Number);
          const arr1=arrays[+a1], arr2=arrays[+a2]; if(!arr1||!arr2) return;
          const p1 = Scene.worldPos(arr1,x1,y1,z1);
          const p2 = Scene.worldPos(arr2,x2,y2,z2);
          const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
          const line = new THREE.Line(geom, mat);
          group.add(line);
        });
      });
    }
    Actions.setCell(arr.id, anchor, want? 'Deps:ON' : 'Deps:OFF', ast.raw, true);
  }catch(e){ Actions.setCell(arr.id, anchor, `!ERR:${e.message}`, ast.raw, true); }
});

// Global intro trigger function (must be defined before tag registration)
window.startIntroExperience = function(){
  console.log('startIntroExperience: global function called (delegating to UI)');
  try{ window.UI?.startIntroExperience?.(); }catch(e){
    console.warn('startIntroExperience: UI path failed, applying inline fallback', e);
    const io = document.getElementById('introOverlay');
    const sheet = document.getElementById('sheet');
    if(io){ io.classList.add('hidden'); }
    if(sheet){ sheet.classList.remove('intro-centered'); sheet.style.left='16px'; sheet.style.bottom='16px'; sheet.style.top=''; sheet.style.transform=''; }
  }
};

tag('STARTINTROEXPERIENCE',['ACTION'],(anchor,arr,ast)=>{ 
  console.log('STARTINTROEXPERIENCE formula called');
  try{
    // Hide overlay and trigger layout collapse first, then run any extra UI logic
    try{ window.UI?.hideIntroOverlay?.(); }catch{}
    try{ window.UI?.triggerIntroCollapse?.(); }catch{}
    window.UI?.startIntroExperience?.();
  }catch(e){ console.warn('STARTINTROEXPERIENCE failed', e); } 
});

/* ===========================
   Cellular Automata (Life)
=========================== */
const CA = (()=> {
  const alive=(v)=> v===1||v==='1'||v===true||v==='X'||v==='x'||v==='■';
  const runLife2D=(arr,{axis='Y',index=0,steps=1})=>{
    const {x:W,y:H,z:D}=arr.size;
    const get=(x,y,z)=>{const ch=arr.chunks[keyChunk(...Object.values(chunkOf(x,y,z)))]; const c=ch.cells.find(t=>t.x===x&&t.y===y&&t.z===z); return c?.value;};
    const set=(x,y,z,v)=>Actions.setCell(arr.id,{x,y,z},v,null,true);
    const clamp=(n,min,max)=> ((n-min)%(max-min+1)+max-min+1)%(max-min+1)+min;
    const stepPlane=(A,B,fix,read)=>{ const cur=[]; for(let b=0;b<B;b++){cur[b]=[]; for(let a=0;a<A;a++){const [x,y,z]=read(a,b,fix); cur[b][a]=alive(get(x,y,z))?1:0;}}
      const nxt=cur.map(r=>r.slice());
      for(let b=0;b<B;b++)for(let a=0;a<A;a++){let n=0; for(let db=-1;db<=1;db++)for(let da=-1;da<=1;da++) if(da||db){const aa=clamp(a+da,0,A-1), bb=clamp(b+db,0,B-1); n+=cur[bb][aa];} nxt[b][a]=(cur[b][a]?(n===2||n===3):(n===3))?1:0;}
      for(let b=0;b<B;b++)for(let a=0;a<A;a++){const [x,y,z]=read(a,b,fix); set(x,y,z,nxt[b][a]);}
    };
    for(let s=0;s<steps;s++){
      if(axis==='Y') stepPlane(W,D,index,(a,b,f)=>[a,f,b]);
      if(axis==='Z') stepPlane(W,H,index,(a,b,f)=>[a,b,f]);
      if(axis==='X') stepPlane(D,H,index,(a,b,f)=>[f,b,a]);
    }
  };
  return {runLife2D};
})();

/* ===========================
   Scene (Three.js + Rapier)
=========================== */
const Boot = {
  step(t){ const el=document.getElementById('statusChip'); if(el) el.textContent=t; },
  ok(){ this.step('Ready'); },
  crash(e){ const el=document.getElementById('crash'); if(!el) return; el.style.display='block'; el.textContent=`Initialization failed\n\n${(e&&e.stack)||e}`; this.step('Crashed'); },
  log:(...a)=>{ try{ console.debug('[Toybox]',...a);}catch{} }
};
const Scene = (()=>{
  let scene, camera, renderer, controls, grid, axesHelper;
  let rapierWorld=null, controller=null, playerBody=null, playerCollider=null;
  const chunkMeshes=new Map(); // legacy chunk meshes (still used for some visuals)
  const layerMeshes=new Map(); // `${arr.id}:${z}` -> {mesh, capacity, used, index2cell}
  const connections = new Map(); // aKey(anchor) -> { line, start, end, ... }
  let depGroup=null, depVis=false; // dependency graph overlay
  let ziplineState = { active: false, line: null, direction: new THREE.Vector3(), progress: 0 };
  let cachedPlayerPos = new THREE.Vector3(); // Cache to avoid Rapier aliasing issues

  const FancyDefaults = {
    hdri: true,
    lights: true,
    darkBg: false,
    bloomEnabled: true,
    bloomStrength: 0.15,
    bloomRadius: 0.10,
    exposure: 0.5,
    dofEnabled: true,
    dofAperture: 0.002,
    dofMaxBlur: 0.001,
    transmission: true,
    mirror: true,
    solidGround: false,
    waveGrid: true,
    fogEnabled: false,
    fogDensity: 0.012,
    outlineEnabled: true,
    outlineStrength: 2.4,
    outlineThickness: 0.9,
    motionEnabled: false,
    motionDamping: 0.94,
    fxaa: true
  };

  const FancyGraphics = {
    enabled: false,
    settings: { ...FancyDefaults },
    composer: null,
    passes: {},
    groups: { lights: null, mirror: null, waveGrid: null, ground: null },
    shadowLights: [],
    decor: null,
    hdriTexture: null,
    hdriPromise: null,
    base: {
      gridVisible: true,
      background: null,
      environment: null,
      fog: null,
      toneMapping: null,
      exposure: 1,
      shadowMap: false,
      shadowAutoUpdate: true,
      physicallyCorrectLights: false,
      clearColor: null,
      clearAlpha: 1
    },
    clock: null,
    mirrorUniforms: null
  };

  const billboardObjects = new Set();
  const REFLECTION_FLIP_AXIS = 'y';

  function markBillboard(obj){
    if(!obj) return obj;
    try{
      obj.userData = obj.userData || {};
      obj.userData.billboard = true;
    }catch{}
    billboardObjects.add(obj);
    return obj;
  }

  function unmarkBillboard(obj){
    if(!obj) return;
    billboardObjects.delete(obj);
    if(obj.userData){
      delete obj.userData.__mirrorFlipped;
      delete obj.userData.__mirrorOrigScale;
    }
  }

  function applyMirrorBillboardFlip(active){
    const axis = REFLECTION_FLIP_AXIS;
    billboardObjects.forEach(obj=>{
      if(!obj || !obj.userData || !obj.userData.billboard){
        billboardObjects.delete(obj);
        return;
      }
      if(!obj.parent){
        billboardObjects.delete(obj);
        return;
      }
      if(active){
        if(obj.userData.__mirrorFlipped) return;
        if(obj.userData.__mirrorOrigScale){
          obj.userData.__mirrorOrigScale.copy(obj.scale);
        } else {
          obj.userData.__mirrorOrigScale = obj.scale.clone();
        }
        const s = obj.scale;
        if(axis === 'x'){
          s.x = (s.x === 0 ? 0 : -s.x);
        } else if(axis === 'y'){
          s.y = (s.y === 0 ? 0 : -s.y);
        } else {
          s.z = (s.z === 0 ? 0 : -s.z);
        }
        obj.userData.__mirrorFlipped = true;
      } else {
        if(!obj.userData.__mirrorFlipped) return;
        if(obj.userData.__mirrorOrigScale){
          obj.scale.copy(obj.userData.__mirrorOrigScale);
        } else {
          const s = obj.scale;
          if(axis === 'x'){
            s.x = (s.x === 0 ? 0 : -s.x);
          } else if(axis === 'y'){
            s.y = (s.y === 0 ? 0 : -s.y);
          } else {
            s.z = (s.z === 0 ? 0 : -s.z);
          }
        }
        obj.userData.__mirrorFlipped = false;
      }
    });
  }

  const PRESENT_LIGHT_BG = new THREE.Color(0xf6f7fb);
  const PRESENT_DARK_BG = new THREE.Color(0x0f172a);

  function cloneColorOrNull(color){
    if(!color) return null;
    try{ return color.clone ? color.clone() : color; }catch{ return color || null; }
  }

  function makeWaveGridMaterial(){
    const uniforms = {
      time:{value:0}, amp:{value:0.04}, freq:{value:1.2}, speed:{value:1.1},
      cell:{value:3.2}, width:{value:0.04}, color:{value:new THREE.Color(0x9fbfe8)}, alpha:{value:0.3}
    };
    const vertexShader = `uniform float time,amp,freq,speed; varying vec2 vXZ; void main(){
      vXZ = position.xz;
      float a = sin(vXZ.x*freq + time*speed);
      float b = sin((vXZ.y + vXZ.x*0.5)*freq*0.78 - time*0.83*speed);
      float c = sin((vXZ.x - vXZ.y*0.6)*freq*0.62 + time*1.21*speed);
      float h = (a*0.5 + b*0.3 + c*0.2)*amp;
      vec3 p = position; p.y += h; gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
    }`;
    const fragmentShader = `precision highp float; uniform float cell,width,alpha; uniform vec3 color; varying vec2 vXZ;
      void main(){ vec2 g=abs(fract(vXZ/cell)-0.5)*cell; float d=min(g.x,g.y); float line=1.0 - smoothstep(width,width*1.6,d);
      gl_FragColor=vec4(color,line*alpha); }`;
    return new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader, transparent:true, depthWrite:false });
  }

  function ensureFancyDecor(){
    if(FancyGraphics.decor) return;
    FancyGraphics.decor = new THREE.Group();
    FancyGraphics.decor.visible = false;
    scene.add(FancyGraphics.decor);
    FancyGraphics.shadowLights = [];

    const mirror = new Reflector(new THREE.PlaneGeometry(400,400), {
      textureWidth: Math.max(256, window.innerWidth),
      textureHeight: Math.max(256, window.innerHeight),
      clipBias: 0.002
    });
    mirror.rotation.x = -Math.PI/2;
    mirror.position.y = -0.52;
    mirror.material.onBeforeCompile = (shader)=>{
      shader.uniforms.time = { value: 0 };
      shader.uniforms.amp = { value: 0.02 };
      shader.uniforms.freq = { value: 8.0 };
      shader.uniforms.speed = { value: 1.2 };
      shader.fragmentShader = shader.fragmentShader.replace(
        'vec4 base = texture2D( tDiffuse, vUv );',
        `vec2 dv = vec2(
            sin((vUv.x + time*speed) * freq),
            sin((vUv.y - time*0.8*speed) * freq)
          ) * amp;
          vec4 base = texture2D( tDiffuse, vUv + dv );`
      );
      FancyGraphics.mirrorUniforms = shader.uniforms;
    };
    FancyGraphics.decor.add(mirror);
    FancyGraphics.groups.mirror = mirror;

    const originalMirrorBefore = mirror.onBeforeRender ? mirror.onBeforeRender.bind(mirror) : null;
    const originalMirrorAfter = mirror.onAfterRender ? mirror.onAfterRender.bind(mirror) : null;

    mirror.onBeforeRender = function(...args){
      applyMirrorBillboardFlip(true);
      if(originalMirrorBefore){
        try{
          originalMirrorBefore(...args);
        }catch(err){
          applyMirrorBillboardFlip(false);
          throw err;
        }
      }
    };

    mirror.onAfterRender = function(...args){
      try{
        if(originalMirrorAfter){
          originalMirrorAfter(...args);
        }
      }finally{
        applyMirrorBillboardFlip(false);
      }
    };

    const solidGround = new THREE.Mesh(
      new THREE.PlaneGeometry(400,400),
      new THREE.MeshStandardMaterial({ color: 0xe6e9ef, roughness: 0.85, metalness: 0.1 })
    );
    solidGround.rotation.x = -Math.PI/2;
    solidGround.position.y = -0.51;
    solidGround.receiveShadow = true;
    solidGround.visible = false;
    FancyGraphics.decor.add(solidGround);
    FancyGraphics.groups.ground = solidGround;

    const waveGrid = new THREE.Mesh(new THREE.PlaneGeometry(400,400,180,180), makeWaveGridMaterial());
    waveGrid.rotation.x = -Math.PI/2;
    waveGrid.position.y = -0.48;
    FancyGraphics.decor.add(waveGrid);
    FancyGraphics.groups.waveGrid = waveGrid;

    const lights = new THREE.Group();
    const key = new THREE.DirectionalLight(0xffffff, 3.2); key.position.set(-8, 14, 10);
    const fill = new THREE.DirectionalLight(0xffffff, 1.4); fill.position.set(10, 6, 12);
    const rim = new THREE.DirectionalLight(0xffffff, 2.6); rim.position.set(0, 8, -14);
    const hemi = new THREE.HemisphereLight(0xdbeafe, 0x0f172a, 0.6);
    key.castShadow = false;
    key.shadow.mapSize.set(2048,2048);
    key.shadow.camera.near = 0.5;
    key.shadow.camera.far = 200;
    key.shadow.camera.left = -80;
    key.shadow.camera.right = 80;
    key.shadow.camera.top = 80;
    key.shadow.camera.bottom = -80;
    key.shadow.bias = -0.0008;
    FancyGraphics.shadowLights.push(key);
    lights.add(key);

    [fill, rim, hemi].forEach(light=>{
      light.castShadow = false;
      lights.add(light);
    });
    FancyGraphics.decor.add(lights);
    FancyGraphics.groups.lights = lights;
  }

  function ensureFancyComposer(){
    if(FancyGraphics.composer) return;
    const fancyTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
      depthBuffer: true,
      stencilBuffer: true
    });
    FancyGraphics.composer = new EffectComposer(renderer, fancyTarget);
    if(FancyGraphics.composer.renderTarget1) FancyGraphics.composer.renderTarget1.stencilBuffer = true;
    if(FancyGraphics.composer.renderTarget2) FancyGraphics.composer.renderTarget2.stencilBuffer = true;
    FancyGraphics.passes.render = new RenderPass(scene, camera);
    FancyGraphics.composer.addPass(FancyGraphics.passes.render);

    const bokeh = new BokehPass(scene, camera, {
      focus: camera.position.distanceTo(controls?.target || new THREE.Vector3()),
      aperture: FancyGraphics.settings.dofAperture,
      maxblur: FancyGraphics.settings.dofMaxBlur,
      width: window.innerWidth,
      height: window.innerHeight
    });
    FancyGraphics.composer.addPass(bokeh);
    FancyGraphics.passes.bokeh = bokeh;

    const outline = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
    outline.edgeStrength = FancyGraphics.settings.outlineStrength;
    outline.edgeThickness = FancyGraphics.settings.outlineThickness;
    outline.visibleEdgeColor.set(0x3b82f6);
    outline.hiddenEdgeColor.set(0x0f172a);
    FancyGraphics.composer.addPass(outline);
    FancyGraphics.passes.outline = outline;

    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), FancyGraphics.settings.bloomStrength, 0.4, 0.85);
    bloom.radius = FancyGraphics.settings.bloomRadius;
    FancyGraphics.composer.addPass(bloom);
    FancyGraphics.passes.bloom = bloom;

    const afterimage = new AfterimagePass();
    FancyGraphics.composer.addPass(afterimage);
    FancyGraphics.passes.afterimage = afterimage;

    const fxaa = new ShaderPass(FXAAShader);
    FancyGraphics.composer.addPass(fxaa);
    FancyGraphics.passes.fxaa = fxaa;

    const output = new OutputPass();
    FancyGraphics.composer.addPass(output);
    FancyGraphics.passes.output = output;

    updateFancyComposerSize();
  }

  function ensureFancyHDRI(){
    if(FancyGraphics.hdriTexture) return Promise.resolve(FancyGraphics.hdriTexture);
    if(FancyGraphics.hdriPromise) return FancyGraphics.hdriPromise;
    FancyGraphics.hdriPromise = new Promise((resolve, reject)=>{
      try{
        const loader = new RGBELoader();
        loader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (tex)=>{
          tex.mapping = THREE.EquirectangularReflectionMapping;
          FancyGraphics.hdriTexture = tex;
          resolve(tex);
        }, undefined, reject);
      }catch(e){ reject(e); }
    });
    return FancyGraphics.hdriPromise.catch((e)=>{ console.warn('HDRI load failed', e); FancyGraphics.hdriPromise=null; throw e; });
  }

  function updateFancyComposerSize(){
    if(!FancyGraphics.composer) return;
    const dpr = Math.min(window.devicePixelRatio||1, 2);
    FancyGraphics.composer.setPixelRatio(dpr);
    FancyGraphics.composer.setSize(window.innerWidth, window.innerHeight);
    if(FancyGraphics.passes.fxaa){
      FancyGraphics.passes.fxaa.material.uniforms.resolution.value.set(1/(window.innerWidth*dpr), 1/(window.innerHeight*dpr));
    }
    if(FancyGraphics.passes.bloom){ FancyGraphics.passes.bloom.setSize(window.innerWidth, window.innerHeight); }
    if(FancyGraphics.passes.outline){ FancyGraphics.passes.outline.setSize(window.innerWidth, window.innerHeight); }
    if(FancyGraphics.passes.bokeh){
      FancyGraphics.passes.bokeh.renderTargetDepth.setSize(window.innerWidth*dpr, window.innerHeight*dpr);
      FancyGraphics.passes.bokeh.renderTargetColor.setSize(window.innerWidth*dpr, window.innerHeight*dpr);
    }
  }

  function applyFancyRuntimeSettings(){
    if(!FancyGraphics.enabled) return;
    renderer.toneMappingExposure = FancyGraphics.settings.exposure;
    renderer.setClearColor(FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG, 1);
    scene.background = (FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG).clone();

    if(FancyGraphics.passes.bloom){
      FancyGraphics.passes.bloom.enabled = FancyGraphics.settings.bloomEnabled;
      FancyGraphics.passes.bloom.strength = FancyGraphics.settings.bloomStrength;
      FancyGraphics.passes.bloom.radius = FancyGraphics.settings.bloomRadius;
    }
    if(FancyGraphics.passes.bokeh){
      FancyGraphics.passes.bokeh.enabled = FancyGraphics.settings.dofEnabled;
      FancyGraphics.passes.bokeh.uniforms.aperture.value = FancyGraphics.settings.dofAperture;
      FancyGraphics.passes.bokeh.uniforms.maxblur.value = FancyGraphics.settings.dofMaxBlur;
    }
    if(FancyGraphics.passes.fxaa){ FancyGraphics.passes.fxaa.enabled = FancyGraphics.settings.fxaa; }
    if(FancyGraphics.passes.outline){
      FancyGraphics.passes.outline.enabled = FancyGraphics.settings.outlineEnabled;
      FancyGraphics.passes.outline.edgeStrength = FancyGraphics.settings.outlineStrength;
      FancyGraphics.passes.outline.edgeThickness = FancyGraphics.settings.outlineThickness;
    }
    if(FancyGraphics.passes.afterimage){
      FancyGraphics.passes.afterimage.enabled = FancyGraphics.settings.motionEnabled;
      FancyGraphics.passes.afterimage.uniforms['damp'].value = FancyGraphics.settings.motionDamping;
    }
    if(FancyGraphics.groups.lights){ FancyGraphics.groups.lights.visible = FancyGraphics.settings.lights; }
    if(FancyGraphics.groups.waveGrid){ FancyGraphics.groups.waveGrid.visible = FancyGraphics.settings.waveGrid; }
    refreshShadowCasting();
    if(FancyGraphics.settings.hdri){
      ensureFancyHDRI().then((tex)=>{ if(FancyGraphics.enabled && FancyGraphics.settings.hdri){ scene.environment = tex; } }).catch(()=>{});
    } else {
      scene.environment = null;
    }

    if(FancyGraphics.settings.fogEnabled){
      scene.fog = new THREE.FogExp2((FancyGraphics.settings.darkBg ? PRESENT_DARK_BG : PRESENT_LIGHT_BG).clone(), FancyGraphics.settings.fogDensity);
    } else {
      scene.fog = null;
    }
  }

  function setPresentMode(force){
    const next = force == null ? !FancyGraphics.enabled : !!force;
    if(next === FancyGraphics.enabled) return FancyGraphics.enabled;
    if(next){
      FancyGraphics.base.gridVisible = grid?.visible ?? true;
      FancyGraphics.base.background = cloneColorOrNull(scene?.background || null);
      FancyGraphics.base.environment = scene?.environment || null;
      FancyGraphics.base.fog = scene?.fog || null;
      FancyGraphics.base.toneMapping = renderer?.toneMapping ?? null;
      FancyGraphics.base.exposure = renderer?.toneMappingExposure ?? 1;
      FancyGraphics.base.shadowMap = renderer?.shadowMap?.enabled ?? false;
      FancyGraphics.base.shadowAutoUpdate = renderer?.shadowMap?.autoUpdate ?? true;
      FancyGraphics.base.physicallyCorrectLights = renderer?.physicallyCorrectLights ?? false;
      FancyGraphics.base.clearColor = cloneColorOrNull(renderer?.getClearColor ? renderer.getClearColor(new THREE.Color()) : new THREE.Color(0xf6f7fb));
      FancyGraphics.base.clearAlpha = renderer?.getClearAlpha ? renderer.getClearAlpha() : 1;

      ensureFancyDecor();
      ensureFancyComposer();
      FancyGraphics.decor.visible = FancyGraphics.settings.waveGrid || FancyGraphics.settings.mirror || FancyGraphics.settings.solidGround;
      grid.visible = false;
      renderer.physicallyCorrectLights = true;
      renderer.shadowMap.enabled = FancyGraphics.settings.solidGround;
      if(renderer.shadowMap.enabled){ renderer.shadowMap.type = THREE.PCFSoftShadowMap; }
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      FancyGraphics.clock = new THREE.Clock();
      FancyGraphics.enabled = true;
      applyFancyRuntimeSettings();
    } else {
      FancyGraphics.enabled = false;
      refreshShadowCasting();
      if(FancyGraphics.decor) FancyGraphics.decor.visible = false;
      grid.visible = !!FancyGraphics.base.gridVisible;
      setupRenderer();
      renderer.setClearColor(FancyGraphics.base.clearColor || new THREE.Color(0xf6f7fb), FancyGraphics.base.clearAlpha ?? 1);
      renderer.shadowMap.enabled = FancyGraphics.base.shadowMap ?? false;
      renderer.shadowMap.autoUpdate = FancyGraphics.base.shadowAutoUpdate ?? true;
      renderer.physicallyCorrectLights = FancyGraphics.base.physicallyCorrectLights ?? false;
      renderer.toneMapping = FancyGraphics.base.toneMapping ?? THREE.NoToneMapping;
      renderer.toneMappingExposure = FancyGraphics.base.exposure ?? 1;
      scene.environment = FancyGraphics.base.environment || null;
      scene.background = FancyGraphics.base.background ? cloneColorOrNull(FancyGraphics.base.background) : PRESENT_LIGHT_BG.clone();
      scene.fog = FancyGraphics.base.fog || null;
      if(FancyGraphics.passes.outline) FancyGraphics.passes.outline.selectedObjects = [];
    }
    updateShellVisibilityGlobal();
    refreshCellMaterials();
    return FancyGraphics.enabled;
  }

  function togglePresentMode(force){
    const state = setPresentMode(force);
    return state;
  }

  function getGraphicsSettings(){
    return { ...FancyGraphics.settings };
  }

  function updateGraphicsSettings(patch){
    const incoming = patch || {};
    Object.keys(incoming).forEach(key=>{
      if(key in FancyGraphics.settings){ FancyGraphics.settings[key] = incoming[key]; }
    });
    if(Object.prototype.hasOwnProperty.call(incoming, 'solidGround') && incoming.solidGround){
      FancyGraphics.settings.mirror = false;
    }
    if(FancyGraphics.settings.solidGround){
      FancyGraphics.settings.mirror = false;
    }
    const affectsMaterials = Object.prototype.hasOwnProperty.call(incoming, 'transmission');
    if(FancyGraphics.enabled){
      applyFancyRuntimeSettings();
      if(affectsMaterials) refreshCellMaterials();
    } else if(affectsMaterials){
      refreshCellMaterials();
    }
  }

  function isPresentEnabled(){ return FancyGraphics.enabled; }
    // Hover highlight state (2D/3D sync)
    let hoverKey = null; // `${arrId}:${x},${y},${z}`
    const HIGHLIGHT_FILL_HEX = 0xe0f2ff; // light blue fill
    function applyHoverColor(arrId, coord){
      try{
        const arr = Store.getState().arrays[arrId]; if(!arr) return;
        const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return;
        if(!ch.index2cell) return;
        const idx = ch.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
        if(idx<0) return;
        const col = new THREE.Color(HIGHLIGHT_FILL_HEX); col.convertSRGBToLinear();
        if(ch.meshLOD1){ ch.meshLOD1.setColorAt(idx, col); if(ch.meshLOD1.instanceColor) ch.meshLOD1.instanceColor.needsUpdate = true; }
        if(ch.meshGhost){ ch.meshGhost.setColorAt(idx, col); if(ch.meshGhost.instanceColor) ch.meshGhost.instanceColor.needsUpdate = true; }
        if(ch.meshShell){ const sc = new THREE.Color(HIGHLIGHT_FILL_HEX); sc.offsetHSL(0,0,-0.22); sc.convertSRGBToLinear(); ch.meshShell.setColorAt(idx, sc); if(ch.meshShell.instanceColor) ch.meshShell.instanceColor.needsUpdate = true; }
        needsRender = true;
      }catch{}
    }
    function setHoverCell(target){
      try{
        const k = target ? `${target.arrId}:${target.x},${target.y},${target.z}` : null;
        if(k===hoverKey) return;
        // clear previous
        if(hoverKey){
          const [aid, rest] = hoverKey.split(':'); const [x,y,z] = rest.split(',').map(Number);
          updateCellColor(+aid, {x,y,z});
        }
        hoverKey = k;
        if(target){ applyHoverColor(target.arrId, target); }
        try{ window.UI?.setHoveredCell?.(target?.arrId || null, target || null); }catch{}
      }catch{}
    }
    function clearHoverCell(){ setHoverCell(null); }
    const temp=new THREE.Object3D(), tempM=new THREE.Matrix4();
    let needsRender = false;
    function refreshShadowCasting(){
      const enable = FancyGraphics.enabled && FancyGraphics.settings.solidGround;
      renderer.shadowMap.enabled = enable;
      renderer.shadowMap.autoUpdate = enable;
      if(enable){
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = true;
      }
      if(FancyGraphics.groups.ground){ FancyGraphics.groups.ground.visible = enable; }
      if(FancyGraphics.groups.mirror){
        FancyGraphics.groups.mirror.visible = FancyGraphics.settings.mirror && !FancyGraphics.settings.solidGround;
      }
      if(FancyGraphics.decor){
        const decorActive = FancyGraphics.enabled && (FancyGraphics.settings.waveGrid || FancyGraphics.settings.solidGround || FancyGraphics.settings.mirror);
        FancyGraphics.decor.visible = decorActive;
      }
      FancyGraphics.shadowLights.forEach(light=>{ light.castShadow = enable; });
      try{
        Object.values(Store.getState().arrays||{}).forEach(arr=>{
          Object.values(arr.chunks||{}).forEach(ch=>{
            if(ch.meshLOD1) ch.meshLOD1.castShadow = enable;
            if(ch.meshLOD2) ch.meshLOD2.castShadow = enable;
            if(ch.meshGhost) ch.meshGhost.castShadow = false;
            if(ch.meshShell) ch.meshShell.castShadow = false;
          });
        });
      }catch{}
      needsRender = true;
    }

    function updateShellVisibilityGlobal(){
      const showShells = !FancyGraphics.enabled;
      try{
        const arrays = Store.getState().arrays || {};
        Object.values(arrays).forEach(arr=>{
          if(!arr) return;
          const arrVisible = !arr.hidden;
          Object.values(arr.chunks||{}).forEach(ch=>{
            if(!ch?.meshShell) return;
            const lod = (ch.currentLOD == null) ? 1 : ch.currentLOD;
            ch.meshShell.visible = showShells && arrVisible && (lod === 1);
          });
        });
      }catch{}
    }
    // Instance bounce store
  const activeInstanceAnims = new Map(); // key `${arrId}:${z}:${type}:${idx}` -> {cancel,busy:true}
  // InteractionManager: transient overlaps and gobble checks
  const InteractionManager = (()=>{
    function getCellWorldBounds(arr,x,y,z){
      const c=cellWorldPos(arr,x,y,z);
      const min=c.clone().add(new THREE.Vector3(-0.5,-0.5,-0.5));
      const max=c.clone().add(new THREE.Vector3( 0.5, 0.5, 0.5));
      return new THREE.Box3(min,max);
    }
    function runChecks(moved){
      try{ checkTransient(moved); }catch{}
      const S=Store.getState();
      if(S?.interactions?.gobblingEnabled){ try{ checkGobble(moved); }catch{} }
    }
    function checkTransient(moved){
      const S=Store.getState(); const tx=Write.start('interaction.transient','overlaps');
      const others=Object.values(S.arrays).filter(a=>!a.hidden && a.id!==moved.id);
      Object.values(moved.chunks).forEach(ch=> ch.cells.forEach(ca=>{
        const bA=getCellWorldBounds(moved,ca.x,ca.y,ca.z);
        const fA=String(Formula.getCell({arrId:moved.id,x:ca.x,y:ca.y,z:ca.z})?.formula||'');
        others.forEach(b=> Object.values(b.chunks).forEach(chb=> chb.cells.forEach(cb=>{
          const bB=getCellWorldBounds(b,cb.x,cb.y,cb.z);
          if(!bA.intersectsBox(bB)) return;
          const fB=String(Formula.getCell({arrId:b.id,x:cb.x,y:cb.y,z:cb.z})?.formula||'');
          // naive check: always_exec flag present if last arg is 1 ... defer strict parsing
          if(/^=\s*OVERLAP\(/i.test(fA) && /\)\s*$/.test(fA) && fA.trim().endsWith('1)')){
            S.globalState.set('temp.overlap_target',{arrId:b.id,x:cb.x,y:cb.y,z:cb.z});
            Formula.executeAt({arrId:moved.id,x:ca.x,y:ca.y,z:ca.z}, undefined, tx);
          }
          if(/^=\s*OVERLAP\(/i.test(fB) && /\)\s*$/.test(fB) && fB.trim().endsWith('1)')){
            S.globalState.set('temp.overlap_target',{arrId:moved.id,x:ca.x,y:ca.y,z:ca.z});
            Formula.executeAt({arrId:b.id,x:cb.x,y:cb.y,z:cb.z}, undefined, tx);
          }
        })));
      }));
      S.globalState.delete('temp.overlap_target');
      if(tx.ops.length) Write.commit(tx);
    }
    function canGobble(gobbler,gobblee){
      // require every gobblee filled/formula cell to intersect at least one gobbler cell bounds
      const filled = [];
      Object.values(gobbler.chunks).forEach(ch=> ch.cells.forEach(c=>{ const fc=Formula.getCell({arrId:gobbler.id,x:c.x,y:c.y,z:c.z}); if(fc.value!==''||fc.formula){ filled.push(getCellWorldBounds(gobbler,c.x,c.y,c.z)); } }));
      if(!filled.length) return false;
      let ok=true;
      outer: for(const ch of Object.values(gobblee.chunks)){
        for(const c of ch.cells){ const fc=Formula.getCell({arrId:gobblee.id,x:c.x,y:c.y,z:c.z}); if(!(fc.value!==''||fc.formula)) continue; const bb=getCellWorldBounds(gobblee,c.x,c.y,c.z); let covered=false; for(const b of filled){ if(b.intersectsBox(bb)){ covered=true; break; } } if(!covered){ ok=false; break outer; } }
      }
      return ok;
    }
    function combineArrays(winner,loser){
      showToast(`Array #${winner.id} combined with #${loser.id}`);
      const tx=Write.start('interaction.combine',`Combine ${winner.id}+${loser.id}`);
      Object.values(loser.chunks).forEach(ch=> ch.cells.forEach(cL=>{
        const vL=Formula.getCell({arrId:loser.id,x:cL.x,y:cL.y,z:cL.z}); if(!(vL.value!==''||vL.formula)) return;
        // find any intersecting winner cell
        let target=null; for(const chw of Object.values(winner.chunks)){ for(const cW of chw.cells){ const bW=getCellWorldBounds(winner,cW.x,cW.y,cW.z); const bL=getCellWorldBounds(loser,cL.x,cL.y,cL.z); if(bW.intersectsBox(bL)){ target={x:cW.x,y:cW.y,z:cW.z}; break; } } if(target) break; }
        if(!target) return;
        const cellW=Formula.getCell({arrId:winner.id,x:target.x,y:target.y,z:target.z});
        const isEmptyW = (cellW.value===''||cellW.value==null) && !cellW.formula;
        // default mode: fill empty
        if(isEmptyW){ Write.set(tx, winner.id, target, { value: vL.value, formula: vL.formula }); }
      }));
      Write.commit(tx);
      try{ Actions.deleteArray(loser.id); }catch{}
    }
    function checkGobble(moved){
      const S=Store.getState(); const arrays=Object.values(S.arrays).filter(a=>!a.hidden);
      for(const other of arrays){ if(other.id===moved.id) continue; if(canGobble(moved,other)){ combineArrays(moved,other); return; } if(canGobble(other,moved)){ combineArrays(other,moved); return; } }
    }
    return { runChecks };
  })();

  function easeOutBack(t, s=1.70158){ const tt=t-1; return (tt*tt*((s+1)*tt + s) + 1); }

  function pulseCell(arr, cell, z){
    // Collect candidate records: core types + any edges overlays for this array/z
    const wantedKeys=[`${arr.id}:${z}:empty`,`$${arr.id}:${z}:ghost`,`$${arr.id}:${z}:filled`,`$${arr.id}:${z}:formula`];
    const recs=[];
    ['empty','ghost','filled','formula'].forEach(type=>{
      const rec=layerMeshes.get(`${arr.id}:${z}:${type}`); if(rec) recs.push({type,rec});
    });
    // Include all edge overlays for this array/z regardless of base group key
    layerMeshes.forEach((val,key)=>{
      if(val?.mesh?.userData?.type==='edges' && val.mesh?.userData?.arrayId===arr.id && val.mesh?.userData?.z===z){
        recs.push({type:'edges',rec:val});
      }
    });

    recs.forEach(({type,rec})=>{
      if(!rec||!rec.mesh||!rec.index2cell) return;
      const idx=rec.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
      if(idx<0) return;
      const mesh=rec.mesh; const key=`${arr.id}:${z}:${type}:${idx}`;
      const running=activeInstanceAnims.get(key);
      // Guard: if running, ignore this click completely to prevent inflation
      if(running && running.busy){ return; }
      // capture base matrix
      const base=new THREE.Matrix4(); mesh.getMatrixAt(idx, base);
      let start=undefined; const duration=180; const amp=(type==='edges'?0.12:0.06);
      const state={cancel:false,busy:true}; activeInstanceAnims.set(key,state);
      const step=(ts)=>{
        if(state.cancel) { mesh.setMatrixAt(idx, base); mesh.instanceMatrix.needsUpdate=true; activeInstanceAnims.delete(key); return; }
        if(start===undefined) start=ts; const t=Math.min(1,(ts-start)/duration);
        const s=1 + amp*easeOutBack(t);
        const m=base.clone().multiply(new THREE.Matrix4().makeScale(s,s,s));
        mesh.setMatrixAt(idx,m); mesh.instanceMatrix.needsUpdate=true;
        if(t<1) requestAnimationFrame(step); else { // return to base for precision
          mesh.setMatrixAt(idx, base); mesh.instanceMatrix.needsUpdate=true; activeInstanceAnims.delete(key);
        }
      };
      requestAnimationFrame(step);
    });
  }

  // Text sprite creation for cell values
  function makeValueSprite(text, isFormula=false){
    const renderMode = Store.getState().scene.renderMode;
    
    if(renderMode === 'fancy') {
      // Rounded backdrop with drop shadow
      const padX = 12, padY = 8, fs = 28, r = 8;
      const font = `600 ${fs}px 'Roboto Mono', monospace`;

      // First measure
      const mCanvas = document.createElement('canvas');
      const mCtx = mCanvas.getContext('2d');
      mCtx.font = font;
      const w = Math.max(48, Math.ceil(mCtx.measureText(text).width) + padX * 2);
      const h = fs + padY * 2;

      // Draw
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const ctx = c.getContext('2d');

      // Backdrop with rounded corners
      ctx.fillStyle = 'rgba(17, 24, 39, 0.66)'; // slate-900 @ ~66%
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const rr = (x, y, w, h, r) => {
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
      };
      rr(0.5, 0.5, w - 1, h - 1, r);
      ctx.fill();
      ctx.stroke();

      // Text with subtle shadow
      ctx.font = font;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 4;
      ctx.fillStyle = isFormula ? '#cfe0ff' : '#ffffff';
      ctx.fillText(text, w / 2, h / 2);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = 4;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(0.9, 0.44, 1);
      spr.renderOrder = 2000;
      return markBillboard(spr);
    } else {
      // Simple mode (current behavior)
      const canvas=document.createElement('canvas');
      const ctx=canvas.getContext('2d');
      const fontSize=28; const padding=4;
      ctx.font=`600 ${fontSize}px 'Roboto Mono', monospace`;
      const metrics=ctx.measureText(text);
      canvas.width=Math.max(48, metrics.width+padding*2);
      canvas.height=fontSize+padding*2;
      
      // Draw text only (no backdrop card). Billboarded sprite will sit on cell face.
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const fg = isFormula ? '#e6ffef' : '#ffffff';
      ctx.fillStyle = fg;
      ctx.font=`600 ${fontSize}px 'Roboto Mono', monospace`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      
      const texture=new THREE.CanvasTexture(canvas);
      // Place label on cell face (depth tested), slightly lifted to avoid z-fighting
      const material=new THREE.SpriteMaterial({map:texture, transparent:true, depthTest:true, depthWrite:false});
      material.toneMapped=false;
      const sprite=new THREE.Sprite(material);
      sprite.scale.set(0.5, 0.32, 1);
      sprite.renderOrder=2; // above solids, below edge overlays
      return markBillboard(sprite);
    }
  }
  // 3D label sprite for arrays (ID and name) - improved with depth testing
  function makeArrayLabelSprite(arr){
    const text = `#${arr.id}${arr.name ? ` — "${arr.name}"` : ''}`;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 32, padding = 8, r = 12;
    ctx.font = `700 ${fontSize}px 'Inter', sans-serif`;
    const metrics = ctx.measureText(text);
    const w = Math.ceil(metrics.width + padding*2);
    const h = fontSize + padding*2;
    // Render at device pixel ratio for sharper text
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    ctx.scale(dpr, dpr);

    // rounded white pill + text
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(r,0);
    ctx.arcTo(w,0,w,h,r); ctx.arcTo(w,h,0,h,r); ctx.arcTo(0,h,0,0,r); ctx.arcTo(0,0,w,0,r);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#1f2937';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.font = `700 ${fontSize}px 'Inter', sans-serif`;
    ctx.fillText(text, w/2, h/2);

    const tex = new THREE.CanvasTexture(canvas);
    tex.colorSpace = THREE.SRGBColorSpace; // correct gamma for UI texture
    tex.anisotropy = renderer?.capabilities?.getMaxAnisotropy?.() || 1;
    tex.minFilter = THREE.LinearMipMapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.generateMipmaps = true;

    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true,
      depthTest: true,
      depthWrite: false
    });
    mat.toneMapped = false;

    const mesh = new THREE.Sprite(mat);
    const aspect = w/h;
    // Slightly reduce width/height to avoid a stretched look while preserving aspect
    mesh.scale.set(1.0*aspect, 1.0, 1);   // world-unit size
    mesh.userData.isLabel = true;
    return markBillboard(mesh);
  }
  const COLORS = {
    empty: 0xffffff,      // empty cells: clean white
    emptyBorder: 0xe5e7eb, // empty border: light gray
    filled: 0x3b82f6,     // data cells: vibrant blue
    formula: 0x16a34a,    // formulas: dark green
    emitted: 0x86efac,    // emitted values: light green
    ghost: 0xf3f4f6,      // ghost layers: very light gray
    ghostBorder: 0xd1d5db, // ghost border: medium gray
    focus: 0xf59e0b,      // focus highlight: amber
    frame: 0x374151,      // array frame: dark gray
    grab: 0x06b6d4        // grab handle: cyan
  };
  // Fixed visibility settings (UI removed)
  const DEFAULT_VISIBILITY = {
      empty:   { color: COLORS.empty,   outlineColor: 0xe5e7eb, outlineThickness: 1.0, outlineOpacity: 0.35 },
      value:   { color: COLORS.filled,  outlineColor: null,     outlineThickness: 1.0, outlineOpacity: 0.35 },
      formula: { color: COLORS.formula, outlineColor: null,     outlineThickness: 1.0, outlineOpacity: 0.35 },
      emitted: { color: COLORS.emitted, outlineColor: null,     outlineThickness: 1.0, outlineOpacity: 0.35 }
    };
  window.VisibilitySettings = DEFAULT_VISIBILITY;
  function typeKeyFrom(raw){
    let t = String(raw||'value');
    if(t.startsWith('ghost_')) t = t.slice(6);
    if(t==='filled') t='value';
    return t;
  }
  function baseHexForTypeKey(tk){
    const vs = window.VisibilitySettings || {}; const s = vs[tk];
    return (s && typeof s.color==='number') ? s.color : (tk==='empty'?COLORS.empty: tk==='formula'?COLORS.formula: tk==='emitted'?COLORS.emitted: COLORS.filled);
  }
  // Make default outlines subtler: 1.01 instead of 1.04
  const BASE_OUTLINE_SCALE = 1.01;
  function outlineParamsForTypeKey(tk){
    const vs = window.VisibilitySettings || {}; const s = vs[tk]||{};
    const setting = Number(s.outlineThickness||1.0);
    const actual = BASE_OUTLINE_SCALE * (isFinite(setting)?setting:1.0);
    const thickness = Math.max(0.98, Math.min(1.12, actual));
    const colorHex = (typeof s.outlineColor==='number' ? s.outlineColor : null);
    const opacity = (typeof s.outlineOpacity==='number' ? s.outlineOpacity : 0.35);
    return { thickness, colorHex, opacity };
  }
  const focusMarker=new THREE.Mesh(new THREE.BoxGeometry(1.06,1.06,1.06),new THREE.MeshBasicMaterial({color:COLORS.focus,wireframe:true}));
  
  // Singleton geometries and materials for performance
  const GEO_VOXEL = new RoundedBoxGeometry(0.9, 0.9, 0.9, 2, 0.1);
  const SHELL_SCALE = 1.08; // shells slightly larger than fills
  const GEO_SHELL = new RoundedBoxGeometry(0.9*SHELL_SCALE, 0.9*SHELL_SCALE, 0.9*SHELL_SCALE, 2, 0.1);
  function addWhiteVertexColors(geo){
    try{
      const n = geo.getAttribute('position')?.count|0;
      if(!geo.getAttribute('color') && n>0){ const arr = new Float32Array(n*3); arr.fill(1.0); geo.setAttribute('color', new THREE.BufferAttribute(arr, 3)); }
    }catch{}
  }
  addWhiteVertexColors(GEO_VOXEL);
  addWhiteVertexColors(GEO_SHELL);
  const cellMaterialCache = new Map();
  function materialKeyFor(type){
    const base = String(type||'').startsWith('ghost') ? 'ghost' : String(type||'filled');
    const mode = FancyGraphics.enabled ? 'present' : 'simple';
    const frosted = FancyGraphics.enabled && FancyGraphics.settings.transmission ? 'frosted' : 'solid';
    return `${mode}:${frosted}:${base}`;
  }
  function createCellMaterial(type='filled'){
    const baseType = String(type||'').startsWith('ghost') ? 'ghost' : String(type||'filled');
    const key = materialKeyFor(baseType);
    if(cellMaterialCache.has(key)) return cellMaterialCache.get(key);

    let material;
    if(baseType === 'ghost'){
      if(FancyGraphics.enabled){
        material = new THREE.MeshPhysicalMaterial({
          color: new THREE.Color(0xffffff),
          vertexColors: true,
          transparent: true,
          opacity: 0.28,
          depthWrite: false,
          depthTest: true,
          roughness: 0.85,
          metalness: 0.05,
          envMapIntensity: 0.35,
          transmission: 0.0,
          clearcoat: 0.0
        });
        material.blending = THREE.NormalBlending;
        material.toneMapped = true;
      }else{
        material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.35,
          blending: THREE.NormalBlending,
          depthWrite: false,
          depthTest: true,
          vertexColors: true
        });
        material.toneMapped = false;
      }
    }else{
      if(FancyGraphics.enabled){
        const frosted = !!FancyGraphics.settings.transmission;
        const params = {
          color: new THREE.Color(0xffffff),
          vertexColors: true,
          roughness: frosted ? 0.78 : 0.32,
          metalness: frosted ? 0.06 : 0.22,
          envMapIntensity: frosted ? 1.3 : 1.2,
          clearcoat: 0.35,
          clearcoatRoughness: frosted ? 0.55 : 0.2,
          reflectivity: 0.5,
          depthWrite: true,
          depthTest: true
        };
        if(frosted){
          Object.assign(params, {
            transparent: true,
            opacity: 0.9,
            transmission: 0.58,
            thickness: 1.4,
            ior: 1.18,
            attenuationColor: new THREE.Color(0xcfe3ff),
            attenuationDistance: 1.25
          });
        }else{
          Object.assign(params, {
            transparent: false,
            transmission: 0.0
          });
        }
        material = new THREE.MeshPhysicalMaterial(params);
        material.toneMapped = true;
      }else{
        const isEmpty = (baseType === 'empty');
        material = new THREE.MeshBasicMaterial({
          color: isEmpty ? COLORS.empty : 0xffffff,
          transparent: false,
          depthWrite: true,
          vertexColors: true
        });
        material.toneMapped = false;
      }
    }

    material.userData = { ...(material.userData||{}), pass: baseType === 'ghost' ? 'ghost' : 'solid' };
    cellMaterialCache.set(key, material);
    return material;
  }

  function rebuildCellMaterialRefs(){
    try{
      const arrays = Store.getState().arrays || {};
      Object.values(arrays).forEach(arr=>{
        const collected = new Set();
        Object.values(arr.chunks||{}).forEach(ch=>{
          if(ch?.meshLOD1?.material) collected.add(ch.meshLOD1.material);
          if(ch?.meshGhost?.material) collected.add(ch.meshGhost.material);
        });
        arr._cellMaterials = Array.from(collected);
      });
    }catch{}
  }

  function refreshCellMaterials(){
    try{
      const visited = new Set();
      const oldMaterials = new Set();
      cellMaterialCache.clear();

      const assign = (mesh, type)=>{
        if(!mesh || visited.has(mesh.uuid)) return;
        visited.add(mesh.uuid);
        if(mesh.material) oldMaterials.add(mesh.material);
        mesh.material = createCellMaterial(type);
        mesh.material.needsUpdate = true;
      };

      try{
        Object.values(Store.getState().arrays||{}).forEach(arr=>{
          Object.values(arr.chunks||{}).forEach(ch=>{
            assign(ch.meshLOD1, 'filled');
            assign(ch.meshGhost, 'ghost');
            if(ch.meshLOD2) assign(ch.meshLOD2, 'filled');
          });
        });
      }catch{}

      try{
        layerMeshes.forEach(rec=>{
          const mesh = rec?.mesh;
          if(!mesh) return;
          if(mesh.userData?.isGhost) return;
          const base = mesh.userData?.type || 'filled';
          const want = String(base).startsWith('ghost') ? 'ghost' : base;
          assign(mesh, want);
        });
      }catch{}
      try{ chunkMeshes.forEach(mesh=> assign(mesh, 'filled')); }catch{}

      oldMaterials.forEach(mat=>{ try{ mat?.dispose?.(); }catch{} });
      rebuildCellMaterialRefs();
      updateShellVisibilityGlobal();
      needsRender = true;
    }catch(e){ console.warn('refreshCellMaterials failed', e); }
  }
  
  // Debounced collider rebuilds
  const colliderRebuildQueue = new Map(); // arrayId -> timeout
  
  // Animation and physics guards
  let isAnimating = false;
  let physicsStepping = false;
  let __rafId = 0, __animating = false;
  // Value sprites for per-cell text labels (declared earlier in Scene scope)
  function startLoop(){ if(__animating) return; __animating = true; __rafId = requestAnimationFrame(animate); }
  function stopLoop(){ if(!__animating) return; cancelAnimationFrame(__rafId); __animating = false; }
  // Global map for value label sprites (persist across rebuilds)
  window.valueSprites = window.valueSprites || new Map();
  const valueSprites = window.valueSprites;
  window.cellLights = window.cellLights || new Map();
  const cellLights = window.cellLights;
  window.cellLightTargets = window.cellLightTargets || new Map();
  const cellLightTargets = window.cellLightTargets;
  const LIGHT_GLOW_GEOMETRY = new THREE.SphereGeometry(0.42, 20, 20);
  let lastCamSig = '';
  const SPRITE_FACE_OFFSET = 0.58; // push label fully outside cell face (avoid z-fight/inside look)
  function axisCharToNum(ch){ return ch==='X'?0 : ch==='Y'?1 : 2; }
  function getPreferredFacing(arr){
    // Prefer occlusion axis for consistency with d-pad/occlusion; fallback to camera-facing state
    let axisNum = null;
    const oc = arr?._occlusionData || {};
    if(oc && (oc.facing || oc.axis)){
      const ch = oc.facing || oc.axis; // may be 'X'|'Y'|'Z'
      if(typeof ch === 'string') axisNum = axisCharToNum(ch);
      else if(typeof ch === 'number') axisNum = ch|0;
    }
    try{ updateFacingState(arr); }catch{}
    const st = arr._facingState || {axis:(axisNum??2), sign:1};
    if(axisNum==null) axisNum = st.axis;
    const sign = (st.sign||1) >= 0 ? 1 : -1;
    return { axis: axisNum, sign };
  }
  function camSig(){ try{ const p=camera?.position||{x:0,y:0,z:0}; const t=controls?.target||{x:0,y:0,z:0}; return `${p.x.toFixed(2)},${p.y.toFixed(2)},${p.z.toFixed(2)}|${t.x.toFixed(2)},${t.y.toFixed(2)},${t.z.toFixed(2)}`; }catch{ return ''; } }
  function maybeUpdateLabels(){ const sig=camSig(); if(sig===lastCamSig) return; lastCamSig=sig; try{ const arrays=Object.values(Store.getState().arrays); for(const arr of arrays){ if(!arr.hidden && arr._frame){ updateArrayLabelPlacement(arr); updateArrayValueSpritePlacement(arr); } } }catch{} }
  // Reposition value sprites on camera-facing changes as well, per array
  function updateArrayValueSpritePlacement(arr){
    try{
      if(!arr || !arr._frame) return;
      // Use the same face as occlusion/arrow mapping for consistency
      const face = getPreferredFacing(arr);
      const sign = face.sign;
      const off = SPRITE_FACE_OFFSET * sign;
      // Iterate value sprites for this array only
      valueSprites.forEach((sprite, key)=>{
        if(!String(key).startsWith(`${arr.id}:`)) return;
        const parts = String(key).split(':'); const coords = parts[1]||'';
        const [sx, sy, sz] = coords.split(',').map(Number);
        const base = localPos(arr, sx, sy, sz);
        let dx=0, dy=0, dz=0;
        if(face.axis===2){ dz = off; }
        else if(face.axis===0){ dx = off; }
        else { dy = off; }
        sprite.position.set(base.x+dx, base.y+dy, base.z+dz);
        // Ensure sprite is visible when repositioned; occlusion masking will hide if blocked
      sprite.visible = true;
    });
    }catch{}
  }

  function lightKey(ref){ if(!ref) return ''; return `${ref.arrId}:${ref.x},${ref.y},${ref.z}`; }
  function untrackLightTarget(key, targetRef){
    if(!targetRef) return;
    const set = cellLightTargets.get(targetRef.arrId);
    if(set){ set.delete(key); if(set.size===0) cellLightTargets.delete(targetRef.arrId); }
  }
  function trackLightTarget(key, targetRef){
    if(!targetRef) return;
    let set = cellLightTargets.get(targetRef.arrId);
    if(!set){ set = new Set(); cellLightTargets.set(targetRef.arrId, set); }
    set.add(key);
  }
  function ensureLightInstance(record){
    if(!record) return;
    const wantSpot = record.config?.mode === 'spot';
    const haveSpot = !!record.light?.isSpotLight;
    if(!record.light || wantSpot !== haveSpot){
      if(record.light){ record.group.remove(record.light); }
      if(record.target){ record.group.remove(record.target); record.target = null; }
      if(wantSpot){
        const spot = new THREE.SpotLight(0xffffff, 1, 24, Math.PI/4, 0.35, 2.0);
        spot.castShadow = false;
        const target = new THREE.Object3D();
        record.group.add(spot);
        record.group.add(target);
        spot.target = target;
        record.light = spot;
        record.target = target;
      } else {
        const point = new THREE.PointLight(0xffffff, 1, 18, 2);
        point.castShadow = false;
        record.group.add(point);
        record.light = point;
        record.target = null;
      }
    }
    if(!record.glow){
      const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending });
      const glow = new THREE.Mesh(LIGHT_GLOW_GEOMETRY, glowMat);
      glow.renderOrder = 1998;
      record.group.add(glow);
      record.glow = glow;
    }
  }
  function attachLightToArray(record){
    if(!record) return;
    const arr = Store.getState().arrays[record.source.arrId];
    if(!arr) return;
    const local = localPos(arr, record.source.x, record.source.y, record.source.z);
    if(arr._frame){
      if(record.group.parent !== arr._frame){
        record.group.parent?.remove(record.group);
        arr._frame.add(record.group);
      }
      record.group.position.copy(local);
    } else {
      const world = cellWorldPos(arr, record.source.x, record.source.y, record.source.z);
      if(record.group.parent !== scene){
        record.group.parent?.remove(record.group);
        scene.add(record.group);
      }
      record.group.position.copy(world);
    }
  }
  function updateLightTarget(record){
    if(!record?.light?.isSpotLight) return;
    const arr = Store.getState().arrays[record.source.arrId];
    if(!arr) return;
    const originWorld = cellWorldPos(arr, record.source.x, record.source.y, record.source.z);
    let dir = new THREE.Vector3(0,-1,0);
    const targetRef = record.config?.targetRef;
    if(targetRef){
      const tgtArr = Store.getState().arrays[targetRef.arrId];
      if(tgtArr){
        const targetWorld = cellWorldPos(tgtArr, targetRef.x, targetRef.y, targetRef.z);
        dir = targetWorld.clone().sub(originWorld);
      }
    }
    if(dir.lengthSq() < 1e-6) dir.set(0,-1,0);
    dir.normalize();
    if(arr._frame){
      const inv = new THREE.Matrix3().setFromMatrix4(new THREE.Matrix4().copy(arr._frame.matrixWorld).invert());
      dir.applyMatrix3(inv).normalize();
    }
    const range = record.config?.beamLength ?? 4.5;
    if(record.target){ record.target.position.copy(dir.clone().multiplyScalar(range)); }
  }
  function updateLightProperties(record){
    if(!record?.light) return;
    const lumens = Math.max(0, Number(record.config?.lumens ?? 0));
    const intensity = lumens <= 0 ? 0 : Math.max(0.1, lumens / 800);
    const distance = record.config?.distance ?? (lumens <= 0 ? 0 : Math.min(60, 8 + Math.sqrt(lumens||0) * 0.18));
    const color = record.config?.color || '#ffffff';
    try{ record.light.color.set(color); }catch{ record.light.color.set(0xffffff); }
    record.light.intensity = intensity;
    record.light.distance = distance;
    record.light.decay = 2;
    if(record.glow && record.glow.material){
      try{ record.glow.material.color.set(color); }catch{}
      const scale = Math.max(0.22, 0.34 + Math.sqrt(Math.max(lumens,0)) * 0.045);
      record.glow.scale.setScalar(scale);
      record.glow.material.opacity = lumens <= 0 ? 0 : Math.min(1, 0.28 + Math.sqrt(lumens) * 0.018);
      record.glow.visible = lumens > 0;
      record.glow.material.needsUpdate = true;
    }
    if(record.light.isSpotLight){
      record.light.angle = record.config?.angle ?? (Math.PI/5);
      record.light.penumbra = record.config?.penumbra ?? 0.4;
      updateLightTarget(record);
    }
  }
  function removeCellLight(ref){
    const key = typeof ref === 'string' ? ref : lightKey(ref);
    if(!key) return;
    const record = cellLights.get(key);
    if(!record) return;
    if(record.config?.targetRef) untrackLightTarget(key, record.config.targetRef);
    try{ record.glow?.material?.dispose?.(); }catch{}
    try{ record.group?.parent?.remove(record.group); }catch{}
    cellLights.delete(key);
    needsRender = true;
  }
  function upsertCellLight(ref, config){
    if(!ref) return null;
    const arr = Store.getState().arrays[ref.arrId];
    if(!arr) return null;
    const key = lightKey(ref);
    if(!config || !config.enabled || (config.lumens!=null && config.lumens<=0)){
      removeCellLight(key);
      return null;
    }
    let record = cellLights.get(key);
    if(!record){
      record = { source:{...ref}, config:{}, group:new THREE.Group(), light:null, target:null };
      record.group.userData.kind = 'cellLight';
      cellLights.set(key, record);
    }
    if(record.config?.targetRef) untrackLightTarget(key, record.config.targetRef);
    record.source = {...ref};
    record.config = { ...config };
    if(config.targetRef) trackLightTarget(key, config.targetRef);
    ensureLightInstance(record);
    attachLightToArray(record);
    updateLightProperties(record);
    needsRender = true;
    return record;
  }
  function refreshLightsForArray(arrId){
    cellLights.forEach((record)=>{
      if(record.source?.arrId === arrId || record.config?.targetRef?.arrId === arrId){
        attachLightToArray(record);
        updateLightProperties(record);
      }
    });
  }
  function clearOcclusion(arr){ try{ if(arr){ delete arr._occlusionData; } }catch{} }
  let lastFocusedArrayId = null;

  function setupRenderer(){
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = false;
    renderer.setClearColor(0xf6f7fb, 1);
    renderer.autoClear = true;
    renderer.autoClearStencil = true;
    renderer.localClippingEnabled = true;
  }
  function setupLighting(){
    // Clear existing lights
    const lightsToRemove = [];
    scene.traverse(obj => {
      if(obj.isLight) lightsToRemove.push(obj);
    });
    lightsToRemove.forEach(light => scene.remove(light));
    // Simple lighting (kept minimal and clean)
    scene.add(new THREE.AmbientLight(0xffffff,0.7));
    const hemi=new THREE.HemisphereLight(0xffffff,0x8899aa,0.7); scene.add(hemi);
    const dir=new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(8,12,6); dir.castShadow=false; scene.add(dir);
  }
  // Settings UI removed
  async function init(canvas){
    renderer=new THREE.WebGLRenderer({canvas, antialias:true, stencil:true});
    renderer.setPixelRatio(Math.min(2,window.devicePixelRatio||1));
    renderer.setSize(window.innerWidth,window.innerHeight);
    
    // Configure renderer based on mode
    setupRenderer();

    scene=new THREE.Scene();
    camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,.1,2000);
    camera.position.set(10,8,13);
    controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true;
    try{ controls.addEventListener('change', ()=>{
      try{
        const S=Store.getState(); const sel=S.selection;
        // Recompute placement for all visible arrays so sprites are always present on the facing side
        Object.values(S.arrays||{}).forEach(a=>{ if(!a.hidden && a._frame){ try{ updateArrayValueSpritePlacement(a); }catch{} } });
        if(sel?.arrayId){
          const arr=S.arrays[sel.arrayId];
          applyCutaway(arr, sel.focus);
        }
      }catch{}
      needsRender = true;
    }); }catch{}

    // Setup lighting and environment
    setupLighting();

    // Apply theme colors as CSS variables for unified styling
    try{
      const styleEl = document.createElement('style');
      const cssVars = Object.entries(COLORS)
        .map(([name, value]) => {
          const colorStr = typeof value === 'number' ? `#${value.toString(16).padStart(6, '0')}` : value;
          return `--clr-${name}: ${colorStr};`;
        })
        .join('\n');
      styleEl.textContent = `:root { ${cssVars} }`;
      document.head.appendChild(styleEl);
    }catch{}

    grid=new THREE.GridHelper(80,80,0x9aa1b5,0xe6e8ef); grid.position.y=-0.49; scene.add(grid);
    axesHelper=new THREE.AxesHelper(6); scene.add(axesHelper);

    scene.add(focusMarker); focusMarker.visible=false;
    // Dependency overlay group
    depGroup = new THREE.Group(); depGroup.visible=false; depGroup.userData.kind='depGroup'; scene.add(depGroup);
    initAvatars();

    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
      updateFancyComposerSize();
    });
    renderer.domElement.addEventListener('pointerdown', onPick);
    // 3D hover sync: highlight cell under cursor
    renderer.domElement.addEventListener('pointermove', (e)=>{
      try{
        const rect=renderer.domElement.getBoundingClientRect();
        const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
        const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
        const pickMeshes=[];
        try{ Object.values(Store.getState().arrays).forEach(a=>{ if(a.hidden) return; Object.values(a.chunks||{}).forEach(ch=>{ if(ch?.meshLOD1 && ch.meshLOD1.visible) pickMeshes.push(ch.meshLOD1); }); }); }catch{}
        const hits=ray.intersectObjects(pickMeshes,false);
        if(hits.length){
          const h=hits[0];
          const ch=h.object?.userData?.chunk; const arr=ch?.array; const cell = ch?.index2cell?.[h.instanceId];
          if(arr && cell){ setHoverCell({arrId:arr.id, x:cell.x, y:cell.y, z:cell.z}); return; }
        }
        clearHoverCell();
      }catch{}
    });
    // Ensure double click in 3D opens editor for the focused cell as well
    renderer.domElement.addEventListener('dblclick', (e)=>{
      try{
        const s=Store.getState().selection; if(!s?.arrayId||!s.focus) return;
        // Mark last interaction as 3d to place editor properly
        Store.setState(st=>({ ui:{...st.ui, lastInteraction:'3d'} }));
        window.UI?.openEditor?.();
      }catch{}
    });
    // Arrow/WASD movement is now handled in the physics loop to avoid aliasing
    // This old handler is disabled to prevent Rapier conflicts

    try{
      await loadRapier();
      if(RAP_READY){
      await RAPIER.init();
      rapierWorld=new RAPIER.World({x:0,y:-9.81,z:0});
        const rb=RAPIER.RigidBodyDesc.kinematicPositionBased();
        rb.setTranslation(0,2,0);
      playerBody=rapierWorld.createRigidBody(rb);
        playerCollider=rapierWorld.createCollider(RAPIER.ColliderDesc.capsule(.5,.35), playerBody);
        // Remove character controller - use simple kinematic movement
        controller = null;
        // Initialize cached player position
        cachedPlayerPos.set(0, 2, 0);
        document.getElementById('physChip').textContent='Physics: ON (Simple)';
        // Center camera on player start
        controls.target.set(cachedPlayerPos.x, cachedPlayerPos.y, cachedPlayerPos.z);
        camera.position.set(cachedPlayerPos.x+6, cachedPlayerPos.y+4, cachedPlayerPos.z+8);
      } else {
        document.getElementById('physChip').textContent='Physics: OFF (unavailable)';
      }
    }catch(e){ document.getElementById('physChip').textContent='Physics: OFF (error)'; console.warn('Rapier failed; continuing without physics', e); }

    // Settings and render-order debug UI removed

    if(!isAnimating){ isAnimating = true; needsRender = true; startLoop(); }
    // Rehydrate: render all current arrays immediately after init
    try{ Object.values(Store.getState().arrays).forEach(a=> Scene.renderArray(a)); }catch{}
    // Enforce default render orders and hydrate meshes/sprites once after all meshes exist
    try{ forceRenderOrderRefresh(); hydrateAll(); }catch{}
    // Apply current view mode once on init (ensures hideEmpty mask engages on boot)
    try{ const cur=(Store.getState().ui&&Store.getState().ui.viewMode)||'standard'; Scene.applyViewMode?.(cur); }catch{}
    // Ensure the first frame renders even if nothing changes immediately after init
    try{ if(typeof window.__RENDER_READY==='undefined'){ renderer.render(scene, camera); window.__RENDER_READY = true; } }catch{}
  }
  // Camera persistence helpers
  function captureCamera(){
    try{
      return {
        pos: (camera?.position?.toArray?.() || [10,8,13]),
        target: (controls?.target?.toArray?.() || [0,0,0]),
        fov: camera?.fov || 60,
        type: camera?.isPerspectiveCamera ? 'perspective' : 'orthographic'
      };
    }catch{ return null; }
  }
  function restoreCamera(s){
    if(!s) return;
    try{
      camera.position.fromArray(s.pos||[10,8,13]);
      controls.target.fromArray(s.target||[0,0,0]);
      if (s.fov) { camera.fov = +s.fov; camera.updateProjectionMatrix(); }
    }catch{}
  }
  
  function worldPos(arr,x,y,z){
    const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
    const base = new THREE.Vector3(
      x - X/2 + .5,
      (Y - 1 - y) - Y/2 + .5,  // Y flipped: y=0 is top, increases downward
      (Z - 1 - z) - Z/2 + .5   // Z front→back with α at front (near camera)
    );
    const off = arr.offset||{x:0,y:0,z:0};
    base.x += off.x; base.y += off.y; base.z += off.z;
    return base;
  }
  function localPos(arr,x,y,z){
    const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
    return new THREE.Vector3(
      x - X/2 + .5,
      (Y - 1 - y) - Y/2 + .5,
      (Z - 1 - z) - Z/2 + .5
    );
  }
  // GPU-first two-pass materials with local clipping planes
  function makeCellMaterials(){
    const solid = createCellMaterial('filled');
    const ghost = createCellMaterial('ghost');
    return { solid, ghost };
  }

  // Extruded shell material for outlines (view-agnostic)
  function makeShellMaterial({ color = 0x9aa0a6, opacity = 0.15, thickness = 0.06 } = {}){
    const mat = new THREE.MeshBasicMaterial({
      color, transparent: true, opacity,
      side: THREE.BackSide,
      // Respect scene depth so distant shells cannot overdraw closer solids
      depthTest: true,
      depthWrite: false,
      toneMapped: false,
      vertexColors: true,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1
    });
    mat.onBeforeCompile = (shader)=>{
      shader.uniforms.uThick = { value: thickness };
      shader.vertexShader = shader.vertexShader.replace(
        'vec3 transformed = position;',
        'uniform float uThick; vec3 transformed = position + normal * uThick;'
      );
    };
    return mat;
  }

  // Whole-array highlight shell (single filled shell around the entire array)
  function ensureArrayHighlightShell(arr){
    try{
      const want = { x:arr.size.x, y:arr.size.y, z:arr.size.z };
      const rebuild = !arr._arrayShell || !arr._arrayShell.userData ||
        arr._arrayShell.userData.sx!==want.x || arr._arrayShell.userData.sy!==want.y || arr._arrayShell.userData.sz!==want.z;
      if(rebuild){
        // Dispose old
        try{ if(arr._arrayShell){ arr._arrayShell.parent?.remove(arr._arrayShell); arr._arrayShell.traverse(n=>{ try{ n.geometry?.dispose?.(); n.material?.dispose?.(); }catch{} }); } }catch{}
        const group = new THREE.Group();
        group.userData = { sx:want.x, sy:want.y, sz:want.z };
        // Outer backface shell: reach mid-gap between arrays (±0.5 beyond faces)
        const geoOuter = new RoundedBoxGeometry(
          arr.size.x + 1.20,
          arr.size.y + 1.20,
          arr.size.z + 1.20,
          3, 0.20
        );
        const matOuter = new THREE.MeshBasicMaterial({
          color: 0x3b82f6,
          transparent: true,
          opacity: 0.30,
          side: THREE.BackSide,
          depthTest: true,
          depthWrite: false,
          toneMapped: false,
          // Do not write color on the inner-facing pixels; rely on stencil to create pass-through
          colorWrite: true
        });
        // Stencil: draw shell only where inner did NOT write stencil
        matOuter.stencilWrite = true;
        matOuter.stencilFunc = THREE.NotEqualStencilFunc;
        matOuter.stencilRef = 1;
        matOuter.stencilZPass = THREE.KeepStencilOp;
        matOuter.stencilZFail = THREE.KeepStencilOp;
        matOuter.stencilFail = THREE.KeepStencilOp;
        const outer = new THREE.Mesh(geoOuter, matOuter);
        outer.renderOrder = window.__RO.frameShell|0; // frame shell above core but behind per-cell
        group.add(outer);
        // Inner fill: invisible, seeds stencil; draw very early
        // Inner fill slightly smaller than outer so outer remains as outline
        const geoInner = new RoundedBoxGeometry(
          arr.size.x + 0.96,
          arr.size.y + 0.96,
          arr.size.z + 0.96,
          3, 0.18
        );
        const matInner = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: false, // treat as opaque so it renders in the opaque pass before transparent outer
          opacity: 0.0,     // fully invisible (colorWrite=false still ensures no color)
          side: THREE.FrontSide,
          depthTest: true,
          depthWrite: false,
          toneMapped: false,
          colorWrite: false
        });
        // Stencil: mark interior with ref=1 so shell ignores it (pass-through window)
        matInner.stencilWrite = true;
        matInner.stencilFunc = THREE.AlwaysStencilFunc;
        matInner.stencilRef = 1;
        matInner.stencilZPass = THREE.ReplaceStencilOp;
        matInner.stencilZFail = THREE.ReplaceStencilOp;
        matInner.stencilFail = THREE.ReplaceStencilOp;
        const inner = new THREE.Mesh(geoInner, matInner);
        inner.renderOrder = window.__RO.frameCore|0; // draw before frame shell
        group.add(inner);
        // If frame exists, parent shell to frame; otherwise enqueue after first renderArray
        if(arr._frame) arr._frame.add(group); else scene.add(group);
        arr._arrayShell = group;
      }
    }catch{}
    // Ensure visibility matches array state immediately
    try{ if(arr._arrayShell) arr._arrayShell.visible = !arr.hidden; }catch{}
    return arr._arrayShell;
  }

  function viewAxisForArray(frame, observerPos){
    try{
      const camPos = observerPos ? observerPos.clone() : camera.position.clone();
      const arrPos = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
      const dirWorld = camPos.sub(arrPos).normalize();
      const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
      const dirLocal = dirWorld.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
      const ax=Math.abs(dirLocal.x), ay=Math.abs(dirLocal.y), az=Math.abs(dirLocal.z);
      let axis=0, sign=Math.sign(dirLocal.x)||1; if(ay>ax && ay>az){ axis=1; sign=Math.sign(dirLocal.y)||1; } else if(az>ax && az>ay){ axis=2; sign=Math.sign(dirLocal.z)||1; }
      return {axis, sign};
    }catch{ return {axis:2, sign:1}; }
  }

  // Camera-facing helpers with hysteresis to stabilize axis/sign and head-on
  function facingFromCamera(frame){
    try{
      const cam = camera.position.clone();
      const arrWorld = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
      const toCamWorld = cam.sub(arrWorld).normalize();
      const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
      const toCamLocal = toCamWorld.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
      const ax=Math.abs(toCamLocal.x), ay=Math.abs(toCamLocal.y), az=Math.abs(toCamLocal.z);
      let axis=0, sign=Math.sign(toCamLocal.x)||1, majorMag=ax;
      if(ay>majorMag){ axis=1; sign=Math.sign(toCamLocal.y)||1; majorMag=ay; }
      if(az>majorMag){ axis=2; sign=Math.sign(toCamLocal.z)||1; majorMag=az; }
      return { axis, sign, majorMag, dirLocal: toCamLocal };
    }catch{ return { axis:2, sign:1, majorMag:1, dirLocal:new THREE.Vector3(0,0,1) }; }
  }

  function updateFacingState(arr){
    if(!arr || !arr._frame) return;
    const vs = facingFromCamera(arr._frame);
    const AXIS_DELTA=0.05, ENTER_HEAD=0.94, EXIT_HEAD=0.90;
    const prev = arr._facingState || { axis:vs.axis, sign:vs.sign, mag:vs.majorMag };
    const axisChanged = (vs.axis!==prev.axis) && (vs.majorMag > Math.max(prev.mag + AXIS_DELTA, 0.80));
    const signChanged = (vs.sign!==prev.sign) && (vs.majorMag > 0.60);
    const axis = axisChanged ? vs.axis : prev.axis;
    const sign = signChanged ? vs.sign : prev.sign;
    const mag  = axisChanged ? vs.majorMag : Math.max(prev.mag*0.9, vs.majorMag);
    const prevHead = !!arr._headOnMajor;
    const nowHead  = prevHead ? (mag > EXIT_HEAD) : (mag > ENTER_HEAD);
    arr._facingState = { axis, sign, mag };
    arr._headOnMajor = nowHead;
    arr._headOnZ = (axis===2) && nowHead;
  }

  function computeOcclusion(arr, selection){
    if(!arr || !selection) return;
    // Determine dominant axis from camera direction relative to array frame
    try{
      const inv = new THREE.Matrix4().copy(arr._frame.matrixWorld).invert();
      const camDirW = camera.position.clone().sub(arr._frame.getWorldPosition(new THREE.Vector3())).normalize();
      const camDirL = camDirW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
      const ax=Math.abs(camDirL.x), ay=Math.abs(camDirL.y), az=Math.abs(camDirL.z);
      let axis='Z', sign=1, frontLayer=0, focusLayer=0;
      if(ay>ax && ay>az){ axis='Y'; sign=Math.sign(camDirL.y)||1; frontLayer = (sign>0) ? 0 : (arr.size.y-1); focusLayer = selection.y; }
      else if(ax>ay && ax>az){ axis='X'; sign=Math.sign(camDirL.x)||1; frontLayer = (sign>0) ? (arr.size.x-1) : 0; focusLayer = selection.x; }
      else { axis='Z'; sign=Math.sign(camDirL.z)||1; frontLayer = (sign>0) ? 0 : (arr.size.z-1); focusLayer = selection.z; }
      const blockedLayers = new Set();
      if(frontLayer < focusLayer){ for(let L=frontLayer; L<focusLayer; L++) blockedLayers.add(L); }
      else { for(let L=frontLayer; L>focusLayer; L--) blockedLayers.add(L); }
      arr._occlusionData = { axis, sign, frontLayer, focusLayer, blockedLayers };
    }catch{
      arr._occlusionData = { axis:'Z', sign:1, frontLayer:0, focusLayer:selection.z, blockedLayers:new Set() };
    }
  }

  function cutPlaneFromCamera(frame, sel, arr){
    try{
      const st = arr? (arr._facingState||{axis:2,sign:1}) : {axis:2,sign:1};
      const axis=st.axis, sign=st.sign;
      const cellSize=1;
      const c = new THREE.Vector3( (sel.x+0.5)*cellSize, (sel.y+0.5)*cellSize, (sel.z+0.5)*cellSize );
      if(axis===0) c.x += 0.5*sign*cellSize;
      if(axis===1) c.y += 0.5*sign*cellSize;
      if(axis===2) c.z += 0.5*sign*cellSize;
      const nL = new THREE.Vector3(axis===0?sign:0, axis===1?sign:0, axis===2?sign:0).normalize();
      const nW = nL.clone().applyQuaternion(frame.getWorldQuaternion(new THREE.Quaternion())).normalize();
      const pW = frame.localToWorld(c);
      return new THREE.Plane().setFromNormalAndCoplanarPoint(nW, pW);
    }catch{ return new THREE.Plane(new THREE.Vector3(0,0,1), 0); }
  }

  function cutPlaneFor(arrayFrame, sel, cellSize = 1){
    try{
      // camera dir in array local space
      const inv = new THREE.Matrix4().copy(arrayFrame.matrixWorld).invert();
      const camDirW = camera.position.clone().sub(arrayFrame.getWorldPosition(new THREE.Vector3())).normalize();
      const camDirL = camDirW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
      // dominant axis + sign
      const ax = Math.abs(camDirL.x), ay = Math.abs(camDirL.y), az = Math.abs(camDirL.z);
      let axis=0, sign=Math.sign(camDirL.x)||1;
      if(ay>ax && ay>az){ axis=1; sign=Math.sign(camDirL.y)||1; }
      else if(az>ax && az>ay){ axis=2; sign=Math.sign(camDirL.z)||1; }
      // face center of selected cell toward camera
      const c = new THREE.Vector3(
        (sel.x + 0.5) * cellSize,
        (sel.y + 0.5) * cellSize,
        (sel.z + 0.5) * cellSize
      );
      if(axis===0) c.x += 0.5 * sign * cellSize;
      if(axis===1) c.y += 0.5 * sign * cellSize;
      if(axis===2) c.z += 0.5 * sign * cellSize;
      // local normal → world normal
      const nL = new THREE.Vector3(axis===0?sign:0, axis===1?sign:0, axis===2?sign:0).normalize();
      const nW = nL.clone().applyQuaternion(arrayFrame.getWorldQuaternion(new THREE.Quaternion())).normalize();
      const pW = arrayFrame.localToWorld(c);
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(nW, pW);
      return plane;
    }catch{ return new THREE.Plane(new THREE.Vector3(0,0,1), 0); }
  }

  function applyCutaway(arr, sel){
    if(!arr || !arr._cellMaterials || !arr._frame || !sel) return;
    // In chunk mode, rely solely on per-instance ghost/solid masking; disable material clipping
    if(Scene.ChunkManager && Scene.ChunkManager.enabled){
      try{ arr._cellMaterials.forEach(m=>{ if(m) m.clippingPlanes = null; }); }catch{}
      // In hideEmpty mode, enforce mask instead of occlusion
      try{
        const mode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
        if(mode==='hideEmpty'){ applyHideEmptyMask(arr); }
      }catch{}
      return;
    }
    try{
      const plane = cutPlaneFromCamera(arr._frame, sel, arr);
      // FRONT (toward camera) → GHOST, BACK (selected+behind) → SOLID
      arr._cellMaterials.forEach(mat=>{
        if(mat.userData.pass === 'ghost'){
          mat.clippingPlanes = [ plane.clone() ];
        } else if(mat.userData.pass === 'solid'){
          mat.clippingPlanes = [ plane.clone().negate() ];
        }
      });
      needsRender = true;
    }catch{}
  }

  // Live color update for a single cell without a full rebuild
  function updateCellColor(arrayId, coord){
    try{
      const arr = Store.getState().arrays[arrayId]; if(!arr) return;
      const cell = getCellFast(arrayId, coord);
      const key = `${arrayId}:${coord.x},${coord.y},${coord.z}`;
      const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
      const isFormula = !!cell.formula;
      const custom = cell?.meta?.color;
      const hasValue = (cell.value!=='' && cell.value!==null && cell.value!==undefined);
      let hex;
      if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
      const col = new THREE.Color(custom || hex); col.convertSRGBToLinear();
      // Update pooled LOD1
      try{
        const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))];
        const mesh = ch?.meshLOD1; const map = ch?.index2cell; const gmesh = ch?.meshGhost; const smesh = ch?.meshShell;
        if(map){
          const idx = map.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
          if(idx>=0){
            if(mesh){ mesh.setColorAt(idx, col); if(mesh.instanceColor) mesh.instanceColor.needsUpdate = true; mesh.visible = true; }
            if(gmesh){ gmesh.setColorAt(idx, col); if(gmesh.instanceColor) gmesh.instanceColor.needsUpdate = true; }
            if(smesh){ const scol = col.clone(); scol.offsetHSL(0,0,-0.22); if(smesh.instanceColor){ smesh.setColorAt(idx, scol); smesh.instanceColor.needsUpdate = true; } }
          }
        }
      }catch{}
      // Update legacy layer meshes
      try{
        const z = coord.z|0; const types=['empty','filled','formula','ghost'];
        for(const t of types){
          const rec = layerMeshes.get(`${arrayId}:${z}:${t}`);
          if(!rec||!rec.mesh||!rec.index2cell) continue;
          const i = rec.index2cell.findIndex(c=>c && c.x===coord.x && c.y===coord.y && c.z===coord.z);
          if(i>=0){ try{ rec.mesh.setColorAt(i, col); }catch{} if(rec.mesh.instanceColor) rec.mesh.instanceColor.needsUpdate = true; }
        }
      }catch{}
      try{ renderer?.state?.reset?.(); }catch{}
      needsRender = true;
    }catch{}
  }

  // Rehydrate an entire chunk's instances from current cell state
  function rehydrateChunkInstances(arr, ch){
    try{
      if(!ch) return;
      ch.ensureMesh?.();
      const meshSolid = ch.meshLOD1; const meshGhost = ch.meshGhost; const meshShell = ch.meshShell;
      if(!meshSolid) return;
      const list = ch.index2cell || ch.cells || [];
      const viewModeNow = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
      for(let i=0;i<list.length;i++){
        const c = list[i]; if(!c) continue;
        // transform
        const p = localPos(arr, c.x, c.y, c.z);
        temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(1,1,1); temp.updateMatrix();
        const M = temp.matrix;
        // In hideEmpty mode, zero-scale empty instances; otherwise set normal transform
        if(viewModeNow==='hideEmpty'){
          const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
          const isFormula = !!fresh.formula;
          const hasValue = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
          const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
          const show = isFormula || hasValue || emitted;
          if(show){
        meshSolid.setMatrixAt(i, M);
        if(meshShell) meshShell.setMatrixAt(i, M);
          } else {
            tempM.identity(); tempM.makeScale(0,0,0);
            meshSolid.setMatrixAt(i, tempM);
            if(meshShell) meshShell.setMatrixAt(i, tempM);
          }
        } else {
          meshSolid.setMatrixAt(i, M);
          if(meshShell) meshShell.setMatrixAt(i, M);
        }
        // ghosts start hidden until occlusion applies
        if(meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); meshGhost.setMatrixAt(i, tempM); }
        // colors
        try{
          const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
          const isFormula = !!fresh.formula;
          const hasValue = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
          const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
          let hex; if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
          const col = new THREE.Color(hex).convertSRGBToLinear();
          meshSolid.setColorAt(i, col);
          if(meshGhost) meshGhost.setColorAt(i, col);
          if(meshShell){ const sc = col.clone(); sc.offsetHSL(0,0,-0.22); meshShell.setColorAt(i, sc); }
        }catch{}
      }
      meshSolid.count = list.length; meshSolid.instanceMatrix.needsUpdate = true; if(meshSolid.instanceColor) meshSolid.instanceColor.needsUpdate = true;
      if(meshGhost){ meshGhost.count = list.length; meshGhost.instanceMatrix.needsUpdate = true; if(meshGhost.instanceColor) meshGhost.instanceColor.needsUpdate = true; }
      if(meshShell){ meshShell.count = list.length; meshShell.instanceMatrix.needsUpdate = true; if(meshShell.instanceColor) meshShell.instanceColor.needsUpdate = true; }
    }catch{}
  }
  
  // Zero-scale chunk instances for blocked layers so ghosts replace solids when chunks are ON
  function applyGhostMaskToChunks(arr){
    try{
      if(!(Scene.ChunkManager && Scene.ChunkManager.enabled)) return;
      if(!arr || !arr.chunks) return;
      const occ = arr._occlusionData || {};
      const blocked = occ.blockedLayers || new Set();
      const axis = occ.axis || occ.facing || 'Z';
      // Determine focus layer from current selection for this array so it always renders as solid
      const sel = Store.getState().selection || {};
      const focusLayer = (sel.arrayId===arr.id && sel.focus) ? (axis==='X' ? sel.focus.x : axis==='Y' ? sel.focus.y : sel.focus.z) : null;
      Object.values(arr.chunks).forEach(ch=>{
        const meshSolid = ch.meshLOD1; const meshGhost = ch.meshGhost; const meshShell = ch.meshShell;
        if(!meshSolid || !ch.index2cell) return;
        let changedS=false, changedG=false, changedH=false;
        for(let i=0;i<ch.index2cell.length;i++){
          const c = ch.index2cell[i];
          const L = axis==='X' ? c.x : axis==='Y' ? c.y : c.z;
          const isFocus = (focusLayer===L);
          const isBlocked = blocked.has(L);
          // Build the canonical transform exactly once
          const p = localPos(arr,c.x,c.y,c.z);
          temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(1,1,1); temp.updateMatrix();
          const M = temp.matrix.clone();
          // Solid shows when NOT blocked. It also shows on the focus layer even if it would be considered blocked.
          const showSolid = (!isBlocked) || isFocus;
          if(showSolid){ meshSolid.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); meshSolid.setMatrixAt(i, tempM); }
          changedS=true;
          // Ghost shows when blocked AND not the focus layer (we still need a visible ghost when solid is hidden)
          const showGhost = isBlocked && !isFocus;
          if(meshGhost){ if(showGhost){ meshGhost.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); meshGhost.setMatrixAt(i, tempM); } changedG=true; }
          // Shell follows solids (hide when blocked unless focus). Larger GEO_SHELL gives visible outline.
          if(meshShell){
            if(showSolid){ meshShell.setMatrixAt(i, M); }
            else { tempM.identity(); tempM.makeScale(0,0,0); meshShell.setMatrixAt(i, tempM); }
            changedH=true;
          }
        }
        if(changedS) meshSolid.instanceMatrix.needsUpdate = true;
        if(changedG && meshGhost) meshGhost.instanceMatrix.needsUpdate = true;
        if(changedH && meshShell) meshShell.instanceMatrix.needsUpdate = true;
      });
      // Hide value sprites for blocked cells too in Standard mode; other modes leave sprites visible
      try{
        const mode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
        if(mode==='standard'){
        const vs = window.valueSprites || new Map();
        vs.forEach((sprite,key)=>{
          if(!String(key).startsWith(`${arr.id}:`)) return;
          const [,coords] = String(key).split(':');
          const [x,y,z] = coords.split(',').map(n=>+n);
          let blk=false;
            if(axis==='Z') blk = blocked.has(z);
            else if(axis==='X') blk = blocked.has(x);
            else blk = blocked.has(y);
          if(sprite) sprite.visible = !blk;
        });
        }
      }catch{}
    }catch(e){ console.warn('applyGhostMaskToChunks failed', e); }
  }

  // Hide-Empty: zero-scale all empty instances for an array
  function applyHideEmptyMask(arr){
    try{
      Object.values(arr.chunks||{}).forEach(ch=>{
        try{
          ch.ensureMesh?.(); ch.setLOD?.(1);
          if(!ch.index2cell) return;
          let changedS=false, changedH=false, changedG=false;
          for(let i=0;i<ch.index2cell.length;i++){
            const c = ch.index2cell[i]; if(!c) continue;
            const fresh = Formula.getCell({arrId:arr.id, x:c.x, y:c.y, z:c.z}) || {};
            const isFormula = !!fresh.formula;
            const hasVal = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
            const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(`${arr.id}:${c.x},${c.y},${c.z}`));
            const show = isFormula || hasVal || emitted;
            const p = localPos(arr,c.x,c.y,c.z);
            temp.position.copy(p); temp.rotation.set(0,0,0); temp.scale.set(1,1,1); temp.updateMatrix();
            const M = temp.matrix.clone();
            if(ch.meshLOD1){ if(show){ ch.meshLOD1.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); ch.meshLOD1.setMatrixAt(i, tempM); } changedS=true; }
            if(ch.meshShell){ if(show){ ch.meshShell.setMatrixAt(i, M); } else { tempM.identity(); tempM.makeScale(0,0,0); ch.meshShell.setMatrixAt(i, tempM); } changedH=true; }
            if(ch.meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); ch.meshGhost.setMatrixAt(i, tempM); changedG=true; }
          }
          if(changedS && ch.meshLOD1) ch.meshLOD1.instanceMatrix.needsUpdate=true;
          if(changedH && ch.meshShell) ch.meshShell.instanceMatrix.needsUpdate=true;
          if(changedG && ch.meshGhost) ch.meshGhost.instanceMatrix.needsUpdate=true;
        }catch{}
      });
      // Ensure sprites (which are created only for content) stay visible
      try{ valueSprites.forEach((sp,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sp.visible=true; }); }catch{}
    }catch{}
  }

  // Apply global 3D view mode across all arrays: 'standard' | 'solid' | 'hideEmpty'
  function applyViewMode(mode){
    try{
      const arrays = Object.values(Store.getState().arrays||{});
      if(mode==='solid'){
        arrays.forEach(arr=>{
          Object.values(arr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }catch{} });
          // Ensure all value sprites are visible; occlusion disabled in this mode
          try{ valueSprites.forEach((sp,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sp.visible=true; }); }catch{}
          // Clear occlusion data so animate doesn't reuse it
          try{ delete arr._occlusionData; }catch{}
        });
      } else if(mode==='hideEmpty'){
        arrays.forEach(arr=>{ try{ applyHideEmptyMask(arr); delete arr._occlusionData; }catch{} });
      } else { // standard
        arrays.forEach(arr=>{
          Object.values(arr.chunks||{}).forEach(ch=>{ try{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }catch{} });
        });
        const s = Store.getState().selection;
        if(s?.arrayId && s.focus){
          const arr = Store.getState().arrays[s.arrayId];
          try{ computeOcclusion(arr, s.focus); if(Scene.ChunkManager && Scene.ChunkManager.enabled){ applyGhostMaskToChunks(arr); } }catch{}
        }
      }
      needsRender = true;
    }catch{}
  }

  // Click pulse: scale both solid and shell at the same instance center
  function pulseCell(arr, cell, z){
    try{
      const useChunks = !!(Scene.ChunkManager && Scene.ChunkManager.enabled);
      const pos = localPos(arr, cell.x, cell.y, cell.z);
      const setScaleAt=(mesh, i, s)=>{
        if(!mesh || typeof i!=='number' || i<0) return;
        temp.position.copy(pos);
        temp.rotation.set(0,0,0);
        temp.scale.set(s,s,s);
        temp.updateMatrix();
        mesh.setMatrixAt(i, temp.matrix);
        mesh.instanceMatrix.needsUpdate = true;
      };
      let idx=-1; let ch=null;
      if(useChunks){
        ch = arr.chunks[keyChunk(...Object.values(chunkOf(cell.x,cell.y,cell.z)))] || null;
        if(ch && ch.index2cell){ idx = ch.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z); }
      }
      const start=performance.now(); const dur=180; const peak=1.10;
      const step=()=>{
        const t=Math.min(1, (performance.now()-start)/dur);
        const s = 1 + (peak-1) * (t<0.5 ? (t*2) : (2-2*t));
        if(useChunks && ch){ setScaleAt(ch.meshLOD1, idx, s); setScaleAt(ch.meshShell, idx, s); }
        // Also try legacy layer meshes (solids + edges) when chunks are off
        try{
          const types=['filled','formula'];
          for(const tp of types){
            const rec = layerMeshes.get(`${arr.id}:${z}:${tp}`);
            if(rec){
              const i = rec.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
              setScaleAt(rec.mesh, i, s);
            }
            const er = layerMeshes.get(`${arr.id}:${z}:${tp}:edges`);
            if(er){
              const i2 = er.index2cell.findIndex(c=>c && c.x===cell.x && c.y===cell.y && c.z===cell.z);
              setScaleAt(er.mesh, i2, s);
            }
          }
        }catch{}
        if(t<1){ requestAnimationFrame(step); }
      };
      requestAnimationFrame(step);
    }catch{}
  }
  // Fast cell accessor using chunk cellMap fallback to array scan
  function getCellFast(arrayId, coord){
    try{
      const arr = Store.getState().arrays[arrayId]; if(!arr) return {value:'',formula:null,meta:{}};
      const ch = arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return {value:'',formula:null,meta:{}};
      if(ch.cellMap){ const c = ch.cellMap.get(`${coord.x},${coord.y},${coord.z}`); return c || {value:'',formula:null,meta:{}}; }
      const c = ch.cells?.find?.(t=>t.x===coord.x&&t.y===coord.y&&t.z===coord.z);
      return c || {value:'',formula:null,meta:{}};
    }catch{ return {value:'',formula:null,meta:{}}; }
  }
  
  function pruneStaleChunkMeshes(arrayId){
    const arr = Store.getState().arrays[arrayId];
    if(!arr) return;
    const validKeys = new Set(Object.keys(arr.chunks).map(k => `${arrayId}:${k}`));
    for (const [key, m] of chunkMeshes) {
      if (m?.userData?.arrayId === arrayId && !validKeys.has(key)) {
        try {
          m.parent?.remove(m);
          m.geometry?.dispose?.();
          m.material?.dispose?.();
        } catch {}
        chunkMeshes.delete(key);
      }
    }
  }
  // --- Chunk module (Phase 0/1) ---
  class Chunk {
    constructor(array, chunkCoord){
      this.array = array;
      this.coord = { x: chunkCoord.x|0, y: chunkCoord.y|0, z: chunkCoord.z|0 };
      this.cells = [];
      this.cellMap = new Map(); // key: "x,y,z" -> cell
      this.currentLOD = -1; // -1=unloaded, 1=instanced, 2=greedy
      this.meshLOD1 = null; // InstancedMesh
      this.meshLOD2 = null; // Greedy merged mesh
      this._dirty = false;
    }
    markDirty(){ this._dirty = true; }
    unload(){
      try{
        if(this.meshLOD1){ this.meshLOD1.parent?.remove(this.meshLOD1); this.meshLOD1.geometry?.dispose?.(); this.meshLOD1.material?.dispose?.(); this.meshLOD1=null; }
        if(this.meshLOD2){ this.meshLOD2.parent?.remove(this.meshLOD2); this.meshLOD2.geometry?.dispose?.(); this.meshLOD2.material?.dispose?.(); this.meshLOD2=null; }
        if(this.meshGhost){ this.meshGhost.parent?.remove(this.meshGhost); this.meshGhost.geometry?.dispose?.(); this.meshGhost.material?.dispose?.(); this.meshGhost=null; }
        if(this.meshShell){ this.meshShell.parent?.remove(this.meshShell); this.meshShell.geometry?.dispose?.(); this.meshShell.material?.dispose?.(); this.meshShell=null; }
      }catch{}
      this.currentLOD = -1; this._dirty=false;
    }
    ensureMesh(){
      // Create/ensure twin instanced meshes (solid + ghost + shell) only once per chunk
      try{
        const maxInstances = Math.max(1, this.cells.length|0);
        if(!this.instancedMesh){
          const geo = GEO_VOXEL; // pooled
          addWhiteVertexColors(geo);
          const mats = makeCellMaterials();
          const shellMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.28,
            side: THREE.BackSide,
            depthTest: true,
            depthWrite: false,
            toneMapped: false,
            vertexColors: true
          });
          // Tag passes for unified clipping control
          mats.solid.userData = { ...(mats.solid.userData||{}), pass:'solid' };
          mats.ghost.userData = { ...(mats.ghost.userData||{}), pass:'ghost' };
          shellMat.userData   = { ...(shellMat.userData||{}),   pass:'shell' };
          const meshSolid = new THREE.InstancedMesh(geo, mats.solid, maxInstances);
          const meshGhost = new THREE.InstancedMesh(geo, mats.ghost, maxInstances);
          const meshShell = new THREE.InstancedMesh(GEO_SHELL, shellMat, maxInstances);
          const shadowsEnabled = FancyGraphics.enabled && FancyGraphics.settings.solidGround;
          meshSolid.castShadow = shadowsEnabled;
          meshGhost.castShadow = false;
          meshShell.castShadow = false;
          // Important for correct layering: ghosts first, then solids, then shells
          meshGhost.renderOrder = 1;
          meshSolid.renderOrder = 2;
          meshShell.renderOrder = 3;
          meshSolid.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
          meshGhost.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
          meshShell.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
          // Prevent culling from hiding outlines at shallow angles
          meshSolid.frustumCulled = false; meshGhost.frustumCulled = false; meshShell.frustumCulled = false;
          // Render order: frame(0) -> ghosts(1) -> solids(2) -> shells(3)
          // Drawing solids after ghosts guarantees fills are visible through low-opacity ghosts
          // Per-cell passes: keep in mid-range so frame UI can be drawn above
          meshGhost.renderOrder = window.__RO.ghostFill|0; 
          meshSolid.renderOrder = window.__RO.solidFill|0; 
          meshShell.renderOrder = window.__RO.solidShell|0;
          // Mark materials for cutaway
          mats.solid.userData.pass = 'solid';
          mats.ghost.userData.pass = 'ghost';
          // Allocate instanceColor buffers
          try{
            const colBufSolid = new Float32Array(maxInstances*3);
            const colBufGhost = new Float32Array(maxInstances*3);
            const colBufShell = new Float32Array(maxInstances*3);
            meshSolid.instanceColor = new THREE.InstancedBufferAttribute(colBufSolid, 3); meshSolid.instanceColor.setUsage(THREE.DynamicDrawUsage);
            meshGhost.instanceColor = new THREE.InstancedBufferAttribute(colBufGhost, 3); meshGhost.instanceColor.setUsage(THREE.DynamicDrawUsage);
            meshShell.instanceColor = new THREE.InstancedBufferAttribute(colBufShell, 3); meshShell.instanceColor.setUsage(THREE.DynamicDrawUsage);
          }catch{}
          // Parent under array frame when available
          if(this.array && this.array._frame){ this.array._frame.add(meshSolid); this.array._frame.add(meshGhost); this.array._frame.add(meshShell); } else { scene.add(meshSolid); scene.add(meshGhost); scene.add(meshShell); }
          // Expose for updates
          this.instancedMesh = meshSolid; // primary for solids
          this.meshLOD1 = meshSolid;
          this.meshGhost = meshGhost;
          this.meshShell = meshShell;
          const lod = (this.currentLOD == null || this.currentLOD < 0) ? 1 : this.currentLOD;
          this.meshShell.visible = !FancyGraphics.enabled && (lod === 1);
          // Use twin meshes for ghosting: solid shows unblocked, ghost shows blocked
          try{ this.meshGhost.visible = true; }catch{}
          // Tag for picking and ghost-mask application
          try{
            meshSolid.userData = { ...(meshSolid.userData||{}), arrayId:this.array.id, chunk:this };
            meshGhost.userData = { ...(meshGhost.userData||{}), arrayId:this.array.id, chunk:this };
            meshShell.userData = { ...(meshShell.userData||{}), arrayId:this.array.id, chunk:this };
          }catch{}
          // Stash materials for cutaway updates
          this.array._cellMaterials = this.array._cellMaterials || [];
          this.array._cellMaterials.push(mats.solid, mats.ghost);
        }

        // Stable index map: sort by z,y,x for deterministic ids
        const sorted = [...this.cells].sort((a,b)=> (a.z-b.z) || (a.y-b.y) || (a.x-b.x));
        this.index2cell = sorted; // expose for picking and ghost masking
        this.cellIndexMap = new Map();
        for(let i=0;i<sorted.length;i++){
          const c = sorted[i];
          this.cellIndexMap.set(`${c.x},${c.y},${c.z}`, i);
          // Initialize transform
          const p = localPos(this.array, c.x, c.y, c.z);
          temp.position.copy(p);
          temp.rotation.set(0,0,0);
          temp.scale.set(1,1,1);
          temp.updateMatrix();
          this.instancedMesh.setMatrixAt(i, temp.matrix);
          // Start ghosts hidden (zero scale) until occlusion mask applies
          if(this.meshGhost){ tempM.identity(); tempM.makeScale(0,0,0); this.meshGhost.setMatrixAt(i, tempM); }
          if(this.meshShell) this.meshShell.setMatrixAt(i, temp.matrix);
          // Initialize color (custom or type-based); linearized
          const key = `${this.array.id}:${c.x},${c.y},${c.z}`;
          const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
          const isFormula = !!c.formula;
          const custom = c?.meta?.color;
          const hasValue = (c.value!=='' && c.value!==null && c.value!==undefined);
          let hex;
          if(isFormula) hex = baseHexForTypeKey('formula'); else if(emitted) hex = baseHexForTypeKey('emitted'); else hex = hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
          const col = new THREE.Color(custom || hex);
          col.convertSRGBToLinear();
          try{
            this.instancedMesh.setColorAt(i, col);
            if(this.meshGhost) this.meshGhost.setColorAt(i, col);
            if(this.meshShell){ const sc = col.clone(); sc.offsetHSL(0,0,-0.22); this.meshShell.setColorAt(i, sc); }
          }catch{}
        }
        this.instancedMesh.count = sorted.length;
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        if(this.instancedMesh.instanceColor) this.instancedMesh.instanceColor.needsUpdate = true;
        if(this.meshGhost){ this.meshGhost.count = sorted.length; this.meshGhost.instanceMatrix.needsUpdate = true; if(this.meshGhost.instanceColor) this.meshGhost.instanceColor.needsUpdate = true; }
        if(this.meshShell){ this.meshShell.count = sorted.length; this.meshShell.instanceMatrix.needsUpdate = true; if(this.meshShell.instanceColor) this.meshShell.instanceColor.needsUpdate = true; }
        needsRender = true;
      }catch{}
      return this.instancedMesh;
    }
    buildMeshLOD1(){
      // Use ensureMesh for stable pooled instances
      this.ensureMesh();
      this._dirty = false;
    }
    buildMeshLOD2(){
      // Greedy mesh: merge visible voxels of identical visual into quads per face and extrude
      try{ if(this.meshLOD2){ this.meshLOD2.parent?.remove(this.meshLOD2); this.meshLOD2.geometry?.dispose?.(); this.meshLOD2.material?.dispose?.(); } }catch{}
      this.meshLOD2 = null;
      const cells = this.cells.filter(c=> c && (c.value!=='' || c.formula));
      if(cells.length===0) return;
      const voxels=new Set(cells.map(c=>`${c.x},${c.y},${c.z}`));
      const W=this.array.size.x, H=this.array.size.y, D=this.array.size.z;
      // Build a dense occupancy grid within this chunk bounds
      const minX=this.coord.x*CHUNK_SIZE, minY=this.coord.y*CHUNK_SIZE, minZ=this.coord.z*CHUNK_SIZE;
      const maxX=Math.min(minX+CHUNK_SIZE, W), maxY=Math.min(minY+CHUNK_SIZE, H), maxZ=Math.min(minZ+CHUNK_SIZE, D);
      const Sx=maxX-minX, Sy=maxY-minY, Sz=maxZ-minZ;
      if(Sx<=0||Sy<=0||Sz<=0) return;
      const occ=new Uint8Array(Sx*Sy*Sz);
      const idx=(x,y,z)=> (z*Sy + y)*Sx + x;
      for(let z=minZ; z<maxZ; z++) for(let y=minY; y<maxY; y++) for(let x=minX; x<maxX; x++){
        if(voxels.has(`${x},${y},${z}`)) occ[idx(x-minX,y-minY,z-minZ)]=1;
      }
      // Greedy along each axis, accumulating quads
      const geoms=[];
      const pushQuad=(x0,y0,z0, dx,dy,dz, w,h)=>{
        // Build a box for the merged face thickness 1 cell
        const bx = Math.abs(dy)+Math.abs(dz) ? w : 1;
        const by = Math.abs(dx)+Math.abs(dz) ? h : 1;
        const bz = Math.abs(dx)+Math.abs(dy) ? 1 : 1; // thickness one cell
        const geo=new THREE.BoxGeometry(bx,by,bz);
        // Center in local space
        const cx = x0 + (dx? (w-1)/2 : 0);
        const cy = y0 + (dy? (h-1)/2 : 0);
        const cz = z0;
        const m=new THREE.Matrix4().makeTranslation(
          (cx - W/2 + 0.5),
          ((H - 1 - cy) - H/2 + 0.5),
          ((D - 1 - cz) - D/2 + 0.5)
        );
        geo.applyMatrix4(m);
        geoms.push(geo);
      };
      // Simple XY-plane sweep per Z to merge rectangles of ones
      for(let z=0; z<Sz; z++){
        // Build 2D mask
        const mask=new Uint8Array(Sx*Sy);
        for(let y=0;y<Sy;y++) for(let x=0;x<Sx;x++) mask[y*Sx+x]=occ[idx(x,y,z)];
        // Greedy rectangles in mask
        let y=0; while(y<Sy){
          let x=0; while(x<Sx){
            if(!mask[y*Sx+x]){ x++; continue; }
            // width
            let w=1; while(x+w<Sx && mask[y*Sx + (x+w)]) w++;
            // height
            let h=1; outer: while(y+h<Sy){ for(let k=0;k<w;k++) if(!mask[(y+h)*Sx + (x+k)]) break outer; h++; }
            // clear mask block
            for(let yy=y; yy<y+h; yy++) for(let xx=x; xx<x+w; xx++) mask[yy*Sx+xx]=0;
            // emit quad as thin box at this z-slice
            pushQuad(minX+x, minY+y, minZ+z, 1,0,0, w, h);
            x += w;
          }
          y++;
        }
      }
      // Merge all quads into single geometry
      let merged=null;
      try{ merged = BufferGeometryUtils.mergeGeometries(geoms,false); }catch{ merged = geoms[0]||null; }
      if(!merged) return;
      const m = new THREE.Mesh(merged, createCellMaterial('filled'));
      this.meshLOD2 = m;
      if(this.array._frame) this.array._frame.add(m);
      this._dirty = false;
    }
    setLOD(level){
      if(this.currentLOD === level && !this._dirty) return;
      if(level === 1) this.buildMeshLOD1();
      else if(level === 2) this.buildMeshLOD2();
      // Visibility policy:
      // - LOD1 (instanced): show solids + ghosts + shells
      // - LOD2 (greedy): show merged solid only; hide ghosts/shells (no per-cell masking available)
      // Keep LOD1 instanced mesh "pick-only" when LOD2 is active so arrays remain clickable without focus
      if(this.meshLOD1){
        if(level===1){
          this.meshLOD1.visible = true;
          try{ this.meshLOD1.material.transparent=false; this.meshLOD1.material.opacity=1.0; this.meshLOD1.material.colorWrite=true; this.meshLOD1.material.depthWrite=true; }catch{}
        } else {
          this.meshLOD1.visible = true; // visible for raycasting
          try{ this.meshLOD1.material.transparent=true; this.meshLOD1.material.opacity=0.0; this.meshLOD1.material.colorWrite=false; this.meshLOD1.material.depthWrite=false; }catch{}
        }
      }
      if(this.meshGhost) this.meshGhost.visible = (level===1);
      if(this.meshShell) this.meshShell.visible = (level===1) && !FancyGraphics.enabled;
      if(this.meshLOD2){
        this.meshLOD2.visible = (level===2 && !this.array._headOnZ);
        // Ensure pickability when LOD2 is visible: leave LOD1 raycastable but visually invisible
        try{ if(this.meshLOD2.visible && this.meshLOD1){ this.meshLOD1.raycast = THREE.InstancedMesh.prototype.raycast; } }catch{}
      }
      // Keep LOD1 pooled; do not destroy
      this.currentLOD = level; this._dirty=false;
    }
  }
  // Greedy mesher stub (Phase 2 placeholder)
  function generateGreedyMesh(chunk){
    // Provided by buildMeshLOD2 now; keep for API completeness
    try{ chunk.buildMeshLOD2(); }catch{}
    return chunk.meshLOD2?.geometry || null;
  }
  // ChunkManager scaffold (Phase 3; gated by enable flag)
  const ChunkManager = {
    enabled:true,
    warmupFrames:0,
    update(){ /* selection-window LOD handled in renderArray/updateFocus */ }
  };
  function renderArray(arr){
    // Prune any stale chunk meshes first
    pruneStaleChunkMeshes(arr.id);
    
    // Wireframe "cage" frame with interior lookthrough fill (does not occlude voxels)
    if(!arr._frame){
      const group = new THREE.Group();

      // Frame removed: using clipping planes instead of stencil slab

      // 2) Structural rounded-edge cage
      const frameGeom = new RoundedBoxGeometry(
        arr.size.x+1.2, arr.size.y+1.2, arr.size.z+1.2, 3, 0.2
      );
      const edges = new THREE.EdgesGeometry(frameGeom);
      // Remove wireframe cage per request (keep edges object construction for potential future use but do not add)
      // const edgeLines = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: COLORS.frame, transparent: true, opacity: 0.45 }));
      // edgeLines.renderOrder = 20; // draw after fill
      // group.add(edgeLines);

      group.userData = {};
      // Array label sprite positioned near the front-left corner of the grab handle
      try{
        const labelSprite = makeArrayLabelSprite(arr);
        // Front-left corner of the array bounds (grab handle lives here)
        const corner = new THREE.Vector3(-(arr.size.x/2 + 0.4), arr.size.y/2 + 1.2, (arr.size.z/2 + 0.4));
        labelSprite.position.copy(corner);
        labelSprite.userData.billboard = true;
        // Left-align text from the corner. The sprite is center-anchored, so offset half the width along +X.
        try{ const w = labelSprite.scale.x; labelSprite.position.x += (w*0.5); }catch{}
        // Ensure it renders above voxels but depth-tested so it sorts by distance
        try{ labelSprite.material.depthTest = true; labelSprite.material.depthWrite = false; }catch{}
        group.add(labelSprite);
        group.userData.labelSprite = labelSprite;
      }catch{}
      arr._frame = group;
      // Hook: minimal diagnostics like colorfix
      try{
        arr._frame.userData.renderDiag = function(){
          const lines = [
            `ToneMapping: ${renderer.toneMapping === THREE.NoToneMapping ? 'None' : renderer.toneMapping}`,
            `outputColorSpace: ${renderer.outputColorSpace}`
          ];
          const z = 0;
          const types=['empty','filled','formula','ghost'];
          for(const t of types){
            const rec=layerMeshes.get(`${arr.id}:${z}:${t}`);
            lines.push(`${t}.instanceColor: ${!!(rec && rec.mesh && rec.mesh.instanceColor)}`);
          }
          console.log(lines.join('\n'));
        }
      }catch{}
      scene.add(arr._frame);
    }
    // center frame at array offset like voxels
    const off=arr.offset||{x:0,y:0,z:0};
    arr._frame.position.set(off.x,off.y,off.z);
    try{ refreshLightsForArray(arr.id); }catch{}
    // No in-scene d-pad overlay (HUD-only)
    buildAxes(arr);
    // Reparent any chunk meshes/shells under frame to ensure center alignment
    try{
      Object.values(arr.chunks||{}).forEach(ch=>{
        if(ch.meshLOD1 && ch.meshLOD1.parent!==arr._frame){ arr._frame.add(ch.meshLOD1); }
        if(ch.meshGhost && ch.meshGhost.parent!==arr._frame){ arr._frame.add(ch.meshGhost); }
        if(ch.meshShell && ch.meshShell.parent!==arr._frame){ arr._frame.add(ch.meshShell); }
      });
      if(arr._arrayShell && arr._arrayShell.parent!==arr._frame){ arr._frame.add(arr._arrayShell); }
    }catch{}
    const sel = Store.getState().selection;
    const isFocused = (sel.arrayId === arr.id);
    const focus = isFocused && sel.focus ? {...sel.focus} : null;
    const cellCount = Object.values(arr.chunks).reduce((n,ch)=> n + ch.cells.length, 0);
    // Prefer filled cell count for LOD2 decisions; empty arrays should keep LOD1 visible
    let filledCount = 0;
    try{
      Object.values(arr.chunks).forEach(ch=>{
        for(let i=0;i<ch.cells.length;i++){
          const c = ch.cells[i];
          if(!c) continue;
          if((c.value!=='' && c.value!==null && c.value!==undefined) || !!c.formula) { filledCount++; }
        }
      });
    }catch{}
    const wantGreedy = filledCount >= INACTIVE_GREEDY_THRESHOLD;

    // Use new GPU cutaway system via chunks only when ChunkManager is enabled
    if(Scene.ChunkManager && Scene.ChunkManager.enabled){
      // Single source of truth: chunk occlusion only. Ensure legacy meshes are removed.
      try{
        for(let z=0; z<arr.size.z; z++){
          ['empty','ghost','filled','formula','edges'].forEach(type=>{
            const key = `${arr.id}:${z}:${type}`;
            const rec = layerMeshes.get(key);
            if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry?.dispose?.(); rec.mesh.material?.dispose?.(); layerMeshes.delete(key); }
          });
        }
      }catch{}
      // Remove legacy layer meshes to prevent flashing when chunks are ON
      try{
        for(let z=0; z<arr.size.z; z++){
          ['empty','ghost','filled','formula','edges'].forEach(type=>{
            const key = `${arr.id}:${z}:${type}`;
            const rec = layerMeshes.get(key);
            if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry?.dispose?.(); rec.mesh.material?.dispose?.(); layerMeshes.delete(key); }
          });
        }
      }catch{}
      // Gate chunk work to the focused window only
      const warm = (Scene.ChunkManager.warmupFrames||0) > 0;
      if(isFocused && focus){
        try{
          const fc = chunkOf(focus.x, focus.y, focus.z);
          for(const ch of Object.values(arr.chunks)){
            const dx = Math.abs(ch.coord.x - fc.x);
            const dy = Math.abs(ch.coord.y - fc.y);
            const dz = Math.abs(ch.coord.z - fc.z);
            const near = (dx <= WINDOW_CHUNK_RADIUS && dy <= WINDOW_CHUNK_RADIUS && dz <= WINDOW_CHUNK_RADIUS);
            if(warm){ ch.ensureMesh?.(); ch.setLOD?.(1); }
            else if(near){ ch.ensureMesh?.(); ch.setLOD?.(1); }
            else { if (cellCount >= INACTIVE_GREEDY_THRESHOLD) { ch.setLOD?.(2); } else { ch.ensureMesh?.(); ch.setLOD?.(1); } }
          }
        }catch{}
        try{ applyCutaway(arr, focus); }catch{}
      } else {
        try{
          for(const ch of Object.values(arr.chunks)){
            const warmSelf = (arr._warmupFrames|0) > 0;
            if(Scene.ChunkManager.warmupFrames>0 || warmSelf){ ch.ensureMesh?.(); ch.setLOD?.(1); }
            else if (filledCount >= INACTIVE_GREEDY_THRESHOLD) { ch.setLOD?.(2); }
            else { ch.ensureMesh?.(); ch.setLOD?.(1); }
          }
        }catch{}
      }
      // Whole-array highlight shell: behind cell fills; slightly larger; functionally invisible core
      try{
        const sh=ensureArrayHighlightShell(arr); if(sh){
          sh.visible=!arr.hidden;
          sh.traverse(n=>{ if(n.isMesh){ n.material.depthTest=true; n.material.depthWrite=false; } });
          sh.children?.forEach?.(m=>{ if(m?.isMesh && m.material?.stencilWrite){ m.renderOrder = 290; } });
        }
      }catch{}
      if(Scene.ChunkManager.warmupFrames>0){ Scene.ChunkManager.warmupFrames--; }
      if((arr._warmupFrames|0) > 0){ arr._warmupFrames--; }
    } else {
      // Ensure any previously created chunk twin meshes are hidden when chunks are OFF
      try{
        Object.values(arr.chunks).forEach(ch=>{
          if(ch.meshLOD1) ch.meshLOD1.visible=false;
          if(ch.meshGhost) ch.meshGhost.visible=false;
          if(ch.meshShell) ch.meshShell.visible=false;
        });
      }catch{}
      // Whole-array highlight shell in legacy mode as well
      try{ ensureArrayHighlightShell(arr); }catch{}
    }

    // Head-on slab mode detection: when looking down +Z or -Z, hide greedy LOD2 so occluded layers don't appear filled
    try{
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      const headOnZ = (Math.abs(dir.z) >= Math.max(Math.abs(dir.x), Math.abs(dir.y)) && Math.abs(dir.z) > 0.92);
      arr._headOnZ = !!headOnZ;
      // Compute a view signature (major axis + relative layer) to avoid unnecessary rebuilds
      const ax = Math.abs(dir.x), ay = Math.abs(dir.y), az = Math.abs(dir.z);
      const major = (az >= ax && az >= ay) ? 'Z' : (ax >= ay ? 'X' : 'Y');
      const sel = Store.getState().selection || {};
      const focus = (sel.arrayId === arr.id) ? sel.focus : null;
      const relLayer = (major==='Z') ? (focus?.z ?? null) : (major==='X' ? (focus?.x ?? null) : (focus?.y ?? null));
      const viewSig = `${major}:${relLayer==null?'n':relLayer}:${arr._headOnZ?1:0}`;
      if(arr._viewSig === viewSig && arr._layersRendered){
        // View signature unchanged; skip expensive layer rebuild
        return;
      }
      arr._viewSig = viewSig;
    }catch{ arr._headOnZ = false; }

    // Do not destroy existing layer meshes; they will be updated/hid as needed for performance
    arr._layersRendered = true;
    syncVisibility(arr);
    debounceColliderRebuild(arr);
    // Rehydrate value sprites for this array after render
    try{
      const vs = window.valueSprites || new Map();
      vs.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)){ try{ unmarkBillboard(sprite); sprite.parent?.remove(sprite); sprite.material?.map?.dispose?.(); sprite.material?.dispose?.(); }catch{} vs.delete(key); } });
      Object.values(arr.chunks||{}).forEach(ch=>{
        (ch.cells||[]).forEach(c=>{
          try{
            const cell = Formula.getCell({arrId: arr.id, x:c.x, y:c.y, z:c.z});
            if(cell && (cell.value!=='' && cell.value!==null && cell.value!==undefined)) updateValueSprite(arr, c.x, c.y, c.z, cell);
          }catch{}
        });
      });
      updateArrayValueSpritePlacement(arr);
    }catch{}
  }

  function renderChunk(arrayId, chunk, size){
    const arr = Store.getState().arrays[arrayId];
    const mKey = `${arrayId}:${keyChunk(chunk.coord.x,chunk.coord.y,chunk.coord.z)}`;

    // Get or create once (no shadowing)
    let mesh = chunkMeshes.get(mKey);
    if (!mesh) {
      mesh = new THREE.InstancedMesh(GEO_VOXEL.clone(), createCellMaterial('filled'), Math.max(1, chunk.cells.length));
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      mesh.frustumCulled = false;
      mesh.userData = { arrayId, chunkKey: keyChunk(chunk.coord.x,chunk.coord.y,chunk.coord.z) };
      chunkMeshes.set(mKey, mesh);
      // Parent to frame for consistent movement
      if (arr._frame) arr._frame.add(mesh); else scene.add(mesh);
    }

    // Ensure instanceColor exists & matches count
    const count = chunk.cells.length;
    if (mesh.instanceColor == null || mesh.instanceColor.count !== count) {
      mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(Math.max(1, count) * 3), 3);
      mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
      // Seed with white to prevent black cells
      const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
      for (let i = 0; i < Math.max(1, count); i++) mesh.setColorAt(i, seed);
    }

    // Fill transforms & per-instance colors from live cell state (treat as atomic unit)
    for (let i = 0; i < count; i++) {
      const c = chunk.cells[i];

      // Use fast accessor for live value/meta including custom colors
      const fresh = getCellFast(arrayId, { x: c.x, y: c.y, z: c.z });
      const has = (fresh.value !== '' && fresh.value !== null && fresh.value !== undefined);
      const isFormula = !!fresh.formula;
      const key = `${arrayId}:${c.x},${c.y},${c.z}`;
      const emitted = !!(Store.getState().sourceByCell?.get?.(key));
      const custom = fresh?.meta?.color;
      
      let hex = has ? COLORS.filled : COLORS.empty;
      if (isFormula) hex = COLORS.formula; 
      else if (emitted) hex = COLORS.emitted;

      // Use local position for frame-relative rendering; zero rotation/scale (centered)
      temp.position.copy(localPos(arr, c.x, c.y, c.z));
      temp.rotation.set(0,0,0);
      temp.scale.set(1,1,1);
      temp.updateMatrix();
      mesh.setMatrixAt(i, temp.matrix);

      const col = new THREE.Color(custom || hex);
      col.convertSRGBToLinear();
      mesh.setColorAt(i, col);
    }

    mesh.count = count;
    mesh.instanceMatrix.needsUpdate = true;
    if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
  }
  function ensureLayerMesh(arr, z, type, capacity){
    const key = `${arr.id}:${z}:${type}`;
    let rec = layerMeshes.get(key);
    const cap = Math.max(1, capacity);

    const makeMesh = (cap) => {
      const geom = GEO_VOXEL.clone(); addWhiteVertexColors(geom);
      const baseType = (type && String(type).startsWith('ghost')) ? 'ghost' : (type||'filled');
      const mesh = new THREE.InstancedMesh(geom, createCellMaterial(baseType), cap);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      mesh.frustumCulled = false;
      mesh.userData = { arrayId: arr.id, z, type, isGhost: baseType==='ghost' };
      if(baseType==='ghost'){
        // Ghost: unlit, depth-tested, above solids
        mesh.material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.20,
          depthWrite: false,
          depthTest: true,
          vertexColors: true,
          blending: THREE.AdditiveBlending
        });
        mesh.material.toneMapped = false;
        mesh.renderOrder = 2;
      }
      // Parent under frame and use local positions for tight alignment
      if(arr._frame) arr._frame.add(mesh); else scene.add(mesh);
      return mesh;
    };

    if (!rec) {
      const mesh = makeMesh(cap);
      // Ensure instanceColor is allocated and seeded
      if (mesh.instanceColor == null || mesh.instanceColor.count !== cap) {
        mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cap*3), 3);
        mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        // Seed with sRGB white -> linear to avoid black first frame
        const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
        for (let i = 0; i < cap; i++) mesh.setColorAt(i, seed);
      }
      // Seed with white to avoid black cells
      const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
      for (let i = 0; i < cap; i++) mesh.setColorAt(i, seed);
      rec = { mesh, capacity: cap, used: 0, index2cell: [] };
      layerMeshes.set(key, rec);
      return rec;
    }

    if (capacity > rec.capacity) {
      // Grow-only: reallocate instance buffers on existing mesh
      const mesh = rec.mesh;
      try{
        const newMatrix = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 16), 16);
        mesh.instanceMatrix = newMatrix;
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        if(mesh.instanceColor){
          mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 3), 3);
          mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
          // Seed expanded buffer with white
          const seed = new THREE.Color(0xffffff).convertSRGBToLinear();
          for (let i = 0; i < capacity; i++) mesh.setColorAt(i, seed);
        }
      }catch{}
      rec.capacity = capacity;
      rec.index2cell.length = 0;
      if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
    }
    return rec;
  }
  function renderLayer(arr, z){
    // LEGACY LAYER PIPELINE REMOVED – use chunk SoT exclusively
    return;
  }

  function renderCellGroup(arr, z, type, cellData){
    const key=`${arr.id}:${z}:${type}`;
    const capacity = Math.max(1, cellData.length);
    const rec = ensureLayerMesh(arr, z, type, capacity);
    const mesh = rec.mesh;
    rec.index2cell.length = 0;
    if(cellData.length === 0){
      // Swap behavior: if this is a ghost group, ensure corresponding solid group is visible; otherwise hide this group
      mesh.count = 0;
      mesh.visible = false;
      return;
    }
    const geom = GEO_VOXEL.clone();
    const GREEN = {dark:0x16a34a, light:0x86efac};
    const BLUE  = 0x3b82f6;
    const WHITE = 0xffffff;
    // Map ghost variants to ghost material
    const baseType = (type && type.startsWith('ghost')) ? 'ghost' : type;
    mesh.userData = { arrayId: arr.id, z, type, isGhost: baseType==='ghost' };
    // Improve pickability: avoid incorrect culling bounds on instanced voxels
    mesh.frustumCulled = false;

    // 🔒 Click-through for ghost:
    if (baseType === 'ghost') {
      // never receive ray hits
      mesh.raycast = () => {};
      // Replace with unlit additive pass so it lightens instead of darkens
      if(!(mesh.material && mesh.material.isMeshBasicMaterial)){
        mesh.material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.20,
          depthWrite: false,
          depthTest: true,
          vertexColors: true,
          blending: THREE.AdditiveBlending
        });
      }
      mesh.material.toneMapped = false;
      mesh.renderOrder = 2;
    } else {
      // Make sure opaque pass wins z-buffer and renders above frames
      mesh.material.transparent = false;
      mesh.material.depthWrite = true;
      mesh.renderOrder = 1; // render above frames (renderOrder 0)
    }

    // Shadows disabled in simple mode

    // place instances + per-instance color for ghost "chain" visualization
    const index2cell = cellData.map(cd => cd.c);
    const useColors = (baseType==='ghost' || baseType==='filled' || baseType==='formula');
    if(useColors && (mesh.instanceColor == null || (mesh.instanceColor && mesh.instanceColor.count !== cellData.length))){
      mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3), 3);
      mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
    }
    // Ensure outline overlay exists and is kept in sync for the same group key
    const overlayKey = `${arr.id}:${z}:${type}:edges`;
    let overlayRec = layerMeshes.get(overlayKey);
    if(!overlayRec){ addEdgeOverlay(`${arr.id}:${z}:${type}`, arr, z, cellData); overlayRec = layerMeshes.get(overlayKey); }
    else {
      // Update transforms and colors for overlays without recreating
      const borders = overlayRec.mesh;
      if(borders.count !== cellData.length){
        borders.count = cellData.length;
        if(!borders.instanceColor || borders.instanceColor.count !== cellData.length){
          borders.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3),3);
          borders.instanceColor.setUsage(THREE.DynamicDrawUsage);
        }
      }
      for(let i=0;i<cellData.length;i++){
        const {c, freshCell} = cellData[i];
        const pos = localPos(arr,c.x,c.y,c.z);
        temp.position.copy(pos);
        temp.updateMatrix();
        borders.setMatrixAt(i, temp.matrix);
        try{
          const key=`${arr.id}:${c.x},${c.y},${c.z}`;
          const fresh = freshCell || Scene.getCell(arr.id,{x:c.x,y:c.y,z:c.z});
          const has = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
          const isFormula = !!fresh.formula;
          const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
          const tk2 = isFormula ? 'formula' : (emitted ? 'emitted' : (has ? 'value' : 'empty'));
          const { colorHex: overrideOutline2 } = outlineParamsForTypeKey(tk2);
          const baseHex2 = baseHexForTypeKey(tk2);
          const col2 = new THREE.Color( (typeof overrideOutline2==='number') ? overrideOutline2 : baseHex2 );
          if(typeof overrideOutline2!=='number'){ col2.offsetHSL(0,0,-0.25); }
          col2.convertSRGBToLinear();
          borders.setColorAt(i, col2);
        }catch{}
      }
      borders.instanceMatrix.needsUpdate = true;
      if(borders.instanceColor) borders.instanceColor.needsUpdate = true;
      borders.visible = true;
    }
    const isCellEmitted = (arr, c) => {
      const key = `${arr.id}:${c.x},${c.y},${c.z}`;
      return !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
    };
    for(let i=0; i<cellData.length; i++){
      const {c, freshCell} = cellData[i];
      const pos = localPos(arr,c.x,c.y,c.z);
      temp.position.copy(pos);
      temp.updateMatrix();
      mesh.setMatrixAt(i, temp.matrix);
      if(useColors){
        // Ghost categories by group, else per-cell meta color for solids
        if(baseType==='ghost'){
          let colorHex = WHITE;
          if(type==='ghost_source') colorHex = GREEN.dark;
          else if(type==='ghost_emitted') colorHex = GREEN.light;
          else if(type==='ghost_value') colorHex = BLUE;
          else if(type==='ghost_empty') colorHex = WHITE;
          { const col=new THREE.Color(colorHex); col.convertSRGBToLinear(); mesh.setColorAt(i, col); }
        } else {
          const custom = freshCell?.meta?.color;
          let hex;
          if(baseType==='formula') hex = baseHexForTypeKey('formula'); 
          else if(isCellEmitted(arr, c)) hex = baseHexForTypeKey('emitted'); 
          else hex = baseHexForTypeKey('value');
          { const col=new THREE.Color(custom || hex); col.convertSRGBToLinear(); mesh.setColorAt(i, col); }
        }
      }
    }
    if(useColors && mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
    mesh.visible = true;

    mesh.count = cellData.length;
    mesh.instanceMatrix.needsUpdate = true;
    layerMeshes.set(key, {mesh, capacity: Math.max(rec.capacity, cellData.length), used: cellData.length, index2cell});
  }
  function addEdgeOverlay(baseKey, arr, z, cellData, colorHex){
    const key = `${baseKey}:edges`;
    const old = layerMeshes.get(key);
    if(old){ if(arr._frame) arr._frame.remove(old.mesh); else scene.remove(old.mesh); old.mesh.geometry.dispose(); old.mesh.material.dispose(); }

    if(cellData.length === 0) return;

    // Create rounded borders using scaled-down rounded cubes
    const tk = typeKeyFrom(baseKey.split(':').pop());
    const { thickness, colorHex: overrideOutline, opacity } = outlineParamsForTypeKey(tk);
    const borderGeom = new RoundedBoxGeometry(thickness, thickness, thickness, 3, 0.15); // slightly larger, inverted hull
    const borderMat = new THREE.MeshBasicMaterial({ 
      color: (typeof overrideOutline === 'number' ? overrideOutline : (typeof colorHex==='number'?colorHex:0xffffff)), 
      transparent: true, 
      opacity: (String(baseKey).includes('ghost') ? Math.max(0, Math.min(1, opacity*0.8)) : opacity),
      side: THREE.BackSide,
      depthTest: true,
      depthWrite: false,
      vertexColors: true
    });
    borderMat.toneMapped = false;
    const borders = new THREE.InstancedMesh(borderGeom, borderMat, cellData.length);
    borders.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    // Allocate per-instance colors for outlines (darker variants of base color)
    if(!borders.instanceColor || borders.instanceColor.count !== cellData.length){
      borders.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(cellData.length*3), 3);
      borders.instanceColor.setUsage(THREE.DynamicDrawUsage);
    }
    borders.userData = { arrayId: arr.id, z, type:'edges', kind:'edgeOverlay' };
    borders.frustumCulled = false;
    borders.renderOrder = 2;

    for(let i=0;i<cellData.length;i++){
      const {c, freshCell} = cellData[i] || {c:null,freshCell:null};
      const pos = localPos(arr,c.x,c.y,c.z);
      temp.position.copy(pos);
      temp.updateMatrix();
      borders.setMatrixAt(i, temp.matrix);
      // Per-instance darker outline color based on base cell color
      try{
        const key=`${arr.id}:${c.x},${c.y},${c.z}`;
        const fresh = freshCell || Scene.getCell(arr.id,{x:c.x,y:c.y,z:c.z});
        const has = (fresh.value!=='' && fresh.value!==null && fresh.value!==undefined);
        const isFormula = !!fresh.formula;
        const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
        const baseHex = isFormula ? COLORS.formula : emitted ? COLORS.emitted : (has ? COLORS.filled : COLORS.empty);
        const col = new THREE.Color(baseHex);
        col.offsetHSL(0, 0, -0.25); // darker
        col.convertSRGBToLinear();
        borders.setColorAt(i, col);
      }catch{}
    }
    borders.count = cellData.length;
    borders.instanceMatrix.needsUpdate = true;
    if(borders.instanceColor) borders.instanceColor.needsUpdate = true;

    // Parent to frame; use local positions to stay aligned
    if(arr._frame) arr._frame.add(borders); else scene.add(borders);
    layerMeshes.set(key, {mesh:borders, capacity: cellData.length, used: cellData.length, index2cell: cellData.map(cd=>cd.c)});
  }
  function buildAxes(arr){
    // remove old
    // Remove previous labels safely from their actual parent
    arr.labels?.forEach(s=>{ try{ if(s?.userData?.billboard) unmarkBillboard(s); s.parent?.remove(s); s.material?.dispose?.(); s.material?.map?.dispose?.(); s.geometry?.dispose?.(); }catch{} }); arr.labels=[];
    const mk=(txt,color='#333333')=>{
      const c=document.createElement('canvas'); const ctx=c.getContext('2d'); const fs=64;
      ctx.font=`900 ${fs}px 'Roboto Mono', monospace`; const w=Math.ceil(ctx.measureText(txt).width);
      c.width=w+24; c.height=fs+24;
      // Transparent background
      ctx.clearRect(0,0,c.width,c.height);
      ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font=`900 ${fs}px 'Roboto Mono', monospace`;
      ctx.fillText(txt,c.width/2,c.height/2);
      const t=new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      // Depth test true so it sorts by distance; write false to avoid z artifacts
      const m=new THREE.SpriteMaterial({map:t,depthTest:true,depthWrite:false,transparent:true});
      m.toneMapped = false;
      const s=new THREE.Sprite(m);
      const targetH=0.6; // consistent height in world units
      const aspect=c.width/c.height; s.scale.set(targetH*aspect, targetH, 1);
      return markBillboard(s);
    };
    const X=arr.size.x,Y=arr.size.y,Z=arr.size.z;
    const grabSize=0.7; // smaller rounded voxel for handle
    const faceGap=grabSize*0.5 + 0.25; // axis label offset from faces
    // Fine-tune label offsets relative to grab/cell centers
    const LABEL_Y_DOWN = 0.12;  // nudge downwards a touch
    const LABEL_X_RIGHT_Y_AXIS = 0.12; // Y-axis numbers slightly to the right
    const LABEL_Z_BACK = 0.06; // slight push back along -Z when near grab

    // Only rebuild grab if not already present to avoid stamping
    let grab = arr.labels?.find(l=>l.userData?.type==='grab');
    if(!grab){
      const grabMat=new THREE.MeshBasicMaterial({color:COLORS.grab, depthWrite:true});
      grab=new THREE.Mesh(new RoundedBoxGeometry(grabSize,grabSize,grabSize,3,Math.min(.2,grabSize*.25)), grabMat);
      const origin=localPos(arr,0,0,0); // local center of A1α (top row)
    // Position grab so its bottom-back-right corner touches A1α's top-left-front corner
    grab.position.set(origin.x - 0.5 - grabSize/2, origin.y + 0.5 + grabSize/2, origin.z + 0.5 + grabSize/2);
    grab.userData={type:'grab', arrayId:arr.id};
      // Parent grab to frame so it follows
      if(arr._frame) arr._frame.add(grab); else scene.add(grab);
      try{ if(arr._frame) arr._frame.userData.grab = grab; }catch{}
      arr.labels.push(grab);
    }

    // Emit axes from grab handle faces, billboarded and aligned near the grab corner
    // X headers (A..) — emit from right face of grab, aligned to cell centers
    for(let x=0;x<X;x++){ 
      const s=mk(A1(x),'#ff1a1a'); s.userData.billboard=true;
      const cellPos=localPos(arr,x,0,0); 
      // Align to the grab handle’s back face Z, and match Z label downshift on Y
      s.position.set(cellPos.x, grab.position.y - LABEL_Y_DOWN, grab.position.z);
      if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s); 
    }
    // Y headers (1..) — top row is 1, increase downward
    for(let y=0;y<Y;y++){ 
      const s=mk(String(y+1),'#00e676'); s.userData.billboard=true;
      const cellPos=localPos(arr,0,y,0); 
      // Align near grab: slightly right on X, slightly down on Y, slightly back on Z
      s.position.set(grab.position.x + LABEL_X_RIGHT_Y_AXIS, cellPos.y - LABEL_Y_DOWN, grab.position.z - LABEL_Z_BACK);
      if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s); 
    }
    // Z headers (α..) — emit negatively along Z, aligned to the back XY face of grab
    for(let z=0;z<Z;z++){ 
      const s=mk(greek(z),'#0066ff'); s.userData.billboard=true;
      const cellPos=localPos(arr,0,0,z); 
      // Emit along Z and match Y with grab center, nudged slightly down
      s.position.set(grab.position.x, grab.position.y - LABEL_Y_DOWN, cellPos.z); 
      if(arr._frame) arr._frame.add(s); else scene.add(s); arr.labels.push(s); 
    }

    // In-scene D-Pad removed (use HUD)

    arr.labels.forEach(s=>s.visible=Store.getState().scene.showAxes);
  }
  // ensureNavPad removed

  function syncVisibility(arr){
    const v=!arr.hidden; 
    if(arr._frame) arr._frame.visible=v;
    // update layer meshes visibility
    for(let z=0; z<arr.size.z; z++){
      ['empty','ghost','filled','formula','edges'].forEach(type=>{
        const rec=layerMeshes.get(`${arr.id}:${z}:${type}`); if(rec) rec.mesh.visible=v;
      });
    }
    // chunk meshes
    Object.values(arr.chunks).forEach(ch=>{
      if(ch.meshLOD2) ch.meshLOD2.visible = v && (ch.currentLOD===2);
      if(ch.meshLOD1){
        const pickVisible = v && (ch.currentLOD===1 || (ch.meshLOD2 && ch.meshLOD2.visible));
        ch.meshLOD1.visible = pickVisible;
      }
      if(ch.meshShell){
        const lod = (ch.currentLOD == null) ? 1 : ch.currentLOD;
        ch.meshShell.visible = v && (lod === 1) && !FancyGraphics.enabled;
      }
      const mk=`${arr.id}:${keyChunk(ch.coord.x,ch.coord.y,ch.coord.z)}`; const m=chunkMeshes.get(mk); if(m) m.visible=v;
    });
    // axis labels and grab handles
    const globalAxes = Store.getState().scene.showAxes;
    const localAxes = (arr.axesVisible === undefined) ? globalAxes : !!arr.axesVisible;
    arr.labels?.forEach(s=> s.visible = v && localAxes);
    // Debug: update HUD counts
    try{ updateCountChip(); }catch{}
    // Toggle value sprite visibility correctly
    valueSprites.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)) sprite.visible = v; });
    // value sprites
    Object.keys(valueSprites).forEach(key=>{
      if(key.startsWith(`${arr.id}:`)){
        const sprite=valueSprites.get(key);
        if(sprite) sprite.visible=v;
      }
    });
    // Update debug counts after any visibility change
    try{ updateCountChip?.(); }catch{}
    // Update 2D sheet if this array becomes invisible
    if(!v && Store.getState().selection.arrayId===arr.id){
      // Switch to next visible array
      const visibleArrays=Object.values(Store.getState().arrays).filter(a=>!a.hidden);
      if(visibleArrays.length>0){
        const next=visibleArrays[0];
        Actions.setSelection(next.id, {x:0,y:Math.max(0,next.size.y-1),z:0});
        window.UI?.renderSheet();
      }
    }
  }

  // Debug HUD counts: total cell instances and split by Chunk/Legacy
  function updateCountChip(){
    try{
      let shellsChunk=0, shellsLegacy=0, fillsChunk=0, fillsLegacy=0;
      // Chunk meshes
      Object.values(Store.getState().arrays).forEach(arr=>{
        Object.values(arr.chunks||{}).forEach(ch=>{
          if(ch.meshShell) shellsChunk += (ch.meshShell.count||0);
          if(ch.meshLOD1)  fillsChunk  += (ch.meshLOD1.count||0);
        });
      });
      // Legacy meshes
      layerMeshes.forEach((rec,key)=>{
        if(!rec||!rec.mesh) return;
        if(String(key).endsWith(':edges')) shellsLegacy += (rec.mesh.count||0);
        else fillsLegacy += (rec.mesh.count||0);
      });
      const totalUnique = fillsChunk + fillsLegacy;
      const chip=document.getElementById('countChip'); if(chip){ chip.textContent = `Cells:${totalUnique} | Shells C/L:${shellsChunk}/${shellsLegacy} | Fills C/L:${fillsChunk}/${fillsLegacy}`; }
    }catch{}
  }

  // Debug panel to control renderOrder for voxel passes
  // Render order debug UI removed

  function forceRenderOrderRefresh(reapplyOcclusion){
    try{
      // Update chunk instanced meshes
      Object.values(Store.getState().arrays).forEach(arr=>{
        Object.values(arr.chunks||{}).forEach(ch=>{
          if(ch.meshGhost) ch.meshGhost.renderOrder = window.__RO.ghostFill|0;
          if(ch.meshLOD1)  ch.meshLOD1.renderOrder  = window.__RO.solidFill|0;
          if(ch.meshShell) ch.meshShell.renderOrder = window.__RO.solidShell|0;
        });
        // Update whole-array shell as Ghost Shell for debugging purposes
        if(arr._arrayShell){
          arr._arrayShell.traverse(n=>{
            if(!n.isMesh) return;
            // detect by stencil: core writes stencil, shell reads NotEqual
            if(n.material && n.material.stencilWrite && n.material.stencilFunc===THREE.AlwaysStencilFunc){
              n.renderOrder = window.__RO.frameCore|0;
            } else {
              n.renderOrder = window.__RO.frameShell|0;
            }
          });
        }
        if(reapplyOcclusion){ try{ const sel=Store.getState().selection; if(sel?.arrayId&&sel.focus){ applyGhostMaskToChunks(arr); } }catch{} }
      });
      needsRender = true;
    }catch{}
  }

  function updateFocus(sel){
    if(!sel.arrayId||!sel.focus){ focusMarker.visible=false; updateAvatars(sel); return; }
    const arr=Store.getState().arrays[sel.arrayId];
    // One-time occlusion clear when focus array changes; do not repeatedly clear
    if(lastFocusedArrayId && lastFocusedArrayId !== sel.arrayId){
      const prev = Store.getState().arrays[lastFocusedArrayId];
      clearOcclusion(prev);
      try{ Object.values(prev?.chunks||{}).forEach(ch=> ch._dirty = true); }catch{}
    }
    lastFocusedArrayId = sel.arrayId;
    
    // Camera-facing highlight box (no .abs() calls on Vector3)
    const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir);
    const ax=Math.abs(camDir.x), ay=Math.abs(camDir.y), az=Math.abs(camDir.z);
    let sx=1.06, sy=1.06, sz=1.06;
    if(ax>ay && ax>az) sx=0.04; else if(ay>az) sy=0.04; else sz=0.04;
    const geo=new THREE.BoxGeometry(sx,sy,sz);
    if(focusMarker.geometry) focusMarker.geometry.dispose?.();
    focusMarker.geometry=geo;
    
    focusMarker.visible=true; const p=worldPos(arr,sel.focus.x,sel.focus.y,sel.focus.z);
    focusMarker.position.copy(p);
    updateAvatars(sel);
    // Promote detailed window around selection immediately for performance/fidelity
    try{
      const fc = chunkOf(sel.focus.x, sel.focus.y, sel.focus.z);
      for(let cz=fc.z-WINDOW_CHUNK_RADIUS; cz<=fc.z+WINDOW_CHUNK_RADIUS; cz++)
        for(let cy=fc.y-WINDOW_CHUNK_RADIUS; cy<=fc.y+WINDOW_CHUNK_RADIUS; cy++)
          for(let cx=fc.x-WINDOW_CHUNK_RADIUS; cx<=fc.x+WINDOW_CHUNK_RADIUS; cx++){
            const k = keyChunk(cx,cy,cz); const ch = arr.chunks[k]; if(ch) ch.setLOD?.(1);
          }
    }catch{}
    // Ensure shells are present after focus changes (e.g., after load)
    try{ ensureArrayHighlightShell(arr); }catch{}
    // In-scene d-pad removed
    try {
      window.UI?.inspect(arr, sel.focus);
      // Trigger occlusion recompute on selection change as well
      if(typeof animate==='function' && animate.lastOcclusionState){ animate.lastOcclusionState.signature = ''; }
    } catch(e) {
      console.warn('Inspect failed:', e);
    }
  }
  function centerOnArray(arr){ if(!arr) return; const off=arr.offset||{x:0,y:0,z:0}; controls.target.set(off.x,off.y,off.z); camera.position.set(off.x+arr.size.x*1.2, off.y+arr.size.y*1.2, off.z+arr.size.z*1.8); }

  function centerOnPlayer(){
    const px = Number.isFinite(cachedPlayerPos.x) ? cachedPlayerPos.x : 0;
    const py = Number.isFinite(cachedPlayerPos.y) ? cachedPlayerPos.y : 2;
    const pz = Number.isFinite(cachedPlayerPos.z) ? cachedPlayerPos.z : 0;
    controls.target.set(px,py,pz);
    camera.position.set(px+6, py+4, pz+8);
  }
  /* ---- Physics: merged colliders per connected run ---- */
  function clearColliders(arr){
    if(!rapierWorld||!arr._colliders) return;
    arr._colliders.forEach(h=>{ try{ rapierWorld.removeCollider(h,true); }catch{} });
    arr._colliders.length=0;
  }

  function debounceColliderRebuild(arr){
    arr._collidersBuilding = true;
    if(colliderRebuildQueue.has(arr.id)) {
      clearTimeout(colliderRebuildQueue.get(arr.id));
    }
    const timeoutId = setTimeout(()=>{
      try { rebuildCollidersForArray(arr); }
      finally { arr._collidersBuilding = false; }
      colliderRebuildQueue.delete(arr.id);
    }, 50);
    colliderRebuildQueue.set(arr.id, timeoutId);
  }
  function rebuildCollidersForArray(arr){
    if(!rapierWorld) return;
    clearColliders(arr);

    const occ = new Map(); // key -> 1 if filled
    Object.values(arr.chunks).forEach(ch=>{
      ch.cells.forEach(c=>{ if(c.value!=='' && c.value!==null && c.value!==undefined){ occ.set(`${c.x},${c.y},${c.z}`,1);} });
    });

    const visited=new Set();
    const inBounds=(x,y,z)=> x>=0&&y>=0&&z>=0&&x<arr.size.x&&y<arr.size.y&&z<arr.size.z;
    const isSolid=(x,y,z)=> occ.has(`${x},${y},${z}`);

    for(let z=0; z<arr.size.z; z++)
      for(let y=0; y<arr.size.y; y++)
        for(let x=0; x<arr.size.x; x++){
          const k=`${x},${y},${z}`; if(!isSolid(x,y,z) || visited.has(k)) continue;

          // grow run in X
          let x2=x; while(x2+1<arr.size.x && isSolid(x2+1,y,z) && !visited.has(`${x2+1},${y},${z}`)) x2++;
          // try to grow Y
          let y2=y;
          outerY: while(y2+1<arr.size.y){
            for(let xi=x; xi<=x2; xi++){ if(!isSolid(xi,y2+1,z) || visited.has(`${xi},${y2+1},${z}`)) break outerY; }
            y2++;
          }
          // try to grow Z
          let z2=z;
          outerZ: while(z2+1<arr.size.z){
            for(let yi=y; yi<=y2; yi++) for(let xi=x; xi<=x2; xi++){ if(!isSolid(xi,yi,z2+1) || visited.has(`${xi},${yi},${z2+1}`)) break outerZ; }
            z2++;
          }

          // mark visited
          for(let zz=z; zz<=z2; zz++) for(let yy=y; yy<=y2; yy++) for(let xx=x; xx<=x2; xx++) visited.add(`${xx},${yy},${zz}`);

          // build collider (single merged AABB)
          const hx=(x2-x+1)/2, hy=(y2-y+1)/2, hz=(z2-z+1)/2;
          const center=worldPos(arr, x+hx-.5, y+hy-.5, z+hz-.5);
          const col=RAPIER.ColliderDesc.cuboid(hx*0.9, hy*0.9, hz*0.9).setTranslation(center.x,center.y,center.z);
          const handle=rapierWorld.createCollider(col); arr._colliders.push(handle);
        }
  }
  // Procedural animation system for timed translations/preview
  const proceduralAnims = [];
  // Per-array timed gamestate (affects all transforms while active)
  function ensureTimedState(arr){
    arr.params = arr.params || {};
    arr.params.timed = arr.params.timed || { ticks:60, reverse:false, reverseTicks:null, repeat:false, t:0, dir:1, previewInArray:false, plan:[], baseOffset:null, baseQuat:null, overlay:null };
    return arr.params.timed;
  }
  function queueTimedOp(arr, anchor, op){
    const t = ensureTimedState(arr);
    t.plan.push({ ...op, anchor:{...anchor} });
  }
  function queueArrayPlanFromArray(arr){
    try{
      const hasArrayOp = (ensureTimedState(arr).plan||[]).some(op=>op.type==='array');
      if(hasArrayOp) return true;
      const parseDims=(f)=>{
        const nums = (s)=>{ const n=parseFloat(String(Formula.valOf(s)||s)); return Number.isFinite(n)? Math.max(1, n|0) : 1; };
        const mFill = /ARRAY\(\s*\"fill\"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(f);
        if(mFill){ return { w:nums(mFill[1]), h:nums(mFill[2]), d:nums(mFill[3]||1) }; }
        const mBasic = /ARRAY\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?\)/i.exec(f);
        if(mBasic){ return { w:nums(mBasic[1]), h:nums(mBasic[2]), d:nums(mBasic[3]||1) }; }
        return null;
      };
      for(const ch of Object.values(arr.chunks||{})){
        for(const c of ch.cells||[]){
          if(!c?.formula) continue;
          const f=String(c.formula||'');
          if(/ARRAY\(/i.test(f)){
            const dims=parseDims(f); if(!dims) continue;
            queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, { type:'array', ...dims });
            return true;
          }
        }
      }
    }catch{}
    return false;
  }
  function buildTimedPlanFromArray(arr){
    try{
      const T = ensureTimedState(arr);
      // reset plan so sequencing/order changes are honored
      try{ if(Array.isArray(T.plan)) T.plan.length = 0; }catch{}
      const reNum = (s)=>{ const n = parseFloat(String(Formula.valOf(s)||s).replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? n : 0; };
      const parseDims=(f)=>{
        const mFill = /ARRAY\(\s*"fill"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(f);
        if(mFill){ return { w:Math.max(1,reNum(mFill[1])|0), h:Math.max(1,reNum(mFill[2])|0), d:Math.max(1,reNum(mFill[3]||1)|0) }; }
        const mBasic = /ARRAY\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?\)/i.exec(f);
        if(mBasic){ return { w:Math.max(1,reNum(mBasic[1])|0), h:Math.max(1,reNum(mBasic[2])|0), d:Math.max(1,reNum(mBasic[3]||1)|0) }; }
        return null;
      };
      for(const ch of Object.values(arr.chunks||{})){
        for(const c of ch.cells||[]){
          const f = String(c?.formula||''); if(!f) continue;
          if(/(?:3D_)?TRANSLATE(?:_ARRAY)?\(/i.test(f) || /TRANSLATE_ARRAY\(/i.test(f)){
            // Robust arg parsing: extract top-level args ignoring nested parens/addresses
            try{
              const start = f.search(/(?:3D_)?TRANSLATE(?:_ARRAY)?\(/i);
              if(start>=0){
                let i=start; while(i<f.length && f[i]!== '(') i++;
                if(i<f.length && f[i]==='('){
                  i++; let depth=0, cur=''; const args=[];
                  for(; i<f.length; i++){
                    const ch=f[i];
                    if(ch==='('){ depth++; cur+=ch; continue; }
                    if(ch===')'){
                      if(depth>0){ depth--; cur+=ch; continue; }
                      // end of arg list
                      args.push(cur.trim());
                      break;
                    }
                    if(ch===',' && depth===0){ args.push(cur.trim()); cur=''; continue; }
                    cur+=ch;
                  }
                  // take last three as dx,dy,dz
                  const n=args.length; if(n>=3){
                    const dxv = reNum(args[n-3]);
                    const dyv = reNum(args[n-2]);
                    const dzv = reNum(args[n-1]);
                    queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'translate', dx:dxv, dy:dyv, dz:dzv});
                  }
                }
              }
            }catch{}
          }
          if(/(?:3D_)?ROTATE(?:_ARRAY)?\(/i.test(f)){
            try{
              const start = f.search(/(?:3D_)?ROTATE(?:_ARRAY)?\(/i);
              if(start>=0){
                let i=start; while(i<f.length && f[i]!== '(') i++;
                if(i<f.length && f[i]==='('){
                  i++; let depth=0, cur=''; const args=[];
                  for(; i<f.length; i++){
                    const ch=f[i];
                    if(ch==='('){ depth++; cur+=ch; continue; }
                    if(ch===')'){
                      if(depth>0){ depth--; cur+=ch; continue; }
                      args.push(cur.trim());
                      break;
                    }
                    if(ch===',' && depth===0){ args.push(cur.trim()); cur=''; continue; }
                    cur+=ch;
                  }
                  // take last up to three as sx,sy,sz (ignore optional target at front)
                  const n=args.length;
                  const sx = n>=1 ? reNum(args[n-3] ?? 0) : 0;
                  const sy = n>=2 ? reNum(args[n-2] ?? 0) : 0;
                  const sz = n>=3 ? reNum(args[n-1] ?? 0) : 0;
                  queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'rotate', sx, sy, sz});
                }
              }
            }catch{}
          }
          // SHIFT(input, dx[, dy[, dz]]) -> treat as translate for previews
          if(/SHIFT\(/i.test(f)){
            const m = /SHIFT\(\s*[^,]+,\s*([^,]+)\s*(?:,\s*([^,]+)\s*)?(?:,\s*([^,]+)\s*)?\)/i.exec(f);
            if(m){ queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'translate', dx:reNum(m[1]||0), dy:reNum(m[2]||0), dz:reNum(m[3]||0)}); }
          }
          if(/TRANSPOSE\(/i.test(f)){
            queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'transpose'});
          }
          if(/ARRAY\(/i.test(f)){
            const dims = parseDims(f); if(dims){ queueTimedOp(arr, {x:c.x,y:c.y,z:c.z,arrId:arr.id}, {type:'array', ...dims}); }
          }
        }
      }
      return (ensureTimedState(arr).plan||[]).length>0;
    }catch{ return false; }
  }
  function configTimed(arr, cfg){
    const t = ensureTimedState(arr);
    t.ticks = Math.max(1, (cfg?.ticks|0) || 60);
    t.repeat = !!cfg?.repeat; t.reverse = !!cfg?.reverse; t.reverseTicks = (cfg?.reverseTicks==null? null : Math.max(1, cfg.reverseTicks|0));
    t.smooth = !!cfg?.smooth;
    t.t = 0; t.dir = 1;
    // Do not clear plan here; transforms add to plan when preview is ON
    t.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) };
    try{ t.baseQuat = (arr._frame?.quaternion?.clone?.()) || null; }catch{ t.baseQuat=null; }
  }
  function stopTimed(arr){
    const t=ensureTimedState(arr);
    t.previewInArray=false;
    // Restore base transforms
    try{ if(t.baseOffset){ setArrayOffset(arr, {x:t.baseOffset.x,y:t.baseOffset.y,z:t.baseOffset.z}, {interactive:true}); } }catch{}
    try{ if(arr._frame && t.baseQuat){ arr._frame.quaternion.copy(t.baseQuat); } }catch{}
    if(t.overlay){ try{ t.overlay.group.parent?.remove(t.overlay.group); }catch{}; t.overlay=null; }
    // Unmask array content after preview ends
    try{ maskArrayForPreview(arr, false); }catch{}
  }
  // Global 3D timed config (overworld movement)
  function ensureTimed3D(){
    const S=Store.getState();
    const sceneState = S.scene || ({});
    if(!sceneState.timed3D){
      sceneState.timed3D = { configured:false, ticks:60, repeat:false, reverse:false, reverseTicks:null, t:0, dir:1, preview:false, waitStart:0, waitEnd:0, _waitCounter:0 };
      Store.setState(s=>({scene:{...s.scene, timed3D: sceneState.timed3D}}));
    } else {
      if(typeof sceneState.timed3D.waitStart!=='number') sceneState.timed3D.waitStart = 0;
      if(typeof sceneState.timed3D.waitEnd!=='number') sceneState.timed3D.waitEnd = 0;
      if(typeof sceneState.timed3D._waitCounter!=='number') sceneState.timed3D._waitCounter = 0;
    }
    return sceneState.timed3D;
  }
  // Temporarily hide colored fills/formulas so expansion overlay is visible over white grid
  function maskArrayForPreview(arr, enable){
    try{
      arr._previewMask = arr._previewMask || { layerKeys:[], chunkLODs:[], chunkLOD2:[], chunkGhosts:[] };
      if(enable){
        // Hide underlying solids to create empty cell receptacles, but keep shells/ghosts for outline context
        if(Scene.ChunkManager && Scene.ChunkManager.enabled){
          Object.values(arr.chunks||{}).forEach(ch=>{
            // Hide LOD1 solids
            if(ch.meshLOD1 && ch.meshLOD1.visible){ arr._previewMask.chunkLODs.push(ch); ch.meshLOD1.visible=false; }
            // Keep shells for context; hide ghosts
            if(ch.meshGhost && ch.meshGhost.visible){ arr._previewMask.chunkGhosts.push(ch); ch.meshGhost.visible=false; }
            if(ch.meshLOD2 && ch.meshLOD2.visible){ arr._previewMask.chunkLOD2.push(ch); ch.meshLOD2.visible=false; }
          });
        } else {
        for(let z=0; z<arr.size.z; z++){
            // Hide filled/formula groups only (leave edges as outline)
            ['filled','formula','ghost'].forEach(type=>{
            const key = `${arr.id}:${z}:${type}`;
            const rec = layerMeshes.get(key);
            if(rec && rec.mesh && rec.mesh.visible){ arr._previewMask.layerKeys.push(key); rec.mesh.visible=false; }
          });
        }
        }
      } else {
        // Restore previously hidden meshes
        (arr._previewMask.layerKeys||[]).forEach(key=>{ const rec=layerMeshes.get(key); if(rec && rec.mesh) rec.mesh.visible=true; });
        (arr._previewMask.chunkLODs||[]).forEach(ch=>{ if(ch.meshLOD1) ch.meshLOD1.visible=true; });
        (arr._previewMask.chunkLOD2||[]).forEach(ch=>{ if(ch.meshLOD2) ch.meshLOD2.visible=true; });
        (arr._previewMask.chunkGhosts||[]).forEach(ch=>{ if(ch.meshGhost) ch.meshGhost.visible=true; });
        arr._previewMask = { layerKeys:[], chunkLODs:[], chunkLOD2:[], chunkGhosts:[] };
      }
    }catch{}
  }
  try{ Scene.maskArrayForPreview = maskArrayForPreview; }catch{}
  try{ Scene.addToScene = (obj)=>{ try{ if(obj) scene.add(obj); }catch{} }; }catch{}
  try{ Scene.removeFromScene = (obj)=>{ try{ obj?.parent?.remove(obj); }catch{} }; }catch{}
  try{ Scene.ensureTimedState = ensureTimedState; }catch{}
  try{ Scene.queueTimedOp = queueTimedOp; }catch{}
  try{ Scene.queueArrayPlanFromArray = queueArrayPlanFromArray; }catch{}
  try{ Scene.buildTimedPlanFromArray = buildTimedPlanFromArray; }catch{}
  try{ Scene.configTimed = configTimed; }catch{}
  try{ Scene.stopTimed = stopTimed; }catch{}
  try{ Scene.upsertCellLight = upsertCellLight; }catch{}
  try{ Scene.removeCellLight = removeCellLight; }catch{}
  try{ Scene.refreshLightsForArray = refreshLightsForArray; }catch{}
  try{ Scene.ensureTimed3D = ensureTimed3D; }catch{}
  function addTimedTranslation(arr, anchor, cfg){
    const { ticks=60, repeat=false, reverse=false, reverseTicks=null, op='' } = cfg||{};
    const group = new THREE.Group();
    group.userData.kind = 'procAnim';
    scene.add(group);

    const GREEN_MAT = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5, depthTest: true, depthWrite: false });
    const makeCell = (sx=0.9,sy=0.9,sz=0.9)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), GREEN_MAT.clone()); m.renderOrder=2100; return m; };
    const anchorArr = (anchor && anchor.arrId!=null && Store.getState().arrays && Store.getState().arrays[anchor.arrId]) || arr;
    const startPos = worldPos(anchorArr, anchor.x, anchor.y, anchor.z);

    // Parse op
    const text = String(op||'').trim();
    const reNum = (s)=>{ const n = parseFloat(String(s).replace(/[^0-9\-+.]/g,'')); return Number.isFinite(n)? n : 0; };
      const mTrans = /(?:3D_)?TRANSLATE(?:_ARRAY)?\(\s*(?:[^,]+\s*,\s*)?([^,]+)\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*\)/i.exec(text);
    const mRot = /(?:3D_)?ROTATE(?:_ARRAY)?\(\s*([^,)]*)\s*(?:,\s*([^,)]*)\s*)?(?:,\s*([^,)]*)\s*)?\)/i.exec(text);
    const mArrayFill = /ARRAY\(\s*"fill"\s*,\s*([^,]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+)\s*)?/i.exec(text);
    const isTranspose = /TRANSPOSE\(/i.test(text);

    let animType='translate';
    let params={};
    if(mTrans){ animType='translate'; params={ dx: reNum(mTrans[1]), dy: reNum(mTrans[2]), dz: reNum(mTrans[3]) }; }
    else if(mRot){ animType='rotate'; params={ sx: reNum(mRot[1]||0), sy: reNum(mRot[2]||0), sz: reNum(mRot[3]||0) }; }
    else if(mArrayFill){ animType='array'; params={ w: Math.max(1, reNum(mArrayFill[1])|0), h: Math.max(1, reNum(mArrayFill[2])|0), d: Math.max(1, reNum(mArrayFill[3]||1)|0) }; }
    else if(isTranspose){ animType='transpose'; params={}; }

    // Build visuals per type
    const record = { group, arrId:arr.id, anchor:{...anchor}, ticks:Math.max(1,ticks|0), repeat:!!repeat, reverse:!!reverse, reverseTicks: (reverseTicks==null? null : Math.max(1, reverseTicks|0)), t:0, dir:1, type:animType, params, _built:false };

    if(animType==='translate'){
      const cube = makeCell(); cube.position.copy(startPos); group.add(cube);
      record.update = (p)=>{
        cube.position.set(startPos.x + params.dx*p, startPos.y + params.dy*p, startPos.z + params.dz*p);
      };
      record.cleanup = ()=>{};
    } else if(animType==='rotate'){
      const cube = makeCell(); cube.position.copy(startPos); group.add(cube);
      const total = { x:(params.sx||0)*Math.PI/2, y:(params.sy||0)*Math.PI/2, z:(params.sz||0)*Math.PI/2 };
      record.update = (p)=>{
        cube.position.copy(startPos);
        cube.rotation.set(total.x*p, total.y*p, total.z*p);
      };
      record.cleanup = ()=>{};
    } else if(animType==='array'){
      const {w,h,d}=params; const cells=[];
      for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
        const c=makeCell(0.84,0.84,0.84);
        const wp = worldPos(arr, anchor.x+xx, anchor.y+yy, anchor.z+zz);
        c.position.copy(wp); c.visible=false; group.add(c); cells.push({mesh:c, xx, yy, zz});
      }
      record.update = (p)=>{
        // Expand simultaneously in X/Y(/Z) like pistons
        const nx = Math.max(1, Math.floor(1 + (w-1)*p));
        const ny = Math.max(1, Math.floor(1 + (h-1)*p));
        const nz = Math.max(1, Math.floor(1 + (d-1)*p));
        cells.forEach(({mesh,xx,yy,zz})=>{ 
          const vis = (xx < nx && yy < ny && zz < nz); 
          if(mesh.visible!==vis){ mesh.visible = vis; }
        });
      };
      record.cleanup = ()=>{
        try{
          // Merge all visible cubes into a single mesh instance
          const geos = [];
          cells.forEach(({mesh})=>{
            if(!mesh.visible) return;
            const g = mesh.geometry.clone();
            const m4 = new THREE.Matrix4(); m4.compose(mesh.position, mesh.quaternion, mesh.scale);
            g.applyMatrix4(m4);
            geos.push(g);
          });
          if(geos.length){
            const merged = (typeof BufferGeometryUtils!=='undefined' && BufferGeometryUtils.mergeGeometries) ? BufferGeometryUtils.mergeGeometries(geos, false) : null;
            const finalMat = new THREE.MeshBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.5, depthTest: true, depthWrite: false });
            const finalMesh = new THREE.Mesh(merged || geos[0], finalMat);
            finalMesh.renderOrder = 2100;
            // Clear children and replace with merged mesh to persist briefly
            while(group.children.length){ const ch = group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
            group.add(finalMesh);
            // Auto-remove after a short hold to avoid scene buildup
            setTimeout(()=>{ try{ scene.remove(group); finalMesh.geometry?.dispose?.(); finalMesh.material?.dispose?.(); }catch{} }, 800);
          }
        }catch{}
      };
    } else if(animType==='transpose'){
      // Minimal visualization: swap X/Y progressively for a 2D 1x1 marker moving toward its transposed target
      const marker = makeCell(0.7,0.7,0.7);
      marker.position.copy(startPos);
      group.add(marker);
      record.update = (p)=>{
        const from = startPos;
        // Default XY transpose for 1x1 marker: move diagonally half-cell for a hint
        const to = worldPos(arr, anchor.x, anchor.y, anchor.z).add(new THREE.Vector3(0.5,0.5,0));
        marker.position.lerpVectors(from, to, p);
      };
      record.cleanup = ()=>{};
    }

    proceduralAnims.push(record);
    return record;
  }
  // Expose under Scene for formula impls
  // Expose for external calls post-IIFE; also mirror on window for robustness
  try{ Scene.addTimedTranslation = addTimedTranslation; }catch{}
  try{ window.__addTimedTranslation = addTimedTranslation; }catch{}
  let lastFrame = 0;
  function animate(time){
    // Limit to 60fps and drive via single chain
    if(time - lastFrame < 16){ __rafId = requestAnimationFrame(animate); return; }
    lastFrame = time;
    try {
      updateDeleteEffects?.(16);
      
      if(rapierWorld && Store.getState().scene.physics && !physicsStepping){
      physicsStepping = true;
      try {
        // Skip stepping while colliders are rebuilding to avoid Rapier panics
        const anyBuilding = Object.values(Store.getState().arrays).some(a=>a?._collidersBuilding);
        if(anyBuilding){ physicsStepping=false; return; }
        // Update cached player position safely before any operations
        if(playerBody) {
          try {
            const translation = playerBody.translation();
            cachedPlayerPos.set(translation.x, translation.y, translation.z);
          } catch(e) {
            // If we can't get position, skip this frame
            physicsStepping = false;
            return;
          }
        } else {
          physicsStepping = false;
          return; // No player body
        }
        
        // --- START: ZIPLINE LOGIC ---        
        if(ziplineState.active){
          ziplineState.progress += 0.008; // Zipline speed
          const newPos = new THREE.Vector3().lerpVectors(ziplineState.start, ziplineState.end, ziplineState.progress);
          playerBody.setNextKinematicTranslation(newPos.x, newPos.y - 0.5, newPos.z);

          if(ziplineState.progress >= 1){
            ziplineState.active = false; // Detach at the end
          }
        } else {
          // Zipline attachment detection using cached position
          if(connections.size > 0) {
            const playerPos = cachedPlayerPos.clone();
            playerPos.y += 0.5; // Adjust for character controller center
            
            // Zipline attachment detection
            for(const [key, con] of connections.entries()){
              const line = new THREE.Line3(con.start, con.end);
              const closestPoint = new THREE.Vector3();
              line.closestPointToPoint(playerPos, true, closestPoint);
              const distance = playerPos.distanceTo(closestPoint);

              if(distance < 0.75){ // Attachment radius
                ziplineState.active = true;
                // Ziplines always go downhill. If level, based on entry.
                if(con.start.y > con.end.y){
                  ziplineState.start = con.start.clone();
                  ziplineState.end = con.end.clone();
                } else {
                  ziplineState.start = con.end.clone();
                  ziplineState.end = con.start.clone();
                }
                // Project player onto the line to find starting progress
                const lineDir = new THREE.Vector3().subVectors(ziplineState.end, ziplineState.start);
                const playerDir = new THREE.Vector3().subVectors(playerPos, ziplineState.start);
                ziplineState.progress = playerDir.dot(lineDir) / lineDir.lengthSq();
                break; // Attach to the first one found
              }
            }
          }
        }
        // --- END: ZIPLINE LOGIC ---

        // Projectile physics and collision detection
        const S = Store.getState();
        if (S.activeProjectiles.length > 0) {
          const newProjectiles = [];
          S.activeProjectiles.forEach(projectile => {
            // Update position
            projectile.pos.add(projectile.vel);
            
            // Check for collision with any array's cells
            let hit = false;
            Object.values(S.arrays).forEach(arr => {
              if(hit) return;
              Object.values(arr.chunks).forEach(chunk => {
                if(hit) return;
                chunk.cells.forEach(cell => {
                  if(hit || !cell.value) return;
                  const cellPos = worldPos(arr, cell.x, cell.y, cell.z);
                  const distance = projectile.pos.distanceTo(cellPos);
                  if(distance < 0.6) { // Collision radius
                    hit = true;
                    const cellKey = aKey({arrId: arr.id, x: cell.x, y: cell.y, z: cell.z});
                    const handler = S.collisionHandlers.get(cellKey);
                    if(handler) {
                      try {
                        const tx = Write.start('collision.handler', 'Projectile collision');
                        Formula.executeAt({arrId: arr.id, x: cell.x, y: cell.y, z: cell.z}, handler, tx);
                        Write.commit(tx);
                      } catch(e) {
                        console.error('Collision handler error:', e);
                      }
                    }
                  }
                });
              });
            });
            
            // Keep projectile if no collision and still in bounds
            if(!hit && projectile.pos.length() < 100) {
              newProjectiles.push(projectile);
            }
          });
          Store.setState({ activeProjectiles: newProjectiles });
        }

        // Simple direct movement without complex character controller
        if(!ziplineState.active && (input.f||input.b||input.l||input.r)){
          if(playerBody){
            try {
              const dir=new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
              const right=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)).normalize();
              const speed = 0.1;
              
              let dx = 0, dz = 0;
              dx += dir.x*(input.f-input.b) + right.x*(input.r-input.l);
              dz += dir.z*(input.f-input.b) + right.z*(input.r-input.l);
              
              // Direct kinematic movement without character controller
              const newX = cachedPlayerPos.x + dx * speed;
              const newZ = cachedPlayerPos.z + dz * speed;
              
              playerBody.setNextKinematicTranslation(newX, cachedPlayerPos.y, newZ);
              cachedPlayerPos.set(newX, cachedPlayerPos.y, newZ);
            } catch(e) {
              console.warn('Simple physics movement failed:', e);
              // Disable physics on repeated failures
              if(!e._physicsFailed) {
                e._physicsFailed = true;
                Store.setState(s => ({scene: {...s.scene, physics: false}}));
                document.getElementById('physChip').textContent = 'Physics: OFF (error)';
              }
            }
          }
        }

        // Basic physics step without complex collision
        if(!ziplineState.active){
          try {
            // Apply jump if requested
            if(input.j){ handleJump(); }
      rapierWorld.step();
            // follow camera using cached position (target + position)
      if(playerBody){
              const t = new THREE.Vector3(cachedPlayerPos.x, cachedPlayerPos.y+0.8, cachedPlayerPos.z);
              controls.target.lerp(t, 0.12);
              const desired = new THREE.Vector3(t.x+6, t.y+3.2, t.z+7.5);
              if(Number.isFinite(desired.x) && Number.isFinite(desired.y) && Number.isFinite(desired.z)){
                camera.position.lerp(desired, 0.10);
              } else {
                centerOnPlayer();
              }
            }
          } catch(e) {
            console.warn('Physics step failed:', e);
            // Disable physics on repeated failures
            Store.setState(s => ({scene: {...s.scene, physics: false}}));
            document.getElementById('physChip').textContent = 'Physics: OFF (error)';
          }
        }
      } finally {
        physicsStepping = false;
      }
    }
    // Optimized occlusion: recompute only when camera-facing changes; clear stale occlusion on array/facing change
    if(!animate.lastOcclusionState) animate.lastOcclusionState = {};
    const s=Store.getState().selection;
    const clearOcclusion = (arr)=>{
      if(!arr) return;
      delete arr._occlusionData;
      // Remove all ghost groups explicitly so we don't leave transparent overlays
      for(let z=0; z<arr.size.z; z++){
        ['ghost'].forEach(type=>{
          const base=`${arr.id}:${z}:${type}`;
          const rec=layerMeshes.get(base); if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry.dispose(); rec.mesh.material.dispose(); layerMeshes.delete(base); }
          const ekey=`${base}:edges`; const er=layerMeshes.get(ekey); if(er){ if(arr._frame) arr._frame.remove(er.mesh); else scene.remove(er.mesh); er.mesh.geometry.dispose(); er.mesh.material.dispose(); layerMeshes.delete(ekey); }
        });
      }
      for(let z=0; z<arr.size.z; z++) renderLayer(arr,z);
    };
    const viewMode = (Store.getState().ui && Store.getState().ui.viewMode) || 'standard';
    if(viewMode==='standard' && s.arrayId && s.focus){
      const arr=Store.getState().arrays[s.arrayId];
      updateFacingState(arr);
      computeOcclusion(arr, s.focus);
      const facing = arr._occlusionData?.axis || 'Z';
      const frontLayer = arr._occlusionData?.frontLayer || 0;
      const focusLayer = arr._occlusionData?.focusLayer || 0;

      const signature = `${s.arrayId}:${facing}:${frontLayer}:${focusLayer}`;
      const prevSig = animate.lastOcclusionState.signature;
      if(prevSig && prevSig.split(':')[0] !== String(s.arrayId)){
        // Active array changed: clear occlusion on previous array
        const prevArrId = +prevSig.split(':')[0];
        const prevArr = Store.getState().arrays[prevArrId];
        clearOcclusion(prevArr);
      }
      if(prevSig && prevSig.split(':')[1] !== facing){
        // Facing axis changed: clear old occlusion data before applying new
        clearOcclusion(arr);
        // Also clear overlays/ghosts explicitly for this array
        for(let z=0; z<arr.size.z; z++){
          ['empty','ghost','filled','formula'].forEach(type=>{
            const base=`${arr.id}:${z}:${type}`;
            const rec=layerMeshes.get(base); if(rec){ if(arr._frame) arr._frame.remove(rec.mesh); else scene.remove(rec.mesh); rec.mesh.geometry.dispose(); rec.mesh.material.dispose(); layerMeshes.delete(base); }
            const ekey=`${base}:edges`; const er=layerMeshes.get(ekey); if(er){ if(arr._frame) arr._frame.remove(er.mesh); else scene.remove(er.mesh); er.mesh.geometry.dispose(); er.mesh.material.dispose(); layerMeshes.delete(ekey); }
          });
        }
      }

      if(animate.lastOcclusionState.signature !== signature){
        animate.lastOcclusionState.signature = signature;
        const blockedLayers = new Set();
        // Block slabs from the observer-facing front THROUGH to just before the focus slab (include front, exclude focus)
        if(facing==='Z'){
          if(frontLayer < focusLayer){ for(let L=frontLayer; L<focusLayer; L++) blockedLayers.add(L); }
          else if(frontLayer > focusLayer) { for(let L=frontLayer; L>focusLayer; L--) blockedLayers.add(L); }
        } else if(facing==='X'){
          if(frontLayer < focusLayer){ for(let L=frontLayer; L<focusLayer; L++) blockedLayers.add(L); }
          else if(frontLayer > focusLayer) { for(let L=frontLayer; L>focusLayer; L--) blockedLayers.add(L); }
        } else if(facing==='Y'){
          if(frontLayer < focusLayer){ for(let L=frontLayer; L<focusLayer; L++) blockedLayers.add(L); }
          else if(frontLayer > focusLayer) { for(let L=frontLayer; L>focusLayer; L--) blockedLayers.add(L); }
        }

        const prevBlocked = animate.lastOcclusionState.blockedLayers || new Set();
        arr._occlusionData = { facing, blockedLayers };
        // Re-render layers. For Z we can do targeted rerender; for X/Y rerender all Z slices (renderLayer filters per-cell)
        if(facing==='Z'){
          for(let z=0; z<arr.size.z; z++){
            const was = prevBlocked.has(z); const now = blockedLayers.has(z);
            if(was !== now) renderLayer(arr, z);
          }
        } else {
          for(let z=0; z<arr.size.z; z++) renderLayer(arr, z);
        }
        animate.lastOcclusionState.blockedLayers = blockedLayers;
        // Apply mask immediately to avoid a one-frame flash
        if (Scene.ChunkManager && Scene.ChunkManager.enabled) {
          try{ applyGhostMaskToChunks(arr); }catch{}
        }
      }
    }
    // Update per-array timed gamestate animations and apply planned transforms
    try{
      const arrays = Object.values(Store.getState().arrays||{});
      // Global 3D timed progression (overworld)
      const G = (Store.getState().scene||{}).timed3D;
      let p3D = 0;
      if(G && G.preview){
        // Default configuration if none provided via 3D_TIMED_TRANSLATION
        if(!G.ticks){ G.ticks=240; G.reverseTicks=G.reverseTicks||G.ticks; G.dir=1; G.t=0; }
        if(typeof G._waitCounter!=='number') G._waitCounter = 0;
        const dur3D = (G.dir>0? G.ticks : (G.reverseTicks||G.ticks));
        let r3D = 0;
        // Wait-at-start: hold time; still render p3D=0 so arrays snap to base
        if(G.dir>0 && G.t===0 && (G.waitStart|0) > 0 && G._waitCounter < (G.waitStart|0)){
          G._waitCounter++;
          p3D = 0;
          r3D = 0;
        } else {
          G.t = (G.t + 1);
          r3D = Math.min(1, G.t/Math.max(1,dur3D));
          p3D = (G.dir>0? r3D : (1-r3D));
        }
        if(r3D>=1){
          // Wait-at-end before reversing or looping
          if((G.waitEnd|0) > 0 && G._waitCounter < (G.waitEnd|0)){
            G._waitCounter++;
            __rafId = requestAnimationFrame(animate); return;
          }
          G._waitCounter = 0;
          if(G.reverse && G.dir>0){ G.dir=-1; G.t=0; }
          else if(G.repeat){ G.dir=1; G.t=0; }
          else {
            // Stop preview: restore each array's base state
            G.preview=false;
            try{
              Object.values(Store.getState().arrays||{}).forEach(a=>{
                const T = a?.params?.timed; if(!T) return;
                if(T.baseOffset){ setArrayOffset(a, {x:T.baseOffset.x,y:T.baseOffset.y,z:T.baseOffset.z}, {interactive:true}); }
                if(a._frame && T.baseQuat){ a._frame.quaternion.copy(T.baseQuat); }
              });
            }catch{}
          }
        }
      }
      // Per-array timed: config exists; animate only if previewInArray is enabled
      for(const arr of arrays){
        if(!arr) continue; const T = arr.params && arr.params.timed; if(!T) continue;
        if(T.previewInArray){
          const dur = (T.dir>0? T.ticks : (T.reverseTicks||T.ticks));
          T.t = (T.t + 1);
          const r = Math.min(1, T.t / Math.max(1,dur));
          const p = (T.dir>0 ? r : (1 - r));
          // Ensure timing defaults are sane even if only PREVIEW was called
          if(!T.ticks) { T.ticks = 120; }
          // Ensure baseOffset captured once to compute from starting state
          if(!T.baseOffset){ T.baseOffset = { ...(arr.offset||{x:0,y:0,z:0}) }; }
          // Ensure a timed plan exists; if not, derive from formulas
          if(!T.plan.length){ try{ (Scene.buildTimedPlanFromArray||buildTimedPlanFromArray)(arr); }catch{} }
          // Green overlays for transformed cells only; ensure overlays draw over everything
          if(T.overlay){
            // Clear previous overlay contents
            while(T.overlay.group.children.length){ const ch=T.overlay.group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); }
            const mat = new THREE.MeshBasicMaterial({ color:0x22c55e, transparent:true, opacity:0.72, depthTest:true, depthWrite:false });
            const overlayGeo = new RoundedBoxGeometry(0.94,0.94,0.94, 2, 0.12);
            const parentIsFrame = (T.overlay.group.parent === arr._frame);

            // Group plan by anchor so we emit overlays from each respective anchor
            const keyOf = (a)=> a? `${a.arrId}:${a.x},${a.y},${a.z}` : null;
            const groups = new Map();
              for(const op of T.plan){
              const k = keyOf(op.anchor);
              if(!k) continue;
              if(!groups.has(k)) groups.set(k, { anchor:{...op.anchor}, tx:0,ty:0,tz:0, rsx:0,rsy:0,rsz:0, hasTranspose:false, dims:{w:1,h:1,d:1} });
              const g = groups.get(k);
              if(op.type==='translate'){ g.tx += (op.dx||0); g.ty += (op.dy||0); g.tz += (op.dz||0); }
              else if(op.type==='rotate'){ g.rsx += (op.sx||0); g.rsy += (op.sy||0); g.rsz += (op.sz||0); }
              else if(op.type==='transpose'){ g.hasTranspose = true; }
              else if(op.type==='array'){ g.dims.w = Math.max(1,op.w|0); g.dims.h = Math.max(1,op.h|0); g.dims.d = Math.max(1,op.d|0); }
            }

            const lerp01=(a,b,t)=> a.clone().multiplyScalar(1-t).add(b.clone().multiplyScalar(t));
            const XU = new THREE.Vector3(1,0,0);
            const YU = new THREE.Vector3(0,-1,0);
            const ZU = new THREE.Vector3(0,0,-1);
            for(const g of groups.values()){
              const baseAnchor = g.anchor || {x:0,y:0,z:0,arrId:arr.id};
              const anchorArr = (baseAnchor.arrId!=null && Store.getState().arrays && Store.getState().arrays[baseAnchor.arrId]) || arr;
              let {w,h,d} = g.dims;
              if(w===1 && h===1 && d===1){
                try{
                  const nonEmpty=(x,y,z)=>{ const c=Formula.getCell({arrId:anchorArr.id,x,y,z}); return !!(c && (c.formula || (c.value!=='' && c.value!==null && c.value!==undefined))); };
                  let ww=1,hh=1,dd=1;
                  for(let x=baseAnchor.x+1; x<anchorArr.size.x; x++){ if(!nonEmpty(x,baseAnchor.y,baseAnchor.z)) break; ww++; }
                  for(let y=baseAnchor.y+1; y<anchorArr.size.y; y++){ if(!nonEmpty(baseAnchor.x,y,baseAnchor.z)) break; hh++; }
                  for(let z=baseAnchor.z+1; z<anchorArr.size.z; z++){ if(!nonEmpty(baseAnchor.x,baseAnchor.y,z)) break; dd++; }
                  w=ww; h=hh; d=dd;
                }catch{}
              }

              const anchorL = localPos(anchorArr, baseAnchor.x, baseAnchor.y, baseAnchor.z);
              const leg = (T.dir>0? p : (1-p));
              const angX = (g.rsx*90)*(Math.PI/180) * leg;
              const angY = (g.rsy*90)*(Math.PI/180) * leg;
              const angZ = (g.rsz*90)*(Math.PI/180) * leg;
              // Match actual rotation semantics: world-axis rotations premultiplied (like rotateOnWorldAxis)
              const qxL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), angX);
              const qyL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), angY);
              const qzL = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), angZ);
              const qWorldL = qzL.clone().multiply(qyL).multiply(qxL); // Z * Y * X (world, premultiply order)
              const baseQL = (arr._frame?.quaternion?.clone?.()) || new THREE.Quaternion();
              const qLocal = baseQL.clone().invert().multiply(qWorldL).multiply(baseQL);
              const legShift = (T.dir>0? p : (1-p));
              const shiftL = XU.clone().multiplyScalar((g.tx||0)*legShift)
                .add(YU.clone().multiplyScalar((g.ty||0)*legShift))
                .add(ZU.clone().multiplyScalar((g.tz||0)*legShift));

              const hasTranspose = !!g.hasTranspose;
              const hasDataAt=(ix,iy,iz)=>{
                try{
                  const c=Formula.getCell({arrId:anchorArr.id, x:baseAnchor.x+ix, y:baseAnchor.y+iy, z:baseAnchor.z+iz});
                  return !!(c && (c.formula || (c.value!=='' && c.value!==null && c.value!==undefined)));
                }catch{ return false; }
              };
              for(let zz=0; zz<d; zz++) for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++){
                if(!hasDataAt(xx,yy,zz)) continue;
                const idx = new THREE.Vector3(xx, yy, zz);
                const swapped = new THREE.Vector3(idx.y, idx.x, idx.z);
                const tIdx = hasTranspose ? lerp01(idx, swapped, p) : idx.clone();
                let offL = XU.clone().multiplyScalar(tIdx.x)
                  .add(YU.clone().multiplyScalar(tIdx.y))
                  .add(ZU.clone().multiplyScalar(tIdx.z));
                const primaryAxis = (h>1) ? 'y' : ((w>1) ? 'x' : 'z');
                const primaryDim  = primaryAxis==='x' ? w : primaryAxis==='y' ? h : d;
                const k = (primaryAxis==='x'? xx : primaryAxis==='y'? yy : zz);
                const pCell = Math.max(0, Math.min(1, p*primaryDim - k));
                offL.applyQuaternion(qLocal);
                offL.add(shiftL);
                offL.multiplyScalar(pCell);
                const posL = anchorL.clone().add(offL);
                let out = posL.clone();
                if(arr !== anchorArr){
                  try{
                    let worldPos = posL.clone();
                    if(anchorArr._frame){ worldPos = posL.clone(); anchorArr._frame.localToWorld(worldPos); }
                    else { const offA = anchorArr.offset||{x:0,y:0,z:0}; worldPos.add(new THREE.Vector3(offA.x,offA.y,offA.z)); }
                    if(parentIsFrame){
                      if(arr._frame){ out = worldPos.clone(); arr._frame.worldToLocal(out); }
                      else { const offB = arr.offset||{x:0,y:0,z:0}; out = worldPos.clone().sub(new THREE.Vector3(offB.x,offB.y,offB.z)); }
                    } else {
                      out = worldPos.clone();
                    }
                  }catch{}
                } else if(!parentIsFrame){
                  if(arr._frame){ out = posL.clone(); arr._frame.localToWorld(out); }
                  else { const off = arr.offset||{x:0,y:0,z:0}; out.add(new THREE.Vector3(off.x,off.y,off.z)); }
                }
                const mesh = new THREE.Mesh(overlayGeo, mat.clone()); mesh.renderOrder=9999; mesh.position.copy(out); T.overlay.group.add(mesh);
              }
            }

            // If no plan, place a single placeholder at a reasonable anchor (focus or origin)
            if(T.plan.length===0){
              const sel=Store.getState().selection; const baseAnchor = sel?.arrayId===arr.id && sel.focus ? {...sel.focus, arrId:arr.id} : {x:0,y:0,z:0,arrId:arr.id};
              const anchorL = localPos(arr, baseAnchor.x, baseAnchor.y, baseAnchor.z);
              const mesh = new THREE.Mesh(overlayGeo, mat.clone()); mesh.renderOrder=9999; mesh.position.copy(parentIsFrame? anchorL : (arr._frame? anchorL.clone().applyMatrix4(arr._frame.matrixWorld) : anchorL.clone().add(new THREE.Vector3((arr.offset?.x||0),(arr.offset?.y||0),(arr.offset?.z||0)))) ); T.overlay.group.add(mesh);
            }
          }
          // End/loop logic — snap back to exact start when a leg completes
          if(r>=1){
            // Reset time BEFORE flipping dir so the next frame starts at p=0/1 cleanly
            T.t = 0;
            if(T.reverse && T.dir>0){ T.dir=-1; }
            else if(T.repeat){ T.dir=1; }
            else {
              // one-shot: clear overlay after brief hold and unmask content
              setTimeout(()=>{ try{ while(T.overlay.group.children.length){ const ch=T.overlay.group.children.pop(); ch.geometry?.dispose?.(); ch.material?.dispose?.(); } }catch{} }, 120);
              try{ T.overlay.group.parent?.remove(T.overlay.group); }catch{}
              T.overlay=null;
              try{ maskArrayForPreview(arr,false); }catch{}
            }
          }
        }
        // If global 3D preview is enabled, apply full-array motion using the same plan and p3D
          if(G && G.preview && T){
          if(!T.plan.length){ buildTimedPlanFromArray(arr); }
          if(!T.plan.length){ continue; }
          if(!T.baseOffset){
            // Reset base to current on first preview frame
            T.baseOffset={...(arr.offset||{x:0,y:0,z:0})};
            try{ if(arr._frame) T.baseQuat = arr._frame.quaternion.clone(); else T.baseQuat = new THREE.Quaternion(); }catch{ T.baseQuat=new THREE.Quaternion(); }
          }
            let tx=0,ty=0,tz=0; let hasTranspose=false; let smooth=false;
            // Stack only translates/transpose from plan; rotation will use applied steps snapshot
          for(const op of T.plan){
            if(op.type==='translate'){ tx+=(op.dx||0); ty+=(op.dy||0); tz+=(op.dz||0); }
            else if(op.type==='transpose'){ hasTranspose=true; }
          }
            // Smooth vs stepped from global or local timed configuration
            smooth = !!((Store.getState().scene?.timed3D?.smooth) || T.smooth);
            // Compute unified translate+rotate around pivot: prefer applied rotation record's pivot
            let pivotLocal = new THREE.Vector3(0,0,0);
            try{
              const S = Store.getState();
              let found=null;
              (S.activeRotations||new Map()).forEach((rec)=>{
                if(found) return;
                if(rec && (rec.targetId===arr.id || (Array.isArray(rec.ids) && rec.ids.includes(arr.id)))) found = rec;
              });
              if(found && found.pivot){ pivotLocal = localPos(arr, found.pivot.x, found.pivot.y, found.pivot.z); }
              else {
                const rotOp = (T.plan||[]).find(op=>op.type==='rotate');
                if(rotOp && rotOp.anchor) pivotLocal = localPos(arr, rotOp.anchor.x, rotOp.anchor.y, rotOp.anchor.z);
              }
            }catch{}
            if(!arr._frame) Scene.renderArray(arr);
            if(!T.baseQuat){ T.baseQuat = arr._frame?.quaternion?.clone?.() || new THREE.Quaternion(); }
            const baseRotPivot = pivotLocal.clone().applyQuaternion(T.baseQuat);
            // Rotation progress and quaternion (snapshot of applied rotation steps; inverse toward pre-transform)
            const steps = arr.rotationSteps || {x:0,y:0,z:0};
            const rotProg = smooth ? (1 - p3D) : (1 - (Math.round(p3D*4)/4));
            const ax = (steps.x|0) * (Math.PI/2) * rotProg;
            const ay = (steps.y|0) * (Math.PI/2) * rotProg;
            const az = (steps.z|0) * (Math.PI/2) * rotProg;
            const qx = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -ax);
            const qy = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -ay);
            const qz = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -az);
            const dq = qz.clone().multiply(qy).multiply(qx); // Z^- * Y^- * X^- pre-multiply (world order)
            const newQuat = dq.clone().multiply(T.baseQuat);
            const newRotPivot = pivotLocal.clone().applyQuaternion(newQuat);
            // Translation progress (preview un-applies first, then returns to final)
            let dxp=0,dyp=0,dzp=0;
            if(smooth){
              dxp = -tx * (1 - p3D); dyp = -ty * (1 - p3D); dzp = -tz * (1 - p3D);
            } else {
              dxp = tx!==0 ? (Math.round(T.baseOffset.x - tx*(1-p3D)) - T.baseOffset.x) : 0;
              dyp = ty!==0 ? (Math.round(T.baseOffset.y - ty*(1-p3D)) - T.baseOffset.y) : 0;
              dzp = tz!==0 ? (Math.round(T.baseOffset.z - tz*(1-p3D)) - T.baseOffset.z) : 0;
            }
            const disp = new THREE.Vector3(dxp,dyp,dzp);
            const newOffset = new THREE.Vector3(T.baseOffset.x, T.baseOffset.y, T.baseOffset.z)
              .add(disp)
              .add(baseRotPivot)
              .sub(newRotPivot);
            setArrayOffset(arr, {x:newOffset.x, y:newOffset.y, z:newOffset.z}, {interactive:true});
            try{ arr._frame.quaternion.copy(newQuat); }catch{}
          // Minimal transpose preview: slight XY swap tilt to indicate operation
          if(hasTranspose){
            try{
              if(!arr._frame) Scene.renderArray(arr);
              // apply a gentle XY tilt oscillation based on p3D
              const tilt = 0.20 * Math.sin(p3D*Math.PI);
              arr._frame.rotation.set(tilt, arr._frame.rotation.y, -tilt);
            }catch{}
          }
        } else if(G && !G.preview && T){
          // Non-preview: arrays should already be at their one-time end state from 3D_TRANSLATE/3D_ROTATE.
          // Do not re-apply or enforce here to avoid double transforms.
        }
      }
    }catch{}

    // Update procedural animations (overlay previews only)
    try{
      for(let i=proceduralAnims.length-1; i>=0; i--){
        const a = proceduralAnims[i];
        const dur = (a.dir>0? a.ticks : (a.reverseTicks||a.ticks));
        a.t = (a.t + 1);
        const pRaw = Math.min(1, a.t / Math.max(1,dur));
        const p = (a.dir>0 ? pRaw : (1 - pRaw));
        if(a.update) a.update(p);
        if(pRaw >= 1){
          if(a.reverse && a.dir>0){ a.dir = -1; a.t = 0; continue; }
          if(a.repeat){ a.dir = 1; a.t = 0; continue; }
          // Done
          let handled = false;
          try{ if(a.cleanup) handled = !!a.cleanup(); }catch{}
          if(!handled){ try{ a.group.parent?.remove(a.group); }catch{} }
          proceduralAnims.splice(i,1);
        }
      }
    }catch{}

    controls.update();
    // Optional dynamic chunk LOD
    try{ ChunkManager.update(); }catch{}

    if(FancyGraphics.enabled){
      const dtFancy = FancyGraphics.clock ? FancyGraphics.clock.getDelta() : 0;
      if(FancyGraphics.groups.waveGrid?.material?.uniforms?.time){
        FancyGraphics.groups.waveGrid.material.uniforms.time.value += dtFancy;
      }
      if(FancyGraphics.mirrorUniforms?.time){
        FancyGraphics.mirrorUniforms.time.value += dtFancy;
      }
      if(FancyGraphics.passes.bokeh?.uniforms?.focus){
        FancyGraphics.passes.bokeh.uniforms.focus.value = camera.position.distanceTo(controls.target);
      }
      if(FancyGraphics.passes.outline){
        if(FancyGraphics.settings.outlineEnabled && focusMarker.visible){
          FancyGraphics.passes.outline.selectedObjects = [focusMarker];
        } else {
          FancyGraphics.passes.outline.selectedObjects = [];
        }
      }
    }

    if(FancyGraphics.enabled && FancyGraphics.composer){
      FancyGraphics.composer.render();
    } else {
      renderer.render(scene,camera); // Simple rendering in build mode
    }
    try{ if(!window.__RENDER_READY){ window.__RENDER_READY = true; } }catch{}
    } finally {
      // Always schedule the next frame, even on early returns inside try blocks
      __rafId = requestAnimationFrame(animate);
    }
  }
  let dragState=null;
  function onPick(e){
    if(deleteInteractionLock) return;
    const rect=renderer.domElement.getBoundingClientRect();
    const mouse=new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -((e.clientY-rect.top)/rect.height)*2+1);
    const ray=new THREE.Raycaster(); ray.setFromCamera(mouse,camera);
    // Legacy layer meshes (still used for some visuals)
    const layerPickMeshes = [...layerMeshes.values()].map(r=>r.mesh).filter(m=>m.visible && !m.userData.isGhost);
    // Include chunk LOD1 meshes so picking works even when layer meshes are cleared
    const chunkPickMeshes = [];
    try{
      Object.values(Store.getState().arrays).forEach(a=>{
        if(a.hidden) return;
        Object.values(a.chunks||{}).forEach(ch=>{ if(ch?.meshLOD1 && ch.meshLOD1.visible) chunkPickMeshes.push(ch.meshLOD1); });
      });
    }catch{}
    // also pick grab handles
    const grabHandles = Object.values(Store.getState().arrays).flatMap(a=> (a.labels||[]).filter(l=>l.userData?.type==='grab'));
    // Intersect both voxels and grab handles; prefer nearest, but allow grab when tied
    const hits=ray.intersectObjects([...layerPickMeshes, ...chunkPickMeshes, ...grabHandles],false);
    if(!hits.length) return;
    // Always prefer the grab handle if it is hit at all
    const grabHit = hits.find(h => h.object?.userData?.type==='grab');
    let hit = grabHit || hits.find(h => (h.object && h.object.isInstancedMesh && typeof h.instanceId === 'number')) || hits[0];
    if(hit.object.userData?.type==='grab'){
      // begin array reposition drag
      const arr=Store.getState().arrays[hit.object.userData.arrayId];
      if(!arr) return;
      const startOff={...(arr.offset||{x:0,y:0,z:0})};
      // Determine movement plane from clicked face normal
      const nLocal = hit.face?.normal?.clone()||new THREE.Vector3(0,1,0);
      const nWorld = nLocal.clone().transformDirection(hit.object.matrixWorld).normalize();
      let planeNormal=new THREE.Vector3(0,1,0);
      if(Math.abs(nWorld.x) > Math.abs(nWorld.y) && Math.abs(nWorld.x) > Math.abs(nWorld.z)) planeNormal.set(1,0,0); // YZ plane
      else if(Math.abs(nWorld.y) > Math.abs(nWorld.x) && Math.abs(nWorld.y) > Math.abs(nWorld.z)) planeNormal.set(0,1,0); // XZ plane
      else planeNormal.set(0,0,1); // XY plane
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, hit.point);
      const startPoint = new THREE.Vector3(); ray.ray.intersectPlane(plane,startPoint);
      // lock orbit controls during drag
      controls.enableRotate=false; controls.enablePan=false; 
      const onMove=(ev)=>{
        const r=renderer.domElement.getBoundingClientRect();
        const m=new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
        const r2=new THREE.Raycaster(); r2.setFromCamera(m,camera);
        const p2=new THREE.Vector3(); r2.ray.intersectPlane(plane,p2);
        // Grid-snapped movement on the two axes of the chosen plane
        const delta = new THREE.Vector3().subVectors(p2,startPoint);
        let nx=startOff.x, ny=startOff.y, nz=startOff.z;
        const snap = (axis, raw)=>{
          const s = axis==='x'?arr.size.x : axis==='y'?arr.size.y : arr.size.z;
          const base = (axis==='z') ? (s/2 - 0.5) : (-(s/2) + 0.5);
          return Math.round(raw + base) - base; // align world centers irrespective of parity
        };
        if(planeNormal.y===1||planeNormal.y===-1){ // XZ plane
          nx = snap('x', startOff.x + delta.x);
          nz = snap('z', startOff.z + delta.z);
        } else if(planeNormal.x===1||planeNormal.x===-1){ // YZ plane
          ny = snap('y', startOff.y + delta.y);
          nz = snap('z', startOff.z + delta.z);
        } else { // XY plane
          nx = snap('x', startOff.x + delta.x);
          ny = snap('y', startOff.y + delta.y);
        }
        // Interactive drag: apply immediately and skip wobble to keep 60fps
        setArrayOffset(arr, {x:nx, y:ny, z:nz}, {interactive:true});
      };
      const onUp=()=>{ controls.enableRotate=true; controls.enablePan=true; window.removeEventListener('pointermove',onMove); window.removeEventListener('pointerup',onUp); try{ const cur=arr.offset||{x:0,y:0,z:0}; const dir={ dx: Math.sign((cur.x||0)-(startOff.x||0)), dy: Math.sign((cur.y||0)-(startOff.y||0)), dz: Math.sign((cur.z||0)-(startOff.z||0)) }; settleAfterDrag(arr, dir); }catch{} };
      window.addEventListener('pointermove',onMove); window.addEventListener('pointerup',onUp);
      return;
    }
    // nav pad interactions removed (HUD only)
    let arrayId = hit.object.userData.arrayId;
    let arr = Store.getState().arrays[arrayId];
    let cell = null; let z = null;
    if(hit.object.userData && hit.object.userData.chunk){
      const chunk = hit.object.userData.chunk;
      cell = chunk?.index2cell?.[hit.instanceId];
      z = cell?.z;
    } else {
      const z0 = hit.object.userData.z, type0 = hit.object.userData.type;
      const rec = layerMeshes.get(`${arrayId}:${z0}:${type0}`);
      cell = rec?.index2cell?.[hit.instanceId];
      z = z0;
    }
    
    // If the picked cell has an ONCLICK action, execute it immediately (3D)
    if(!cell) return;
    let decodedAction = '';
    let hasAction = false;
    try{
      const c2d = UI.getCell(arr.id, {x:cell.x,y:cell.y,z:cell.z});
      let actionRaw = String(c2d?.meta?.onClick||'').trim();
      if(actionRaw){
        hasAction = true;
        if(actionRaw.startsWith('B64:')){
          try{ actionRaw = atob(actionRaw.slice(4)); }catch{}
        } else {
          const colon=actionRaw.indexOf(':');
          if(colon>0 && /^\d+$/.test(actionRaw.slice(0,colon))){
            const enc=actionRaw.slice(colon+1);
            try{ actionRaw = atob(enc); }catch{}
          }
        }
        decodedAction = actionRaw.startsWith('=') ? actionRaw : `=${actionRaw}`;
      }
    }catch{}

    if(!(hasAction && formulaHasChime(decodedAction))){ playCellClick(); }
    try{
      if(hasAction && decodedAction){
        const tx = Write.start('onclick.3d','Click action (3D)');
        Formula.runOnceAt({arrId:arr.id,x:cell.x,y:cell.y,z:cell.z}, decodedAction, tx);
        Write.commit(tx);
        // Visual feedback pulse
        try{ pulseCell(arr, cell, z); }catch{}
        // Do not return; continue to also select the cell
      }
    }catch{}

    // Start drag-select in 3D with playful click feedback (scale pulse)
    dragState={arrayId:arr.id, start:{x:cell.x,y:cell.y,z:cell.z}};
    Actions.setSelection(arr.id, {x:cell.x,y:cell.y,z:cell.z}, null, '3d');
    try{ pulseCell(arr, cell, z); }catch{}
    // Freeze orbit while dragging
    controls.enableRotate=false; controls.enablePan=false;
    
    const onMove=(ev)=>{
      if(!dragState) return;
      const r=renderer.domElement.getBoundingClientRect();
      const m=new THREE.Vector2(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
      ray.setFromCamera(m,camera);
      const h=ray.intersectObjects([...layerPickMeshes, ...chunkPickMeshes], false);
      if(h.length){
        const hh=h[0];
        let aid = hh.object.userData.arrayId;
        let cel = null; let z = null;
        if(hh.object.userData && hh.object.userData.chunk){
          const ch = hh.object.userData.chunk;
          aid = ch?.array?.id || aid;
          cel = ch?.index2cell?.[hh.instanceId];
          z = cel?.z;
        } else {
          const z0 = hh.object.userData.z; const type0 = hh.object.userData.type;
          const rec2 = layerMeshes.get(`${aid}:${z0}:${type0}`);
          cel = rec2?.index2cell?.[hh.instanceId];
          z = z0;
        }
        if(!cel) return;
        if(aid===dragState.arrayId){
          Actions.setSelectionRange(dragState.arrayId, dragState.start, {x:cel.x,y:cel.y,z:z}); 
        }
      }
    };
    const onUp=()=>{ dragState=null; controls.enableRotate=true; controls.enablePan=true; window.removeEventListener('pointermove',onMove); window.removeEventListener('pointerup',onUp); };
    window.addEventListener('pointermove',onMove); window.addEventListener('pointerup',onUp);
  }
  function setArrayOffset(arr, next, opts){
    opts = opts||{}; const fast = !!opts.interactive; const skipDock = !!opts._skipDock; const skipConn = !!opts._skipConnections;
    // Snap to global phase
    const snapAxis=(axis,val,sz)=>{ const phase = Store.getState().gridPhase[axis]||0; const base = (axis==='z') ? (arr.size[axis]/2 - 0.5) : (-(arr.size[axis]/2) + 0.5); return Math.round(val - base - phase) + base + phase; };
    const snapped={ x:snapAxis('x',next.x,arr.size.x), y:snapAxis('y',next.y,arr.size.y), z:snapAxis('z',next.z,arr.size.z) };
    const curOff = arr.offset||{x:0,y:0,z:0};
    // If no actual snap delta, do nothing (prevents wobble without movement)
    if(Math.abs(snapped.x-curOff.x)+Math.abs(snapped.y-curOff.y)+Math.abs(snapped.z-curOff.z) < 1e-6){ return; }
    // Smooth transition toward snapped position
    if(!arr._frame){ arr.offset=snapped; }
    else if(fast){
      // Immediate update for interactive drags
      arr.offset={x:snapped.x,y:snapped.y,z:snapped.z};
      arr._frame.position.set(snapped.x,snapped.y,snapped.z);
    } else {
      const cur=arr.offset||{x:0,y:0,z:0};
      const lerp=(a,b,t)=> a+(b-a)*t;
      const steps=6; let i=0;
      const tick=()=>{
        i++; const t=i/steps; const ease=t*(2-t); // smoothstep-ish
        const x=lerp(cur.x,snapped.x,ease), y=lerp(cur.y,snapped.y,ease), z=lerp(cur.z,snapped.z,ease);
        arr.offset={x,y,z}; if(arr._frame) arr._frame.position.set(x,y,z);
        if(i<steps){ requestAnimationFrame(tick); }
        else {
          // Only wobble once per snap (guard quick repeats)
          const now = performance.now();
          if(!fast && (!arr._lastSnap || now - arr._lastSnap > 120)){
            arr._lastSnap = now;
            applyWiggle(arr, {angle:0.11, lift:0.06, hold:170});
          }
        }
      };
      requestAnimationFrame(tick);
    }

    // Non-destructive: update transforms only
    if(arr._frame) arr._frame.position.set(arr.offset.x,arr.offset.y,arr.offset.z);

    // Apply dock propagation after offset change (use actual delta of snapped vs previous)
    try{
      const S=Store.getState();
      const group = [...(S.dockGroups||new Map()).values()].find(g=>g.members.includes(arr.id));
      if(group && !skipDock){
        const orderIndex = group.members.indexOf(arr.id);
        const ids = (group.mode==='parent') ? group.members.slice(orderIndex+1) : group.members.filter(id=>id!==arr.id);
        const dx=snapped.x-curOff.x, dy=snapped.y-curOff.y, dz=snapped.z-curOff.z;
        ids.forEach(id=>{
          const a=S.arrays[id]; if(!a) return; const off=a.offset||{x:0,y:0,z:0};
          const nx=off.x+dx, ny=off.y+dy, nz=off.z+dz;
          // Reuse same transform pipeline to ensure identical math, but skip further propagation and heavy work
          setArrayOffset(a,{x:nx,y:ny,z:nz},{interactive:true, _skipDock:true, _skipConnections:true});
        });
      }
    }catch{}

    // Update matrices for existing layer meshes by recomputing instance transforms
    if(!arr._frame && !fast){
    Object.entries(Store.getState().arrays).forEach(()=>{}); // no-op ensure state accessible
    for(let z=0; z<arr.size.z; z++){
      ['empty','ghost','filled','formula','edges'].forEach(type=>{
        const rec=layerMeshes.get(`${arr.id}:${z}:${type}`);
        if(!rec) return;
        const {mesh,index2cell}=rec; if(!mesh||!index2cell) return;
        for(let i=0;i<index2cell.length;i++){
          const c=index2cell[i]; if(!c) continue;
            temp.position.copy(localPos(arr,c.x,c.y,c.z));
          temp.updateMatrix();
          mesh.setMatrixAt(i,temp.matrix);
        }
        mesh.instanceMatrix.needsUpdate=true;
      });
      }
    }

    // Update value sprites - parent them to frame and use local coords
    if(!(arr._frame && fast)){
    valueSprites.forEach((sprite,key)=>{
      if(!key.startsWith(`${arr.id}:`)) return;
      const [_,coords]=key.split(':'); const [x,y,z]=coords.split(',').map(Number);
        // Parent sprite to frame if not already
        if(sprite.parent !== arr._frame && arr._frame){
          sprite.parent?.remove(sprite);
          arr._frame.add(sprite);
          // Recompute position in local space
          const pos=localPos(arr,x,y,z); 
          sprite.position.set(pos.x,pos.y,pos.z+0.55);
        }
      });
    }

    // Update connection lines that involve this array
    if(!skipConn){
    connections.forEach((connection, key) => {
      const { ref1, ref2, line } = connection;
      if(ref1.arrId === arr.id || ref2.arrId === arr.id) {
        // Recalculate endpoints
        const arr1 = Store.getState().arrays[ref1.arrId];
        const arr2 = Store.getState().arrays[ref2.arrId];
        if(arr1 && arr2) {
          const start = worldPos(arr1, ref1.x, ref1.y, ref1.z);
          const end = worldPos(arr2, ref2.x, ref2.y, ref2.z);
          
          // Update line geometry
          const points = [start, end];
          line.geometry.dispose();
          line.geometry = new THREE.BufferGeometry().setFromPoints(points);
          
          // Update stored positions
          connection.start = start;
          connection.end = end;
        }
      }
    });
    }
    // Update occlusion/highlight meshes for this array
    highlights.forEach((highlight, key) => {
      if(key.startsWith(`${arr.id}:`)) {
        const [_, coords] = key.split(':');
        const [x, y, z] = coords.split(',').map(Number);
        if(highlight.mesh) {
          highlight.mesh.position.copy(worldPos(arr, x, y, z));
        }
      }
    });

    try{ refreshLightsForArray(arr.id); }catch{}

    // Skip rebuilding axes during movement to prevent stamping
    // buildAxes(arr); // Commented out - only rebuild when array structure changes
    const s=Store.getState().selection; if(s.arrayId===arr.id) updateFocus(s);
    // Enforce visibility after transforms (hidden arrays remain hidden)
    try{ syncVisibility(arr); }catch{}

    // Interactions: run overlap/gobble checks shortly after move settles
    try{ setTimeout(()=>{ InteractionManager?.runChecks?.(arr); }, 120); }catch{}
  }

  // Apply post-snap wiggle/tilt to give momentum feeling
  function applyWiggle(arr, {angle=0.11, lift=0.06, hold=170}={}){
    try{
      for(let zz=0; zz<arr.size.z; zz++){
        const recs=[];
        ['empty','ghost','filled','formula'].forEach(type=>{ const r=layerMeshes.get(`${arr.id}:${zz}:${type}`); if(r) recs.push(r); });
        layerMeshes.forEach((val,key)=>{ if(val?.mesh?.userData?.type==='edges' && val.mesh?.userData?.arrayId===arr.id && val.mesh?.userData?.z===zz) recs.push(val); });
        recs.forEach(rec=>{
          if(!rec||!rec.mesh||!rec.index2cell) return;
          for(let k=0;k<rec.index2cell.length;k++){
            const c=rec.index2cell[k]; if(!c) continue;
            const basePos = localPos(arr,c.x,c.y,c.z);
            temp.position.copy(basePos).add(new THREE.Vector3(0,lift,0));
            temp.rotation.set(angle, 0, -angle);
            temp.scale.set(1,1,1);
            temp.updateMatrix();
            rec.mesh.setMatrixAt(k,temp.matrix);
          }
          rec.mesh.instanceMatrix.needsUpdate=true;
          setTimeout(()=>{
            for(let k=0;k<rec.index2cell.length;k++){
              const c=rec.index2cell[k]; if(!c) continue;
              temp.position.copy(localPos(arr,c.x,c.y,c.z));
              temp.rotation.set(0,0,0); temp.scale.set(1,1,1); temp.updateMatrix();
              rec.mesh.setMatrixAt(k,temp.matrix);
            }
            rec.mesh.instanceMatrix.needsUpdate=true;
          }, hold);
        });
      }
    }catch{}
  }

  // After releasing drag, add a subtle overshoot settle and wiggle
  function settleAfterDrag(arr, dir){
    if(!arr?._frame) return;
    const target = new THREE.Vector3(arr.offset?.x||0, arr.offset?.y||0, arr.offset?.z||0);
    const start = arr._frame.position.clone();
    const dv = new THREE.Vector3(dir.dx||0, dir.dy||0, dir.dz||0);
    const len = dv.length();
    let ov = new THREE.Vector3();
    if(len>1e-6) ov.copy(dv.clone().normalize().multiplyScalar(0.18));
    const overshoot = target.clone().add(ov);
    let phase=0; let t0; const dur1=110, dur2=100;
    const ease=(t)=> t*(2-t);
    const step=(ts)=>{
      if(t0==null) t0=ts;
      const dt=ts-t0;
      if(phase===0){
        const u = Math.min(1, dt/dur1);
        const e = ease(u);
        const p = start.clone().lerp(overshoot, e);
        arr._frame.position.copy(p);
        if(u<1){ requestAnimationFrame(step); }
        else { phase=1; t0=undefined; requestAnimationFrame(step); }
      } else {
        const u = Math.min(1, (dt)/dur2);
        const e = ease(u);
        const p = overshoot.clone().lerp(target, e);
        arr._frame.position.copy(p);
        if(u<1){ requestAnimationFrame(step); }
        else { arr._frame.position.copy(target); applyWiggle(arr); }
      }
    };
    requestAnimationFrame(step);
  }
  function getArrayOffset(arr){ const o=arr?.offset||{x:0,y:0,z:0}; return {x:o.x,y:o.y,z:o.z}; }

  function setGridVisible(v){
    FancyGraphics.base.gridVisible = v;
    grid.visible = FancyGraphics.enabled ? false : v;
  }
  function setAxesVisible(v){ axesHelper.visible=v; Object.values(Store.getState().arrays).forEach(a=>{ a.labels?.forEach(s=>s.visible=v); }); }

  // keyboard for physics locomotion
  const input={f:0,b:0,l:0,r:0,j:0};
  // Toggle arrow mapping via middle mouse button (Mouse 3)
  window.addEventListener('mousedown',(e)=>{
    if(e.button===1){
      e.preventDefault();
      Store.setState(s=>({scene:{...s.scene, arrowMapDepth: !s.scene.arrowMapDepth}}));
      const flag = Store.getState().scene.arrowMapDepth;
      showToast(flag? 'Arrows: Depth' : 'Arrows: Height');
    }
  }, true);
  window.addEventListener('keydown',(e)=>{
    const s=Store.getState();
    // Physics mode takes priority regardless of focused inputs
    if(s.scene.physics){
      const activeTag = document.activeElement?.tagName;
      const direct = document.getElementById('directEdit');
      const typing = (activeTag==='INPUT' || activeTag==='TEXTAREA' || (direct && direct.style.display==='block'));
      if(!typing && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D'].includes(e.key)){
        e.preventDefault();
        if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=1;
        if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=1;
        if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=1;
        if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=1;
        if(e.key===' '||e.key==='Spacebar') input.j=1;
        return;
      }
      if(e.key==='p'||e.key==='P'){ Actions.togglePhysics(); return; }
    }

    // If a text input is focused (formula textbox or universal editor), do nothing; their handlers manage Enter/Esc/typing
    const activeTag = document.activeElement?.tagName;
    const direct = document.getElementById('directEdit');
    if(['INPUT','TEXTAREA'].includes(activeTag)) return;
    if(direct && direct.style.display==='block') return;

    // Universal input: Enter always opens the editor. If no selection, select a default cell first.
    if(e.key==='Enter'){
      e.preventDefault();
      const state=Store.getState();
      const sel=state.selection;
      if(sel?.focus){ UI.openEditor(); return; }
      const fallbackArr = state.arrays[1] || Object.values(state.arrays)[0];
      if(fallbackArr){
        Actions.setSelection(fallbackArr.id,{x:0,y:0,z:0}, null, '2d');
        setTimeout(()=> UI.openEditor(), 0);
      }
      return;
    }
    // Undo/Redo shortcuts
    if(e.ctrlKey || e.metaKey){
      if(e.key==='z'){
        if(e.shiftKey){ e.preventDefault(); Actions.redoData(); return; }
        else { e.preventDefault(); Actions.undoData(); return; }
      }
      if(e.key==='y'){ e.preventDefault(); Actions.redoData(); return; }
    }
    if(e.altKey && e.key==='z'){
      if(e.shiftKey){ e.preventDefault(); Actions.redoUI(); return; }
      else { e.preventDefault(); Actions.undoUI(); return; }
    }
    
    // Backspace: clear cell and enter input mode
    if(e.key==='Backspace' && s.selection?.focus){
      e.preventDefault(); 
      const sel = s.selection;
      const anchor = {arrId: sel.arrayId, ...sel.focus};
      Actions.setCell(sel.arrayId, sel.focus, '', null, true);
      // Do not open the inline editor on backspace; just clear
      return;
    }
    
    // Realtime typing: printable char when a cell is focused starts editor with that char
    if(s.selection?.focus && e.key.length===1 && !e.ctrlKey && !e.metaKey && !e.altKey){
      e.preventDefault(); UI.startDirectTyping(e.key); return;
    }
    if(e.key==='p'||e.key==='P'){ Actions.togglePhysics(); return; }
    if(!s.scene.physics){
      // Ensure we have a selection; default to Array 1 A1α if none
      let sel=s.selection;
      if(!sel.focus){
        const fallbackArr = s.arrays[1] || Object.values(s.arrays)[0];
        if(fallbackArr){ Actions.setSelection(fallbackArr.id, {x:0,y:0,z:0}, null, '2d'); sel = Store.getState().selection; }
      }
      if(!sel.focus) return; const arr=s.arrays[sel.arrayId]; if(!arr) return;
      let {x,y,z}=sel.focus;
      if(e.shiftKey){
        // Shift+Arrows: move selection
        if(e.key==='ArrowUp') Actions.moveSelection(0,1,0);
        if(e.key==='ArrowDown') Actions.moveSelection(0,-1,0);
        if(e.key==='ArrowLeft') Actions.moveSelection(-1,0,0);
        if(e.key==='ArrowRight') Actions.moveSelection(1,0,0);
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){ e.preventDefault(); UI.scrollSheetToSelection(); }
      } else {
        // View-dependent navigation with optional Depth mode (Mouse 3 toggles)
        const cam = Scene.getCamera?.();
        const frame = arr?._frame;
        let major='Z', sign=1, signX=1, signY=1, signZ=1;
        try{
          if(frame && cam){
            const arrPos = new THREE.Vector3().setFromMatrixPosition(frame.matrixWorld);
            const toCamW = cam.position.clone().sub(arrPos).normalize();
            const inv = new THREE.Matrix4().copy(frame.matrixWorld).invert();
            const toCamL = toCamW.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(inv)).normalize();
            const ax=Math.abs(toCamL.x), ay=Math.abs(toCamL.y), az=Math.abs(toCamL.z);
            if(ay>ax && ay>az){ major='Y'; sign=Math.sign(toCamL.y)||1; }
            else if(ax>ay && ax>az){ major='X'; sign=Math.sign(toCamL.x)||1; }
            else { major='Z'; sign=Math.sign(toCamL.z)||1; }
            signX = Math.sign(toCamL.x)||1; signY = Math.sign(toCamL.y)||1; signZ = Math.sign(toCamL.z)||1;
          }
        }catch{}

        const depthMode = !!Store.getState().scene.arrowMapDepth;
        let dx=0, dy=0, dz=0;
        if(depthMode){
          // Depth mode: Up/Down control depth (Z) relative to camera; Left/Right control X relative to camera
          if(e.key==='ArrowLeft')  dx = (signX>0 ? -1 : +1);
          if(e.key==='ArrowRight') dx = (signX>0 ? +1 : -1);
          if(e.key==='ArrowUp')    dz = (signZ>0 ? -1 : +1);
          if(e.key==='ArrowDown')  dz = (signZ>0 ? +1 : -1);
      } else {
          // Standard view-dependent mapping (height on Up/Down except top/bottom views)
          if(major==='X'){
            if(e.key==='ArrowLeft')  dz = (sign>0 ? -1 : +1);
            if(e.key==='ArrowRight') dz = (sign>0 ? +1 : -1);
            if(e.key==='ArrowUp')    dy = -1;
            if(e.key==='ArrowDown')  dy = +1;
          } else if(major==='Z'){
            if(e.key==='ArrowLeft')  dx = (sign>0 ? -1 : +1);
            if(e.key==='ArrowRight') dx = (sign>0 ? +1 : -1);
            if(e.key==='ArrowUp')    dy = -1;
            if(e.key==='ArrowDown')  dy = +1;
          } else { // major==='Y'
            if(e.key==='ArrowLeft')  dx = -1;
            if(e.key==='ArrowRight') dx = +1;
            if(e.key==='ArrowUp')    dz = (sign>0 ? -1 : +1);
            if(e.key==='ArrowDown')  dz = (sign>0 ? +1 : -1);
          }
        }

        if(dx||dy||dz){
          e.preventDefault();
          x = Math.max(0, Math.min(arr.size.x-1, x+dx));
          y = Math.max(0, Math.min(arr.size.y-1, y+dy));
          z = Math.max(0, Math.min(arr.size.z-1, z+dz));
          Actions.setSelection(sel.arrayId,{x,y,z}); UI.scrollSheetToSelection();
        }
      }
      // Immediate typing: Enter resumes, other printable keys clear and start typing
      if(e.key==='Enter') { UI.openEditor(); }
      else if(e.key==='=') { UI.startDirectTyping('='); e.preventDefault(); }
      else if(e.key.length===1 && !e.ctrlKey && !e.altKey && !e.metaKey) { UI.startDirectTyping(e.key); e.preventDefault(); }
      else if(e.key==='f'||e.key==='F') UI.toggleFxPanel();
      else if(e.key==='[') document.getElementById('zPrev').click();
      else if(e.key===']') document.getElementById('zNext').click();
      else if(e.key===' '||e.key==='Spacebar') Scene.handleJump();
    }
  }, true);
  window.addEventListener('keyup',(e)=>{
    const s=Store.getState();
    if(s.scene.physics){
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Spacebar','w','a','s','d','W','A','S','D'].includes(e.key)){
        e.preventDefault();
        if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=0;
        if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=0;
        if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=0;
        if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=0;
        if(e.key===' '||e.key==='Spacebar') input.j=0; 
        return;
      }
    }
    if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.f=0; if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.b=0; if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.l=0; if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.r=0; if(e.key===' '||e.key==='Spacebar') input.j=0; 
  },true);
  const highlights=new Map(); // anchor -> {mode, mesh}
  function setHighlightMode(arr,anchor,config){
    const k=aKey(anchor); 
    const {mode='dynamic',scope='cell',style='wireframe'} = typeof config==='string'?{mode:config}:config;
    highlights.set(k,{mode,scope,style,anchor});
    
    // create highlight mesh based on scope and style
    let geo, mat;
    if(scope==='face'){
      geo = new THREE.PlaneGeometry(1.1,1.1); 
      mat = new THREE.MeshBasicMaterial({color:0x22c55e,transparent:true,opacity:0.6,side:THREE.DoubleSide});
    } else {
      geo = new THREE.BoxGeometry(1.1,1.1,1.1);
      mat = new THREE.MeshBasicMaterial({
        color:0x22c55e,transparent:true,opacity:0.3,
        wireframe:style==='wireframe'
      });
    }
    const mesh=new THREE.Mesh(geo,mat); 
    mesh.position.copy(worldPos(arr,anchor.x,anchor.y,anchor.z)); 
    scene.add(mesh);
    highlights.get(k).mesh=mesh;
  }

  function setCameraLock(arr,config){
    arr.cameraLock = config;
    // Implementation would constrain orbit controls based on axis/angle
  }
  function setViewMode(arr,config){
    arr.viewMode = config;
    // Implementation would switch between perspective/orthographic cameras
  }

  // Lightweight AvatarFactory for modular characters
  const AvatarFactory = {
    createCelli(THREE){
      const MAT_BODY  = new THREE.MeshLambertMaterial({ color: 0xf59e0b });
      const MAT_DARK  = new THREE.MeshLambertMaterial({ color: 0x374151 });
      const MAT_BLUSH = new THREE.MeshLambertMaterial({ color: 0xec4899 });
      const MAT_WING  = new THREE.MeshLambertMaterial({ color: 0xf59e0b, side: THREE.DoubleSide });
      const MAT_OUTLINE = new THREE.MeshBasicMaterial({ color: 0x111827 });
      MAT_OUTLINE.depthTest = false;
      MAT_OUTLINE.depthWrite = false;
      MAT_OUTLINE.toneMapped = false;
      const root = new THREE.Group();
      root.scale.setScalar(0.40);
      // Body
      const BW=.8, BH=.8, BD=.3;
      const bodyGroup = new THREE.Group();
      const body = new THREE.Mesh(new RoundedBoxGeometry(BW, BH, BD, 6, .12), MAT_BODY);
      bodyGroup.add(body); bodyGroup.position.y = BH/2; root.add(bodyGroup);
      // Face cluster
      const faceGroup = new THREE.Group();
      const faceZ = BD/2 + 0.01;
      const eyeGeo = new THREE.SphereGeometry(0.05, 16, 12);
      const eyeL = new THREE.Mesh(eyeGeo, MAT_DARK); eyeL.scale.set(1,2,.25); eyeL.position.set(-.12,.13,faceZ);
      const eyeR = new THREE.Mesh(eyeGeo, MAT_DARK); eyeR.scale.set(1,2,.25); eyeR.position.set(.12,.13,faceZ);
      const blushGeo = new THREE.SphereGeometry(0.05, 16, 12);
      const cheekL = new THREE.Mesh(blushGeo, MAT_BLUSH); cheekL.scale.set(1.2,1,.2); cheekL.position.set(-.25,-.08,faceZ);
      const cheekR = new THREE.Mesh(blushGeo, MAT_BLUSH); cheekR.scale.set(1.2,1,.2); cheekR.position.set(.25,-.08,faceZ);
      const smileShape = new THREE.Shape();
      smileShape.moveTo(-0.12, -0.06);
      smileShape.quadraticCurveTo(0, -0.25, 0.12, -0.06);
      smileShape.quadraticCurveTo(0, -0.20, -0.12, -0.06);
      const smile = new THREE.Mesh(new THREE.ShapeGeometry(smileShape), MAT_DARK); smile.position.z = faceZ;
      faceGroup.add(eyeL, eyeR, cheekL, cheekR, smile);
      bodyGroup.add(faceGroup);
      // Bow
      function triWing(width=0.22, height=0.16, depth=0.02){
        const shape = new THREE.Shape();
        shape.moveTo(width/2, 0);
        shape.lineTo(-width/2, height/2);
        shape.lineTo(-width/2, -height/2);
        shape.lineTo(width/2, 0);
        const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled:false });
        geo.center(); geo.computeVertexNormals();
        return geo;
      }
      const bowGroup = new THREE.Group();
      const wingL = new THREE.Mesh(triWing(), MAT_WING);
      const wingR = new THREE.Mesh(triWing(), MAT_WING);
      wingL.rotation.y = 0; wingR.rotation.y = Math.PI;
      wingL.position.set(-0.18, 0, 0); wingR.position.set(0.18, 0, 0);
      const knot = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.06), MAT_BODY);
      bowGroup.add(wingL, wingR, knot);
      bowGroup.position.set(0, BH + 0.15, 0);
      root.add(bowGroup);
      // Arms
      const armRadius = .055;
      const armCurve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(-0.016, 0, 0), new THREE.Vector3(0.046, -0.016, 0.012), new THREE.Vector3(0.028, -0.10, 0)
      );
      const armGeo = new THREE.TubeGeometry(armCurve, 28, armRadius, 12, false);
      const handGeo = new THREE.SphereGeometry(armRadius, 16, 12);
      function makeArm(sign=1){
        const armRoot = new THREE.Group();
        const upper = new THREE.Mesh(armGeo, MAT_BODY);
        const handGroup = new THREE.Group();
        const hand = new THREE.Mesh(handGeo, MAT_BODY);
        hand.position.copy(armCurve.getPoint(1)); handGroup.add(hand);
        armRoot.add(upper, handGroup);
        armRoot.position.set(sign*(BW/2), BH*.90, 0);
        armRoot.scale.x *= sign;
        return { armRoot, handGroup };
      }
      const L = makeArm(-1), R = makeArm(+1);
      R.armRoot.position.set(Math.abs(L.armRoot.position.x), L.armRoot.position.y, L.armRoot.position.z);
      R.armRoot.rotation.set(L.armRoot.rotation.x, -L.armRoot.rotation.y, -L.armRoot.rotation.z);
      R.armRoot.scale.y = L.armRoot.scale.y; R.armRoot.scale.z = -L.armRoot.scale.z;
      // Legs
      const legRadius = .06;
      const legCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0,0,0), new THREE.Vector3(0,-.10,.022), new THREE.Vector3(0,-.17,.036)
      ]);
      const legGeo = new THREE.TubeGeometry(legCurve, 12, legRadius, 12, false);
      const footGeo = new THREE.SphereGeometry(legRadius, 16, 12);
      function makeLeg(x){
        const legRoot = new THREE.Group();
        const leg = new THREE.Mesh(legGeo, MAT_BODY);
        const footGroup = new THREE.Group();
        const foot = new THREE.Mesh(footGeo, MAT_BODY);
        foot.position.copy(legCurve.getPoint(1)); foot.scale.set(1.5,.8,1.2); footGroup.add(foot);
        legRoot.add(leg, footGroup); legRoot.position.set(x, 0, 0);
        return { legRoot, footGroup };
      }
      const legL = makeLeg(-.20), legR = makeLeg(.20);
      legR.legRoot.position.set(Math.abs(legL.legRoot.position.x), legL.legRoot.position.y, legL.legRoot.position.z);
      root.add(bodyGroup, L.armRoot, R.armRoot, legL.legRoot, legR.legRoot);
      const baseMeshes = [];
      root.traverse(n=>{ if(n.isMesh) baseMeshes.push(n); });
      baseMeshes.forEach(mesh=>{
        const outline = new THREE.Mesh(mesh.geometry, MAT_OUTLINE);
        outline.name = `${mesh.name||'part'}_outline`;
        outline.userData.isAvatarOutline = true;
        outline.scale.set(1.08,1.08,1.08);
        outline.position.set(0,0,0);
        outline.castShadow = false;
        outline.receiveShadow = false;
        mesh.add(outline);
      });
      // Ensure overlay rendering above voxels
      root.traverse(n=>{
        if(!n.isMesh) return;
        const isOutline = !!n.userData?.isAvatarOutline;
        n.material.depthTest = false;
        n.material.depthWrite = false;
        if(n.material.toneMapped !== false) n.material.toneMapped = false;
        n.renderOrder = isOutline ? 10499 : 10500;
      });
      return root;
    }
  };

  // Celli and Arraya avatars
  let celli, arraya;
  function initAvatars(){
    celli = AvatarFactory.createCelli(THREE);
    scene.add(celli); celli.visible=false;
    
    arraya=new THREE.Group();
    const segG=new RoundedBoxGeometry(.5,.5,.5,2,.12); const segM=new THREE.MeshLambertMaterial({color:0x22c55e});
    for(let i=0;i<3;i++){ const m=new THREE.Mesh(segG,segM); m.position.y=i*.5; arraya.add(m); }
    scene.add(arraya); arraya.visible=false;
  }

  function updateAvatars(sel){
    if(!sel.arrayId||!sel.focus){ celli.visible=false; arraya.visible=false; return; }
    const arr=Store.getState().arrays[sel.arrayId];
    const pos=worldPos(arr,sel.focus.x,sel.focus.y,sel.focus.z);
    celli.position.copy(pos).add(new THREE.Vector3(0,.7,0)); celli.visible=true; celli.rotation.y+=0.02;
    
    const cell=UI.getCell(sel.arrayId,sel.focus);
    const hasArray=(cell.formula||'').toUpperCase().includes('ARRAY');
    arraya.visible=hasArray; if(hasArray) arraya.position.copy(pos).add(new THREE.Vector3(.8,0,0));
  }

  function addTimedPreview(arr,anchor,ticks){
    const pos=worldPos(arr,anchor.x,anchor.y,anchor.z);
    const preview=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), new THREE.MeshBasicMaterial({color:0x22c55e,transparent:true,opacity:0.4}));
    preview.position.copy(pos); scene.add(preview);
    let t=0; const loop=()=>{
      t=(t+1)%ticks; const s=Math.sin((t/ticks)*Math.PI*2)*0.3;
      preview.position.y=pos.y+s; preview.rotation.y=t*0.05;
      if(t===0) scene.remove(preview); else requestAnimationFrame(loop);
    }; loop();
  }
  // Jump physics
  let jumpVelocity=0;
  function handleJump(){
    // --- START: ZIPLINE DETACHMENT ---
    if(ziplineState.active){
      ziplineState.active = false;
      jumpVelocity = 4; // Give a small hop off the line
      return;
    }
    // --- END: ZIPLINE DETACHMENT ---

    if(rapierWorld && playerBody){
      try {
        // Simple jump without character controller
        const p = {x: cachedPlayerPos.x, y: cachedPlayerPos.y, z: cachedPlayerPos.z};
        const grounded=p.y<=1.05;
      if(grounded && jumpVelocity<=0) jumpVelocity=8;
        if(jumpVelocity>0){ 
          const newY = p.y + jumpVelocity*0.045;
          playerBody.setNextKinematicTranslation(p.x, newY, p.z); 
          cachedPlayerPos.set(p.x, newY, p.z);
          jumpVelocity-=0.55; 
        }
      } catch(e) {
        console.warn('Jump failed:', e);
      }
    }
  }

  function updateValueSprite(arr, x, y, z, cell){
    const key=`${arr.id}:${x},${y},${z}`;
    
    // Remove old sprite if exists
    const oldSprite=valueSprites.get(key);
    if(oldSprite){ try{ unmarkBillboard(oldSprite); }catch{} oldSprite.parent?.remove(oldSprite); oldSprite.material.map?.dispose(); oldSprite.material.dispose(); valueSprites.delete(key); }
    
    // Create new sprite if cell has content (prefer displayText if available)
    const displayText = cell.meta?.displayText;
    const actualText = displayText !== undefined ? displayText : cell.value;
    if(actualText!=='' && actualText!==null && actualText!==undefined){
      const text=String(actualText).slice(0,12); // allow longer text
      const isFormula=!!cell.formula;
      const sprite=makeValueSprite(text, isFormula);
      const pos=localPos(arr,x,y,z);
      // Place on the same face used by occlusion/arrow mapping
      const face = getPreferredFacing(arr);
      const off = SPRITE_FACE_OFFSET * face.sign;
      const dx = (face.axis===0) ? off : 0;
      const dy = (face.axis===1) ? off : 0;
      const dz = (face.axis===2) ? off : 0;
      sprite.position.copy(pos).add(new THREE.Vector3(dx,dy,dz));
      // Parent to frame for unified movement
      if(arr._frame) arr._frame.add(sprite); else scene.add(sprite);
      try{ sprite.material.depthTest = true; sprite.material.depthWrite = false; }catch{}
      valueSprites.set(key, sprite);
    } else { valueSprites.delete(key); }
  }

  // Deletion explosion effect
  const deleteEffects = [];
  const pendingDatafallDeletes = new Map(); // arrId -> {count:number, finished:boolean}
  const normalizeArrayId = (id)=>{
    if(id === undefined) return '__undefined__';
    if(id === null) return '__null__';
    return String(id);
  };
  const nowMs = ()=> (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  let deleteInteractionLock = false;
  let deletionControlState = null;
  const DATAFALL_COLORS = {
    syntax: '#111827',
    function: '#111827',
    punctuation: '#111827',
    string: '#16a34a',
    range: '#f59e0b',
    address: '#f59e0b',
    number: '#1d4ed8',
    binary: '#2563eb'
  };
  function cssColor(color){
    if(typeof color === 'number'){ return `#${color.toString(16).padStart(6,'0')}`; }
    return color || '#ffffff';
  }
  function tokenizeFormulaForDatafall(raw){
    const out = [];
    if(!raw){ return out; }
    const formula = String(raw);
    const regex = /(=[A-Z_0-9]+)|(@\[[^\]]+\])|("[^"\\]*(?:\\.[^"\\]*)*")|(\()|(\))|(,)|([A-Z]+\d+)|(-?\d+(?:\.\d+)?)/gi;
    let lastIndex = 0;
    let match;
    while((match = regex.exec(formula))){
      if(match.index > lastIndex){
        const text = formula.slice(lastIndex, match.index);
        if(text){ out.push({ text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax }); }
      }
      const text = match[0];
      let tokenKind = 'syntax';
      if(match[1]) tokenKind = 'function';
      else if(match[2]) tokenKind = 'range';
      else if(match[3]) tokenKind = 'string';
      else if(match[4] || match[5] || match[6]) tokenKind = 'punctuation';
      else if(match[7]) tokenKind = 'address';
      else if(match[8]) tokenKind = 'number';
      out.push({ text, tokenKind, color: DATAFALL_COLORS[tokenKind] || DATAFALL_COLORS.syntax });
      lastIndex = regex.lastIndex;
    }
    if(lastIndex < formula.length){
      const tail = formula.slice(lastIndex);
      if(tail){ out.push({ text: tail, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax }); }
    }
    return out;
  }
  function classifyRawValue(raw){
    const text = String(raw ?? '');
    const trimmed = text.trim();
    if(trimmed === '') return { text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax };
    const numeric = !Number.isNaN(Number(trimmed));
    if(numeric){ return { text: trimmed, tokenKind: 'number', color: DATAFALL_COLORS.number }; }
    if(/^".*"$/.test(trimmed)) return { text: trimmed, tokenKind: 'string', color: DATAFALL_COLORS.string };
    return { text, tokenKind: 'syntax', color: DATAFALL_COLORS.syntax };
  }
  function colorForCellVisual(arrId, cell){
    try{
      if(!cell) return baseHexForTypeKey('empty');
      if(cell.meta && cell.meta.color) return cell.meta.color;
      const key = `${arrId}:${cell.x},${cell.y},${cell.z}`;
      const emitted = !!(Store.getState().sourceByCell && Store.getState().sourceByCell.get && Store.getState().sourceByCell.get(key));
      const hasValue = (cell.value!=='' && cell.value!==null && cell.value!==undefined);
      if(cell.formula) return baseHexForTypeKey('formula');
      if(emitted) return baseHexForTypeKey('emitted');
      return hasValue ? baseHexForTypeKey('value') : baseHexForTypeKey('empty');
    }catch{ return baseHexForTypeKey('empty'); }
  }
  function lockDeletionInteractions(){
    deleteInteractionLock = true;
    try{
      if(controls){
        deletionControlState = {
          rotate: controls.enableRotate,
          pan: controls.enablePan,
          zoom: controls.enableZoom
        };
        controls.enableRotate = false;
        controls.enablePan = false;
        controls.enableZoom = false;
      }
    }catch{}
  }
  function releaseDeletionInteractions(){
    try{
      if(controls && deletionControlState){
        controls.enableRotate = deletionControlState.rotate;
        controls.enablePan = deletionControlState.pan;
        controls.enableZoom = deletionControlState.zoom;
      }
    }catch{}
    deletionControlState = null;
    deleteInteractionLock = false;
  }
  function startAxisFall(arr, onDone){
    try{
      const labels = (arr?.labels||[]).filter(Boolean);
      if(!labels.length){ if(typeof onDone==='function') onDone(); return; }
      const actors = [];
      labels.forEach(label=>{
        try{ if(label.userData?.billboard) unmarkBillboard(label); }catch{}
        try{
          const worldPos = label.getWorldPosition(new THREE.Vector3());
          const worldQuat = label.getWorldQuaternion(new THREE.Quaternion());
          const worldScale = label.scale ? label.scale.clone() : new THREE.Vector3(1,1,1);
          label.parent?.remove(label);
          label.position.copy(worldPos);
          label.quaternion.copy(worldQuat);
          if(worldScale) label.scale.copy(worldScale);
          scene.add(label);
          actors.push({
            mesh: label,
            vel: new THREE.Vector3((Math.random()-0.5)*0.02, Math.random()*0.04 + 0.02, (Math.random()-0.5)*0.02),
            rot: new THREE.Vector3((Math.random()-0.5)*0.06, (Math.random()-0.5)*0.06, (Math.random()-0.5)*0.06),
            age: 0,
            life: 1100 + Math.random()*500
          });
        }catch{}
        });
        arr.labels = [];
        try{ if(arr._frame?.userData) arr._frame.userData.grab = null; }catch{}
        if(!actors.length){ if(typeof onDone==='function') onDone(); return; }
      deleteEffects.push({
        phase:'axisFall',
        labels: actors,
        onDone:()=>{
          actors.forEach(actor=>{
            try{ if(actor.mesh.userData?.billboard) unmarkBillboard(actor.mesh); }catch{}
            try{ actor.mesh.parent?.remove(actor.mesh); }catch{}
            try{ actor.mesh.material?.map?.dispose?.(); actor.mesh.material?.dispose?.(); }catch{}
          });
          if(typeof onDone==='function') onDone();
        }
      });
    }catch{ if(typeof onDone==='function') onDone(); }
  }
  function maybeFinalizeDeletion(arrId){
    const key = normalizeArrayId(arrId);
    try{
      const rec = pendingDatafallDeletes.get(key);
      if(rec && rec.finished && ((rec.count|0) <= 0)){
        if(rec.finalizing) return;
        rec.finalizing = true;
        pendingDatafallDeletes.set(key, rec);
        const finalizeNow = ()=>{
          pendingDatafallDeletes.delete(key);
          try{ Actions.deleteArray(arrId); }catch{}
          releaseDeletionInteractions();
        };
        const store = Store.getState();
        const arr = store.arrays?.[arrId] ?? store.arrays?.[key];
        if(arr){
          startAxisFall(arr, finalizeNow);
        } else {
          finalizeNow();
        }
      }
    }catch{ releaseDeletionInteractions(); }
  }

  function makeCharSprite(ch, color = '#ffffff'){
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fs = 18, pad = 4;
    ctx.font = `600 ${fs}px 'Roboto Mono', monospace`;
    const w = Math.max(12, Math.ceil(ctx.measureText(ch).width) + pad*2);
    const h = fs + pad*2;
    canvas.width = w; canvas.height = h;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = cssColor(color);
    ctx.font = `600 ${fs}px 'Roboto Mono', monospace`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(ch, w/2, h/2);
    const tex = new THREE.CanvasTexture(canvas);
    tex.colorSpace = THREE.SRGBColorSpace;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false, opacity: 1 });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(0.25, 0.18, 1);
    spr.renderOrder = 2100;
    return spr;
  }
  function spawnCellDatafallAt(position, cell, parentArrId){
    const arrKey = normalizeArrayId(parentArrId);
    try{
      try{
        const rec = pendingDatafallDeletes.get(arrKey) || {count:0, finished:false, finalizing:false};
        rec.count = (rec.count||0) + 1;
        rec.arrId = rec.arrId ?? parentArrId;
        rec.startedAt = rec.startedAt ?? nowMs();
        rec.lastActive = nowMs();
        pendingDatafallDeletes.set(arrKey, rec);
      }catch{}
      const group = new THREE.Group();
      group.userData.kind='microCollapse';
      scene.add(group);
      const colorHex = cssColor(colorForCellVisual(parentArrId, cell));
      const coreColor = new THREE.Color(colorHex);
      const shellColor = coreColor.clone().lerp(new THREE.Color(0xffffff), 0.45);
      const coreMat = new THREE.MeshBasicMaterial({ color: coreColor, transparent:true, opacity:0.95, depthTest:true, depthWrite:true });
      const shellMat = new THREE.MeshBasicMaterial({ color: shellColor, transparent:true, opacity:0.38, depthTest:true, depthWrite:false });
      const core = new THREE.Mesh(GEO_VOXEL, coreMat);
      const shell = new THREE.Mesh(GEO_SHELL, shellMat);
      core.renderOrder = 2100;
      shell.renderOrder = 2101;
      group.add(core);
      group.add(shell);
      group.position.copy(position);
      const dur=420; let t0;
      const step=(ts)=>{
        if(t0==null) t0=ts;
        const u=Math.min(1,(ts-t0)/dur);
        const e=1-Math.pow(1-u,4);
        const scale = 1 - (0.55*e);
        core.scale.setScalar(Math.max(0.0001, scale));
        shell.scale.setScalar(Math.max(0.0001, scale * 1.04));
        core.material.opacity = 0.95*(1-e)+0.08;
        shell.material.opacity = 0.38*(1-e)+0.05;
        if(u<1){
          requestAnimationFrame(step);
        } else {
          try{
            scene.remove(group);
            core.material?.dispose?.();
            shell.material?.dispose?.();
          }catch{}
          const hasContent = !!(cell && ((cell.formula && String(cell.formula).length) || (cell.value!=='' && cell.value!==null && cell.value!==undefined)));
          if(!hasContent){
            try{
              const rec = pendingDatafallDeletes.get(arrKey);
              if(rec){
                rec.count = Math.max(0, (rec.count||0) - 1);
                rec.arrId = rec.arrId ?? parentArrId;
                rec.lastActive = nowMs();
                pendingDatafallDeletes.set(arrKey, rec);
                maybeFinalizeDeletion(parentArrId);
              }
            }catch{}
            return;
          }
          const effGroup=new THREE.Group();
          scene.add(effGroup);
          const hasFormula = !!(cell && typeof cell.formula === 'string' && cell.formula.trim().length);
          const displayText = hasFormula ? String(cell.formula) : String(cell?.value ?? '');
          const baseToken = hasFormula ? { tokenKind:'formula', color: DATAFALL_COLORS.syntax } : classifyRawValue(displayText);
          const baseColor = baseToken.color || DATAFALL_COLORS.syntax;
          const sp = makeCharSprite(displayText, baseColor);
          sp.position.copy(position);
          effGroup.add(sp);
          const vel = new THREE.Vector3(0,0.022,0);
          deleteEffects.push({
            phase:'datafall',
            group:effGroup,
            particles:[{
              kind:'value',
              cell,
              text:displayText,
              sprite:sp,
              vel,
              age:0,
              life:420,
              rot:0,
              color: baseColor,
              tokenKind: baseToken.tokenKind
            }],
            onDone:()=>{
              try{
                const rec = pendingDatafallDeletes.get(arrKey);
                if(rec){
                  rec.count = Math.max(0, (rec.count||0) - 1);
                  rec.arrId = rec.arrId ?? parentArrId;
                  rec.lastActive = nowMs();
                  pendingDatafallDeletes.set(arrKey, rec);
                  maybeFinalizeDeletion(parentArrId);
                }
              }catch{}
            }
          });
        }
      };
      requestAnimationFrame(step);
    }catch{}
  }
  function startDatafallDelete(arr){
    try{
      try{
        if(!arr._frame) renderArray(arr);
        Object.values(arr.chunks||{}).forEach(ch=>{
          ch.ensureMesh?.();
          ch.setLOD?.(1);
          rehydrateChunkInstances(arr, ch);
        });
      }catch{}
      if(!deleteInteractionLock) lockDeletionInteractions();
      const items=[];
      try{
        Object.values(arr.chunks||{}).forEach(ch=>{
          (ch.cells||[]).forEach(c=>{ items.push({x:c.x,y:c.y,z:c.z}); });
        });
        for(let i=items.length-1; i>0; i--){
          const j = Math.floor(Math.random()*(i+1));
          const tmp = items[i];
          items[i] = items[j];
          items[j] = tmp;
        }
      }catch{}
      let idx=0;
      const waveSize=8;
      const waveDelay=160;
      const arrKey = normalizeArrayId(arr.id);
      pendingDatafallDeletes.set(arrKey, {count:0, finished:false, finalizing:false, arrId: arr.id, startedAt: nowMs(), lastActive: nowMs()});
      if(items.length===0){
        try{
          const rec=pendingDatafallDeletes.get(arrKey);
          if(rec){ rec.finished=true; rec.finishedAt = nowMs(); rec.lastActive = nowMs(); pendingDatafallDeletes.set(arrKey, rec); }
        }catch{}
        maybeFinalizeDeletion(arr.id);
        return;
      }
      const spawnWave=()=>{
        const S=Store.getState();
        if(!S.arrays[arr.id]) return;
        for(let k=0;k<waveSize && idx<items.length;k++,idx++){
          const c=items[idx];
          let cell=null;
          try{
            cell = Formula.getCell({arrId:arr.id,x:c.x,y:c.y,z:c.z});
          }catch{}
          const pos = cellWorldPos(arr, c.x, c.y, c.z);
          spawnCellDatafallAt(pos, cell? {...cell, arrId: arr.id, x:c.x, y:c.y, z:c.z } : null, arr.id);
          try{
            const CH = chunkOf(c.x,c.y,c.z);
            const key = keyChunk(CH.x,CH.y,CH.z);
            const ch = (arr.chunks||{})[key];
            if(ch){
              const mesh = ch.meshLOD1 || ch.meshLOD2 || null;
              const list = ch.index2cell || [];
              if(mesh && list && list.length){
                const idx3 = list.findIndex(q=> q && q.x===c.x && q.y===c.y && q.z===c.z);
                if(idx3>=0){
                  const mat = new THREE.Matrix4();
                  mat.makeScale(0,0,0);
                  mesh.setMatrixAt(idx3, mat);
                  mesh.instanceMatrix.needsUpdate = true;
                  if(ch.meshShell){ try{ ch.meshShell.setMatrixAt(idx3, mat); ch.meshShell.instanceMatrix.needsUpdate = true; }catch{} }
                  if(ch.meshGhost){ try{ ch.meshGhost.setMatrixAt(idx3, mat); ch.meshGhost.instanceMatrix.needsUpdate = true; }catch{} }
                }
              } else {
                const rec = layerMeshes.get(`${arr.id}:${c.z}:filled`) || layerMeshes.get(`${arr.id}:${c.z}:formula`) || layerMeshes.get(`${arr.id}:${c.z}:empty`);
                if(rec && rec.mesh && rec.index2cell){
                  const idxL = rec.index2cell.findIndex(q=> q && q.x===c.x && q.y===c.y && q.z===c.z);
                  if(idxL>=0){
                    const mat = new THREE.Matrix4();
                    mat.makeScale(0,0,0);
                    rec.mesh.setMatrixAt(idxL, mat);
                    rec.mesh.instanceMatrix.needsUpdate=true;
                  }
                }
                const recShell = layerMeshes.get(`${arr.id}:${c.z}:edges`);
                if(recShell && recShell.mesh && recShell.index2cell){
                  const idxS = recShell.index2cell.findIndex(q=> q && q.x===c.x && q.y===c.y && q.z===c.z);
                  if(idxS>=0){
                    const mat = new THREE.Matrix4();
                    mat.makeScale(0,0,0);
                    recShell.mesh.setMatrixAt(idxS, mat);
                    recShell.mesh.instanceMatrix.needsUpdate = true;
                  }
                }
              }
            }
          }catch{}
        }
        if(idx<items.length){
          setTimeout(spawnWave, waveDelay);
        } else {
          setTimeout(()=>{
            try{
              const rec=pendingDatafallDeletes.get(arrKey)||{count:0};
              rec.finished=true;
              rec.finishedAt = nowMs();
              rec.arrId = rec.arrId ?? arr.id;
              rec.lastActive = nowMs();
              pendingDatafallDeletes.set(arrKey, rec);
              maybeFinalizeDeletion(arr.id);
            }catch{}
          }, 200);
        }
      };
      spawnWave();
    }catch(e){
      console.warn('startDatafallDelete failed', e);
      releaseDeletionInteractions();
    }
  }
  function spawnDeleteExplosion(arr){
    try{
      const group = new THREE.Group();
      group.userData.kind = 'deleteEffect';
      scene.add(group);

      const clones = [];
      const particles = [];

      // Duplicate the visible value sprites for this array, then animate them
      valueSprites.forEach((sprite, key)=>{
        if(!String(key).startsWith(`${arr.id}:`)) return;
        const [_, coords] = key.split(':');
        const [x, y, z] = coords.split(',').map(Number);
        const cell = Formula.getCell({arrId: arr.id, x, y, z});
        const displayText = cell?.meta?.displayText;
        const actualText = displayText !== undefined ? displayText : cell?.value;
        if(actualText === '' || actualText === null || actualText === undefined) return;

        const label = String(actualText).slice(0, 12);
        const clone = makeValueSprite(label, !!cell?.formula);
        const wp = cellWorldPos(arr, x, y, z);
        clone.position.copy(wp).add(new THREE.Vector3(0, 0, 0.55));
        group.add(clone);
        clones.push({ sprite: clone, cell, origin: clone.position.clone(), t: 0, text: label });
      });

      deleteEffects.push({ group, clones, particles, t: 0, phase: 'hover', stage: 'chars', stageT: 0 });
    }catch(e){ console.warn('spawnDeleteExplosion failed', e); }
  }

  function updateDeleteEffects(dtMs){
    const grav = 0.004; // gentler gravity to emphasize slow drift cascade
    for(let i = deleteEffects.length - 1; i >= 0; i--){
      const eff = deleteEffects[i];
      eff.t += dtMs;

      // Datafall phase: value -> formula/text chunks -> char codes -> binary bits
      if(eff.phase === 'datafall'){
        const next = [];
        for(let k=0; k<eff.particles.length; k++){
          const pr = eff.particles[k];
          pr.age += dtMs;
          pr.vel.y -= 0.003;
          pr.sprite.position.add(pr.vel);
          pr.sprite.material.opacity = Math.max(0, 1 - Math.pow(pr.age/pr.life, 2));
          if(pr.sprite.rotation !== undefined){ pr.sprite.rotation += (pr.rot||0); }

          if(pr.age > pr.life){
            const pos = pr.sprite.position.clone();
            try{ unmarkBillboard(pr.sprite); }catch{}
            pr.sprite.parent?.remove(pr.sprite); pr.sprite.material?.map?.dispose?.(); pr.sprite.material?.dispose?.();

            let newTokens = [], nextKind = null;
            try{
              if(pr.kind === 'value'){
                const rawFormula = (pr.cell?.formula && String(pr.cell.formula).trim().startsWith('=')) ? String(pr.cell.formula) : '';
                const rawValue = !rawFormula ? String(pr.cell?.value ?? '') : '';
                if(rawFormula){
                  newTokens = tokenizeFormulaForDatafall(rawFormula);
                } else {
                  const classified = classifyRawValue(rawValue);
                  if(classified.text){ newTokens = [classified]; }
                }
                nextKind = newTokens.length ? 'formula_chunk' : null;
              } else if(pr.kind === 'formula_chunk'){
                const text = String(pr.text ?? '');
                const tokenKind = pr.tokenKind || 'syntax';
                const trimmed = text.trim();
                if(trimmed===''){ nextKind = null; }
                else if(tokenKind === 'number' || (!Number.isNaN(Number(trimmed)) && trimmed!=='')){
                  const n = parseInt(trimmed, 10) || 0;
                  const bin = Math.abs(n).toString(2);
                  const bits = bin.length ? Array.from(bin) : ['0'];
                  newTokens = bits.map(bit=> ({ text: bit, tokenKind: 'binary_bit', color: DATAFALL_COLORS.number }));
                  nextKind = 'binary_bit';
                } else {
                  const plain = tokenKind === 'string' ? text.replace(/^\"|\"$/g,'') : text;
                  const chars = Array.from(plain);
                  newTokens = chars.map(ch=>{
                    const code = ch.codePointAt(0);
                    return { text: code != null ? String(code) : '', tokenKind: 'char_code', color: pr.color || DATAFALL_COLORS.syntax, code, sourceChar: ch };
                  }).filter(tok=> tok.text !== '');
                  nextKind = 'char_code';
                }
              } else if(pr.kind === 'char_code'){
                const baseColor = pr.color || DATAFALL_COLORS.binary;
                const n = (typeof pr.code === 'number' && Number.isFinite(pr.code)) ? pr.code : parseInt(pr.text ?? '0', 10);
                if(!Number.isFinite(n)) { continue; }
                const bin = Math.abs(n).toString(2) || '0';
                newTokens = Array.from(bin).map(bit=> ({ text: bit, tokenKind: 'binary_bit', color: baseColor }));
                nextKind = 'binary_bit';
              } else { continue; }
            }catch{ continue; }

            if(!nextKind || !newTokens.length){ continue; }
            newTokens.forEach(token=>{
              const label = String(token.text ?? '');
              if(label==='') return;
              const color = token.color || pr.color || DATAFALL_COLORS.syntax;
              const sp = makeCharSprite(label, color);
              sp.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random())*0.2, (Math.random()-0.5)*0.2));
              const vel = new THREE.Vector3((Math.random()-0.5)*0.015, (Math.random())*0.02, (Math.random()-0.5)*0.015);
              eff.group.add(sp);
              const baseLife = nextKind === 'binary_bit'
                ? 1000 + Math.random()*500
                : nextKind === 'char_code'
                  ? 1100 + Math.random()*500
                  : 900 + Math.random()*600;
              next.push({
                kind: nextKind,
                text: label,
                code: token.code !== undefined ? token.code : parseInt(label,10),
                sprite: sp,
                vel,
                age: 0,
                life: baseLife,
                rot:(Math.random()-0.5)*0.05,
                color,
                tokenKind: token.tokenKind || pr.tokenKind,
                sourceChar: token.sourceChar || pr.sourceChar
              });
            });
          } else {
            next.push(pr);
          }
        }
        eff.particles = next;
        if(eff.particles.length===0){ try{ const cb=eff.onDone; eff.group.parent?.remove(eff.group); if(typeof cb==='function') cb(); }catch{} deleteEffects.splice(i,1); }
        continue;
      }

      if(eff.phase === 'axisFall'){
        const nextLabels = [];
        for(let k=0; k<eff.labels.length; k++){
          const lbl = eff.labels[k];
          lbl.age += dtMs;
          lbl.vel.y -= 0.0025;
          lbl.mesh.position.add(lbl.vel);
          if(lbl.mesh.rotation){
            lbl.mesh.rotation.x += lbl.rot.x;
            lbl.mesh.rotation.y += lbl.rot.y;
            lbl.mesh.rotation.z += lbl.rot.z;
          }
          if(lbl.mesh.material && typeof lbl.mesh.material.opacity==='number'){
            lbl.mesh.material.opacity = Math.max(0, lbl.mesh.material.opacity - 0.01);
          }
          if(lbl.age < lbl.life){
            nextLabels.push(lbl);
          } else {
            try{ lbl.mesh.parent?.remove(lbl.mesh); }catch{}
          }
        }
        eff.labels = nextLabels;
        if(nextLabels.length===0){
          try{ eff.onDone?.(); }catch{}
          deleteEffects.splice(i,1);
        }
        continue;
      }

      if(eff.phase === 'hover'){
        // Subtle hover/vibrate for ~450ms
        eff.clones.forEach(c=>{
          c.t += dtMs;
          const up = Math.sin(c.t * 0.01) * 0.06;
          const wob = 0.9 + Math.sin(c.t * 0.013) * 0.05 + 0.05;
          c.sprite.position.y = c.origin.y + up;
          c.sprite.scale.set(wob, wob, 1);
        });
        if(eff.t > 450){
          // Explode into raining characters (prefer full formula text)
          eff.phase = 'explode';
          eff.clones.forEach(c=>{
            try{
              let raw = (c.cell?.formula && String(c.cell.formula)[0] === '=') ? String(c.cell.formula) : String(c.cell?.value ?? '');
              if(!raw || raw.trim()==='') raw = String(c.text||'');
              // Split into Unicode code points (grapheme clusters approximation)
              const chars = Array.from(raw).slice(0, 96);
              // Remove the big clone before raining
              try{ unmarkBillboard(c.sprite); }catch{}
              c.sprite.parent?.remove(c.sprite);
              c.sprite.material.map?.dispose?.();
              c.sprite.material?.dispose?.();

              chars.forEach(ch=>{
                if(ch === ' ') return;
                const p = makeCharSprite(ch);
                p.position.copy(c.origin).add(new THREE.Vector3((Math.random()-0.5)*0.4, (Math.random()-0.5)*0.4, 0.55));
                const vel = new THREE.Vector3(
                  (Math.random()-0.5)*0.06,
                  -(Math.random()*0.06 + 0.02),
                  (Math.random()-0.5)*0.06
                );
                p.rotation = (Math.random()-0.5)*0.5;
                eff.group.add(p);
                eff.particles.push({ kind:'char', ch, sprite:p, vel, age:0, life:900 + Math.random()*500, rot:(Math.random()-0.5)*0.12 });
              });
            }catch{}
          });
          eff.clones.length = 0;
          // Per-particle staged cascade handled in update loop
        }
      } else if(eff.phase === 'explode'){
        // Per-particle cascade with slow downward drift
        const next = [];
        for(let k=0; k<eff.particles.length; k++){
          const pr = eff.particles[k];
          pr.age += dtMs;
          // Slow downward drift
          pr.vel.y -= 0.003;
          pr.sprite.position.add(pr.vel);
          pr.sprite.material.opacity = Math.max(0, 1 - pr.age/pr.life);
          pr.sprite.rotation += pr.rot;

          // Stage transitions per particle
          if(pr.kind === 'char' && pr.age > pr.life){
            try{
              const code = (pr.ch && pr.ch.codePointAt) ? pr.ch.codePointAt(0) : null;
              const label = (code!=null)
                ? (code > 0x7f ? `U+${code.toString(16).toUpperCase()}` : String(code))
                : String(pr.ch||'');
              // Replace char sprite with a number sprite at current position
              const pos = pr.sprite.position.clone();
              try{ unmarkBillboard(pr.sprite); }catch{}
              pr.sprite.parent?.remove(pr.sprite);
              pr.sprite.material?.map?.dispose?.();
              pr.sprite.material?.dispose?.();
              const sp = makeCharSprite(label);
              sp.position.copy(pos);
              const vel = new THREE.Vector3((Math.random()-0.5)*0.04, -(Math.random()*0.04 + 0.01), (Math.random()-0.5)*0.04);
              eff.group.add(sp);
              next.push({ kind:'number', code, sprite:sp, vel, age:0, life:900 + Math.random()*500, rot:(Math.random()-0.5)*0.14 });
            }catch{}
            continue;
          }

          if(pr.kind === 'number' && pr.age > pr.life){
            try{
              const pos = pr.sprite.position.clone();
              const n = (typeof pr.code==='number' && isFinite(pr.code)) ? pr.code : null;
              let bin = (n!=null) ? n.toString(2) : '';
              if(!bin) bin = '0';
              try{ unmarkBillboard(pr.sprite); }catch{}
              pr.sprite.parent?.remove(pr.sprite);
              pr.sprite.material?.map?.dispose?.();
              pr.sprite.material?.dispose?.();
              // Spawn bits from current position
              Array.from(bin).forEach(bit=>{
                const sp = makeCharSprite(bit);
                sp.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.12, (Math.random())*0.10, (Math.random()-0.5)*0.12));
                const vel = new THREE.Vector3((Math.random()-0.5)*0.06, -(Math.random()*0.06 + 0.02), (Math.random()-0.5)*0.06);
                eff.group.add(sp);
                next.push({ kind:'bit', sprite:sp, vel, age:0, life:1000 + Math.random()*500, rot:(Math.random()-0.5)*0.2 });
              });
            }catch{}
            continue;
          }

          if(pr.kind === 'bit' && pr.age > pr.life){
            try{
              try{ unmarkBillboard(pr.sprite); }catch{}
              pr.sprite.parent?.remove(pr.sprite);
              pr.sprite.material?.map?.dispose?.();
              pr.sprite.material?.dispose?.();
            }catch{}
            continue;
          }

          // keep particle
          next.push(pr);
        }
        eff.particles = next;

        // Clean up when all particles are gone
        if(eff.particles.length === 0){
          try{
            eff.group.parent?.remove(eff.group);
            eff.group.traverse(obj=>{
              if(obj.isSprite){
                obj.material?.map?.dispose?.();
                obj.material?.dispose?.();
              }else if(obj.isMesh){
                obj.geometry?.dispose?.();
                obj.material?.dispose?.();
              }
            });
          }catch{}
          deleteEffects.splice(i, 1);
        }
    }
  }

    if(deleteInteractionLock){
      const now = nowMs();
      const finalizeIds = [];
      pendingDatafallDeletes.forEach((rec, key)=>{
        if(!rec) return;
        if(rec.finalizing) return;
        const arrId = rec.arrId ?? Number(key);
        if(rec.finished && ((rec.count|0) <= 0)){
          if(Number.isFinite(arrId)){ finalizeIds.push(arrId); }
          else {
            try{ releaseDeletionInteractions(); }catch{}
            pendingDatafallDeletes.delete(key);
          }
          return;
        }
        if(rec.finished){
          const idleSince = rec.finishedAt ?? rec.lastActive ?? rec.startedAt ?? now;
          if(now - idleSince > 2400){
            rec.count = 0;
            rec.lastActive = now;
            pendingDatafallDeletes.set(key, rec);
            if(Number.isFinite(arrId)){ finalizeIds.push(arrId); }
            else {
              try{ releaseDeletionInteractions(); }catch{}
              pendingDatafallDeletes.delete(key);
            }
          }
        }
      });
      finalizeIds.forEach(id=>{
        try{ maybeFinalizeDeletion(id); }catch{}
      });
      if(!pendingDatafallDeletes.size && !deleteEffects.length){
        try{ releaseDeletionInteractions(); }catch{}
      }
    }
}

  function removeArrayGraphics(arr){
    try{
      // Remove layer meshes (all types + edge overlays)
      for(let z=0; z<arr.size.z; z++){
        ['empty','ghost','filled','formula'].forEach(type=>{
          const key = `${arr.id}:${z}:${type}`;
          const rec = layerMeshes.get(key);
          if(rec){
            rec.mesh.parent?.remove(rec.mesh);
            rec.mesh.geometry?.dispose?.();
            rec.mesh.material?.dispose?.();
            layerMeshes.delete(key);
          }
          const key2 = `${key}:edges`;
          const rec2 = layerMeshes.get(key2);
          if(rec2){
            rec2.mesh.parent?.remove(rec2.mesh);
            rec2.mesh.geometry?.dispose?.();
            rec2.mesh.material?.dispose?.();
            layerMeshes.delete(key2);
          }
        });
      }
      // Remove legacy chunk meshes
      [...chunkMeshes.keys()].forEach(k=>{
        if(String(k).startsWith(`${arr.id}:`)){
          const mesh = chunkMeshes.get(k);
          if(mesh){
            scene.remove(mesh);
            mesh.geometry?.dispose?.();
            mesh.material?.dispose?.();
          }
          chunkMeshes.delete(k);
        }
      });
      // Remove labels/grab
      (arr.labels||[]).forEach(s=>{
        try{
          if(s?.userData?.billboard) unmarkBillboard(s);
          s.parent?.remove(s);
          s.material?.map?.dispose?.();
          s.material?.dispose?.();
        }catch{}
      });
      arr.labels = [];

      // Remove frame
      if(arr._frame){
        try{
          scene.remove(arr._frame);
          arr._frame.traverse(obj=>{
            if(obj.isMesh){
              obj.geometry?.dispose?.();
              obj.material?.dispose?.();
            }
          });
        }catch{}
        arr._frame = null;
      }
      // Reset transforms/meshes for clean rebuild
      try{ arr.rotationQuat = arr.rotationQuat || [0,0,0,1]; }catch{}
      try{ Object.values(arr.chunks||{}).forEach(ch=>{ ch.meshLOD1=null; ch.meshLOD2=null; ch.currentLOD=-1; ch._dirty=true; }); }catch{}

      // Remove colliders
      try{ clearColliders(arr); }catch{}

      // Remove value sprites for this array
      [...valueSprites.keys()].forEach(key=>{
        if(key.startsWith(`${arr.id}:`)){
          const sp = valueSprites.get(key);
          if(sp){
            sp.parent?.remove(sp);
            sp.material?.map?.dispose?.();
            sp.material?.dispose?.();
          }
          valueSprites.delete(key);
        }
      });
    }catch(e){ console.warn('removeArrayGraphics failed', e); }
  }

  function reconcileAllArrays(){
    console.log('Reconciling all arrays...');
    Object.values(Store.getState().arrays).forEach(arr => {
      console.log(`Reconciling array #${arr.id} "${arr.name}"`);
      arr._layersRendered = false; // Force re-render
      // Ensure each chunk's mesh reflects current content immediately
      try{ Object.values(arr.chunks||{}).forEach(ch=> ch._dirty=true); }catch{}
      renderArray(arr);
      // Apply visibility after render (hide reserved arrays like Mainframe)
      try{ syncVisibility(arr); }catch{}
    });
  }

  function removeConnection(anchor){
    const key = aKey(anchor);
    if(connections.has(key)){
      const connection = connections.get(key);
      scene.remove(connection.line);
      connection.line.geometry.dispose();
      connection.line.material.dispose();
      connections.delete(key);
    }
  }

  function addConnection(anchor, ref1, ref2){
    removeConnection(anchor); // Clear any existing line from this anchor

    const arr1 = Store.getState().arrays[ref1.arrId];
    const arr2 = Store.getState().arrays[ref2.arrId];
    if(!arr1 || !arr2) return;

    const start = worldPos(arr1, ref1.x, ref1.y, ref1.z);
    const end = worldPos(arr2, ref2.x, ref2.y, ref2.z);

    const points = [start, end];
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ color: COLORS.grab, linewidth: 2 });
    const line = new THREE.Line(geometry, material);
    line.renderOrder = 100;

    scene.add(line);
    connections.set(aKey(anchor), { line, start, end, anchor, ref1, ref2 });
  }

  function createArraySnapshot(arr) {
    const geometries = [];
    // Iterate through all VISIBLE layer meshes of the source array
    layerMeshes.forEach((rec, key) => {
      if (key.startsWith(`${arr.id}:`) && rec.mesh.visible && rec.mesh.count > 0) {
        const mesh = rec.mesh;
        for (let i = 0; i < mesh.count; i++) {
          const geo = mesh.geometry.clone();
          const matrix = new THREE.Matrix4();
          mesh.getMatrixAt(i, matrix);
          geo.applyMatrix4(matrix);
          geometries.push(geo);
        }
      }
    });
    if (geometries.length === 0) return null;

    // Note: BufferGeometryUtils would be needed for mergeGeometries
    // For now, create a simple group
    const group = new THREE.Group();
    geometries.forEach(geo => {
      const mesh = new THREE.Mesh(geo, new THREE.MeshNormalMaterial());
      group.add(mesh);
    });
    return group;
  }
  // Rotate array around a world-space pivot by 90° steps per axis
  function rotateArrayAround(arr, pivotWorld, stepsX=0, stepsY=0, stepsZ=0){
    if(!arr?._frame) return;
    const snap=(v)=> Math.round(v);
    const apply=(axis, steps)=>{
      const n=((steps%4)+4)%4; if(n===0) return;
      const angle=n*(Math.PI/2);
      const pos=arr._frame.position.clone().sub(pivotWorld);
      pos.applyAxisAngle(axis, angle).add(pivotWorld);
      arr._frame.position.copy(pos);
      arr._frame.rotateOnWorldAxis(axis, angle);
      // snap position to integer grid after each axis to minimize drift
      arr._frame.position.set(snap(arr._frame.position.x), snap(arr._frame.position.y), snap(arr._frame.position.z));
    };
    apply(new THREE.Vector3(1,0,0), stepsX);
    apply(new THREE.Vector3(0,1,0), stepsY);
    apply(new THREE.Vector3(0,0,1), stepsZ);
    // persist offset for future renders
    arr.offset = { x: arr._frame.position.x, y: arr._frame.position.y, z: arr._frame.position.z };
    // Persist rotation for save
    try{
      arr.rotationQuat = arr._frame.quaternion.toArray();
      const rs = arr.rotationSteps || {x:0,y:0,z:0};
      arr.rotationSteps = {
        x: ((rs.x||0) + (stepsX|0))%4,
        y: ((rs.y||0) + (stepsY|0))%4,
        z: ((rs.z||0) + (stepsZ|0))%4,
      };
    }catch{}
  }
  // Compute world position of a cell, respecting current frame transform
  function cellWorldPos(arr, x, y, z){
    const lp = localPos(arr, x, y, z).clone();
    if(arr._frame){ return arr._frame.localToWorld(lp); }
    const off = arr.offset||{x:0,y:0,z:0};
    lp.x += off.x; lp.y += off.y; lp.z += off.z; return lp;
  }

  function refreshArray(arr){
    if(!arr || !arr._frame) return;
    try{
      const old = arr._frame.userData?.labelSprite;
      if(old){ try{ if(old?.userData?.billboard) unmarkBillboard(old); }catch{} old.parent?.remove(old); old.material?.map?.dispose?.(); old.material?.dispose?.(); old.geometry?.dispose?.(); }
      const labelSprite = makeArrayLabelSprite(arr);
      // Initial position will be updated by updateArrayLabelPlacement
      labelSprite.position.set(0, arr.size.y/2 + 0.8, 0);
      arr._frame.add(labelSprite);
      arr._frame.userData.labelSprite = labelSprite;
    }catch{}
  }
  // Rehydrate all arrays from current Store state: ensure LOD1 meshes, apply occlusion for the focused array, and rebuild value sprites
  function hydrateAll(){
    try{
      const S = Store.getState();
      const sel = S.selection || {};
      Object.values(S.arrays).forEach(arr=>{
        try{ Object.values(arr.chunks||{}).forEach(ch=>{ ch.ensureMesh?.(); ch.setLOD?.(1); rehydrateChunkInstances(arr, ch); }); }catch{}
        // Apply occlusion mask only to the focused array so others start solid
        if(sel.arrayId === arr.id && sel.focus){
          try{ computeOcclusion(arr, sel.focus); applyGhostMaskToChunks(arr); }catch{}
        }
        // Rebuild value sprites for visible cells (clear first to prevent duplicates)
        try{
          valueSprites.forEach((sprite,key)=>{ if(String(key).startsWith(`${arr.id}:`)){ try{ unmarkBillboard(sprite); sprite.parent?.remove(sprite); sprite.material?.map?.dispose?.(); sprite.material?.dispose?.(); }catch{} valueSprites.delete(key); } });
          Object.values(arr.chunks||{}).forEach(ch=>{
            (ch.cells||[]).forEach(c=>{
              try{ const cell = Formula.getCell({arrId: arr.id, x:c.x, y:c.y, z:c.z}); if(cell && (cell.value!=='' && cell.value!==null && cell.value!==undefined)) updateValueSprite(arr, c.x, c.y, c.z, cell); }catch{}
            });
          });
          // Ensure sprites are positioned on the current camera-facing face
          try{ updateArrayValueSpritePlacement(arr); }catch{}
        }catch{}
      });
      try{ forceRenderOrderRefresh?.(true); }catch{}
      needsRender = true;
    }catch{}
  }
  
  function updateArrayLabelPlacement(arr){
    const label = arr?._frame?.userData?.labelSprite;
    const grab  = arr.labels?.find(l => l.userData?.type === 'grab');
    if(!label || !grab) return;

    // world positions
    grab.updateWorldMatrix(true, false);
    const grabW = new THREE.Vector3(); grab.getWorldPosition(grabW);

    const camW = camera.position;
    const toCam = new THREE.Vector3().subVectors(camW, grabW);
    toCam.y = 0;
    if(toCam.lengthSq() < 1e-6){ toCam.set(0,0,1); }
    toCam.normalize();

    // offsets: a little above in world Y, and a little toward the camera (horizontal only)
    const up = new THREE.Vector3(0,1,0);
    const above   = up.multiplyScalar(0.35 + Math.abs(label.scale.y)*0.5);
    const inFront = toCam.multiplyScalar(0.3);

    const targetW = grabW.clone().add(above).add(inFront);

    // place in the frame's local space (so it follows naturally)
    const parent = arr._frame || scene;
    parent.worldToLocal(targetW);
    label.position.copy(targetW);

    // keep it facing camera without touching renderOrder
    label.lookAt(camera.position);
  }
  return {init, renderArray, renderChunk, renderLayer, updateFocus, centerOnArray, syncVisibility, setGridVisible, setAxesVisible, rebuildCollidersForArray, debounceColliderRebuild, setHighlightMode, setCameraLock, setViewMode, initAvatars, updateAvatars, addTimedPreview, handleJump, getCamera:()=>camera, getControls:()=>controls, updateValueSprite, setArrayOffset, reconcileAllArrays, setupRenderer, setupLighting, addConnection, removeConnection, createArraySnapshot, worldPos, getScene:()=>scene, getLayerMesh:(key)=>layerMeshes.get(key), rotateArrayAround, cellWorldPos, spawnDeleteExplosion, startDatafallDelete, removeArrayGraphics, refreshArray, updateArrayLabelPlacement, dockOffsetFor, Chunk, ChunkManager, localPos, createCellMaterial, GEO_VOXEL, getCell:getCellFast, captureCamera, restoreCamera, updateCellColor:(arrId, coord)=>updateCellColor(arrId, coord), togglePresentMode, isPresentEnabled, getGraphicsSettings, updateGraphicsSettings};
})();

/* ===========================
   UI
=========================== */
const UI = (()=>{
  let dragStart=null;
  let hovered2D = null; // {arrId,x,y,z}
  const els={
    fx:document.getElementById('fx'), fxHighlight:document.getElementById('fxHighlight'), apply:document.getElementById('applyFx'),
    toggleFxPanel:document.getElementById('toggleFxPanel'), fxPanel:document.getElementById('fxPanel'),
    fxBody:document.getElementById('fxBody'), fxClose:document.getElementById('fxClose'),
    focusChip:document.getElementById('focusChip'), inspect:document.getElementById('inspect'),
    centerHome:document.getElementById('centerHome'), viewMainframe:document.getElementById('viewMainframe'),
    toggleGrid:document.getElementById('toggleGrid'), toggleAxes:document.getElementById('toggleAxes'),
    presentToggle:document.getElementById('presentToggleBtn'), graphicsSettingsBtn:document.getElementById('graphicsSettingsBtn'), crystalToggle:document.getElementById('crystal2DToggle'),
    physicsBtn:document.getElementById('physicsBtn'), reset:document.getElementById('reset'),
    status:document.getElementById('statusChip'),
    sheetTitle:document.getElementById('sheetTitle'),
    zPrev:document.getElementById('zPrev'), zNext:document.getElementById('zNext'), zLabel:document.getElementById('zLabel'),
    rowHeaders:document.getElementById('rowHeaders'), colHeaders:document.getElementById('colHeaders'), grid:document.getElementById('grid'),
    direct:document.getElementById('directEdit')
  };
  // Local Excel-style column name generator to avoid any global shadowing
  const colNameFromIndex=(n)=>{ let s=''; let v=n+1; while(v>0){ const r=(v-1)%26; s=String.fromCharCode(65+r)+s; v=Math.floor((v-1)/26);} return s; };
  // 2D sheet column widths (px) — persisted in-memory across renders
  const colWidths = {};
  const getColWidth=(i)=> (colWidths[i]||100);
  const setColWidth=(i,w)=>{ colWidths[i]=Math.max(60, Math.min(480, Math.round(w))); };

  const graphicsPanel = document.getElementById('graphicsSettingsPanel');
  const graphicsClose = document.getElementById('graphicsSettingsClose');
  const graphicsPanelHint = document.getElementById('graphicsSettingsHint');
  const graphicsControls = {
    hdri: document.getElementById('gfxHdri'),
    lights: document.getElementById('gfxLights'),
    darkBg: document.getElementById('gfxDarkBg'),
    bloom: document.getElementById('gfxBloom'),
    bloomStrength: document.getElementById('gfxBloomStrength'),
    bloomRadius: document.getElementById('gfxBloomRadius'),
    exposure: document.getElementById('gfxExposure'),
    dof: document.getElementById('gfxDof'),
    dofAperture: document.getElementById('gfxDofAperture'),
    dofMaxBlur: document.getElementById('gfxDofMaxBlur'),
    transmission: document.getElementById('gfxTransmission'),
    mirror: document.getElementById('gfxMirror'),
    ground: document.getElementById('gfxGround'),
    waveGrid: document.getElementById('gfxWaveGrid'),
    fxaa: document.getElementById('gfxFxaa'),
    fog: document.getElementById('gfxFog'),
    fogDensity: document.getElementById('gfxFogDensity'),
    outline: document.getElementById('gfxOutline'),
    outlineStrength: document.getElementById('gfxOutlineStrength'),
    outlineThickness: document.getElementById('gfxOutlineThickness'),
    motion: document.getElementById('gfxMotion'),
    motionDamping: document.getElementById('gfxMotionDamping')
  };
  const graphicsSliderDisplays = {
    bloomStrength: document.getElementById('gfxBloomStrengthValue'),
    bloomRadius: document.getElementById('gfxBloomRadiusValue'),
    exposure: document.getElementById('gfxExposureValue'),
    dofAperture: document.getElementById('gfxDofApertureValue'),
    dofMaxBlur: document.getElementById('gfxDofMaxBlurValue'),
    fogDensity: document.getElementById('gfxFogDensityValue'),
    outlineStrength: document.getElementById('gfxOutlineStrengthValue'),
    outlineThickness: document.getElementById('gfxOutlineThicknessValue'),
    motionDamping: document.getElementById('gfxMotionDampingValue')
  };
  let graphicsPanelVisible = false;

  const sliderFormatters = {
    bloomStrength: (v)=>v.toFixed(2),
    bloomRadius: (v)=>v.toFixed(2),
    exposure: (v)=>v.toFixed(2),
    dofAperture: (v)=>v.toFixed(4),
    dofMaxBlur: (v)=>v.toFixed(4),
    fogDensity: (v)=>v.toFixed(3),
    outlineStrength: (v)=>v.toFixed(1),
    outlineThickness: (v)=>v.toFixed(2),
    motionDamping: (v)=>v.toFixed(3)
  };

  function updateSliderDisplay(key, value){
    const span = graphicsSliderDisplays[key];
    if(!span) return;
    const formatter = sliderFormatters[key] || ((v)=>v.toFixed(2));
    span.textContent = formatter(Number(value));
  }

  function syncGraphicsSettings(){
    if(!Scene.getGraphicsSettings) return;
    const settings = Scene.getGraphicsSettings();
    if(!settings) return;
    if(graphicsControls.hdri) graphicsControls.hdri.checked = !!settings.hdri;
    if(graphicsControls.lights) graphicsControls.lights.checked = !!settings.lights;
    if(graphicsControls.darkBg) graphicsControls.darkBg.checked = !!settings.darkBg;
    if(graphicsControls.bloom) graphicsControls.bloom.checked = !!settings.bloomEnabled;
    if(graphicsControls.bloomStrength){ graphicsControls.bloomStrength.value = settings.bloomStrength; updateSliderDisplay('bloomStrength', settings.bloomStrength); }
    if(graphicsControls.bloomRadius){ graphicsControls.bloomRadius.value = settings.bloomRadius; updateSliderDisplay('bloomRadius', settings.bloomRadius); }
    if(graphicsControls.exposure){ graphicsControls.exposure.value = settings.exposure; updateSliderDisplay('exposure', settings.exposure); }
    if(graphicsControls.dof) graphicsControls.dof.checked = !!settings.dofEnabled;
    if(graphicsControls.dofAperture){ graphicsControls.dofAperture.value = settings.dofAperture; updateSliderDisplay('dofAperture', settings.dofAperture); }
    if(graphicsControls.dofMaxBlur){ graphicsControls.dofMaxBlur.value = settings.dofMaxBlur; updateSliderDisplay('dofMaxBlur', settings.dofMaxBlur); }
    if(graphicsControls.transmission) graphicsControls.transmission.checked = !!settings.transmission;
    if(graphicsControls.ground) graphicsControls.ground.checked = !!settings.solidGround;
    if(graphicsControls.mirror){
      graphicsControls.mirror.checked = !!settings.mirror && !settings.solidGround;
      graphicsControls.mirror.disabled = !!settings.solidGround;
    }
    if(graphicsControls.waveGrid) graphicsControls.waveGrid.checked = !!settings.waveGrid;
    if(graphicsControls.fxaa) graphicsControls.fxaa.checked = !!settings.fxaa;
    if(graphicsControls.fog) graphicsControls.fog.checked = !!settings.fogEnabled;
    if(graphicsControls.fogDensity){ graphicsControls.fogDensity.value = settings.fogDensity; updateSliderDisplay('fogDensity', settings.fogDensity); }
    if(graphicsControls.outline) graphicsControls.outline.checked = !!settings.outlineEnabled;
    if(graphicsControls.outlineStrength){ graphicsControls.outlineStrength.value = settings.outlineStrength; updateSliderDisplay('outlineStrength', settings.outlineStrength); }
    if(graphicsControls.outlineThickness){ graphicsControls.outlineThickness.value = settings.outlineThickness; updateSliderDisplay('outlineThickness', settings.outlineThickness); }
    if(graphicsControls.motion) graphicsControls.motion.checked = !!settings.motionEnabled;
    if(graphicsControls.motionDamping){ graphicsControls.motionDamping.value = settings.motionDamping; updateSliderDisplay('motionDamping', settings.motionDamping); }
  }

  function setGraphicsControlsEnabled(enabled){
    const settings = Scene.getGraphicsSettings ? Scene.getGraphicsSettings() : null;
    Object.entries(graphicsControls).forEach(([key, ctrl])=>{
      if(!ctrl) return;
      const mirrorLocked = (key==='mirror' && settings?.solidGround);
      ctrl.disabled = !enabled || mirrorLocked;
    });
    if(graphicsPanelHint) graphicsPanelHint.style.display = enabled ? 'none' : 'block';
  }

  function updatePresentButton(state){
    if(!els.presentToggle) return;
    els.presentToggle.textContent = state ? '🎨 Present: ON' : '🎨 Present: OFF';
    if(state){ els.presentToggle.classList.add('good'); }
    else { els.presentToggle.classList.remove('good'); }
  }

  let lastCrystalState = document.body?.classList?.contains('crystal-2d') || false;
  function applyCrystalStyle(enabled){
    const want = !!enabled;
    if(els.crystalToggle && els.crystalToggle.checked !== want){
      els.crystalToggle.checked = want;
    }
    if(lastCrystalState === want){
      if(!want){ try{ document.body.classList.remove('crystal-2d'); }catch{} }
      return;
    }
    lastCrystalState = want;
    try{
      if(want){ document.body.classList.add('crystal-2d'); }
      else { document.body.classList.remove('crystal-2d'); }
    }catch{}
  }

  function showGraphicsPanel(){
    if(!graphicsPanel) return;
    graphicsPanelVisible = true;
    graphicsPanel.style.display = 'block';
    syncGraphicsSettings();
    setGraphicsControlsEnabled(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false);
  }

  function hideGraphicsPanel(){
    if(!graphicsPanel) return;
    graphicsPanelVisible = false;
    graphicsPanel.style.display = 'none';
  }

  function toggleGraphicsPanel(){
    if(graphicsPanelVisible) hideGraphicsPanel(); else showGraphicsPanel();
  }

  function init(){
    console.log('UI.init: starting, checking elements...');
    console.log('UI.init: found elements:', {
      centerHome: !!els.centerHome,
      viewMainframe: !!els.viewMainframe,
      toggleGrid: !!els.toggleGrid,
      toggleAxes: !!els.toggleAxes,
      physicsBtn: !!els.physicsBtn,
      reset: !!els.reset
    });
    if(!Store.getState().ui?.crystal2D){
      try{ document.body.classList.remove('crystal-2d'); }catch{}
      lastCrystalState = false;
      if(els.crystalToggle){ els.crystalToggle.checked = false; }
    }
    // Touch-mode scaling
    try{ if(("ontouchstart" in window) || (navigator.maxTouchPoints>0) || (navigator.msMaxTouchPoints>0)){ document.body.classList.add('touch'); } }catch{}
    els.apply.onclick=()=>{ 
      const s=Store.getState().selection; if(!s.focus) return; 
      const anchor={arrId:s.arrayId,...s.focus};
      const formula=els.fx.value.trim();
      // Wrap user apply in a single atomic transaction
      const tx = Write.start('user.applyFx','User applying formula');
      Formula.executeAt(anchor, formula, tx);
      Write.commit(tx);
      updateFocusChip(); 
    };
    // 2D hover sync: detect hovered cell and propagate to 3D
    try{
      const sheetEl = document.getElementById('sheet');
      sheetEl?.addEventListener('mousemove', (e)=>{
        const td = e.target && e.target.closest && e.target.closest('td.cell');
        if(td){
          const x=+td.dataset.x, y=+td.dataset.y, z=+td.dataset.z; 
          const arrId = Store.getState().selection?.arrayId || Object.values(Store.getState().arrays)[0]?.id || 1;
          setHovered2D(arrId, {x,y,z});
        } else {
          setHovered2D(null, null);
        }
      }, true);
      sheetEl?.addEventListener('mouseleave', ()=> setHovered2D(null, null), true);
    }catch{}
    // Live syntax highlighting for formula input
    const syncFxHighlight = ()=>{
      const raw = els.fx.value || '';
      // Escape HTML
      const esc = (s)=> s.replace(/[&<>]/g, ch=> ({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch]));
      let h = esc(raw);
      // Strings in double quotes
      h = h.replace(/"([^"\\]|\\.)*"/g, m=> `<span class="tok-str">${esc(m)}</span>`);
      // Ranges @[x,y,z,a]
      h = h.replace(/@\[\-?\d+\,\-?\d+\,\-?\d+\,\-?\d+\]/g, m=> `<span class="tok-range">${esc(m)}</span>`);
      // Numbers (standalone) — avoid coloring inside quotes by running after strings
      h = h.replace(/(?<![A-Za-z0-9_@\"])(\-?\d+(?:\.\d+)?)(?![A-Za-z0-9_\"])/g, (m)=> `<span class="tok-num">${m}</span>`);
      els.fxHighlight.innerHTML = h || '';
    };
    // Keep formula bar and direct editor in sync in real time
    els.fx.addEventListener('input', ()=>{ 
      try{ if(els.direct && els.direct.style.display==='block'){ els.direct.value = els.fx.value; } }catch{}
      syncFxHighlight();
    });
    // Initialize once
    syncFxHighlight();
    els.fx.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); els.apply.click(); els.fx.blur(); }});
    if(els.toggleFxPanel) els.toggleFxPanel.onclick=toggleFxPanel;
    if(els.fxClose) els.fxClose.onclick=toggleFxPanel;
    // Make the formula row reliably focus the input on single click
    try{
      const fxRow = document.querySelector('#sheet .sheet-fx');
      fxRow?.addEventListener('click', (ev)=>{ if(ev.target!==els.apply) els.fx.focus(); }, true);
      const fxHL = document.getElementById('fxHighlight');
      fxHL?.addEventListener('click', ()=> els.fx.focus(), true);
    }catch{}
    // Make sheet draggable with immediate response (no transition while dragging)
    const sheetEl=document.getElementById('sheet'); let drag=false, sx=0, sy=0, sl=0, st=0, prevTrans='';
    const beginDrag=(clientX, clientY)=>{ drag=true; sheetEl.classList.add('dragging'); sx=clientX; sy=clientY; const r=sheetEl.getBoundingClientRect(); sl=r.left; st=r.top; prevTrans=sheetEl.style.transition; sheetEl.style.transition='none'; // kill easing
      // If mobile intro left a centering transform, clear it so absolute dragging is literal
      if(sheetEl.style.transform){ sheetEl.style.transform=''; }
    };
    const moveDrag=(clientX, clientY)=>{ if(!drag) return; const dx=clientX-sx, dy=clientY-sy; sheetEl.style.left=(sl+dx)+'px'; sheetEl.style.top=(st+dy)+'px'; sheetEl.style.bottom='auto'; };
    const endDrag=()=>{ if(!drag) return; drag=false; sheetEl.classList.remove('dragging'); sheetEl.style.transition=prevTrans||''; };
    sheetEl.addEventListener('mousedown',e=>{ if(e.target.closest('.sheet-head')){ beginDrag(e.clientX, e.clientY); e.preventDefault(); }});
    window.addEventListener('mousemove',e=> moveDrag(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);
    // Pointer events for touch
    sheetEl.addEventListener('pointerdown',e=>{ if(e.pointerType==='touch' && e.target.closest('.sheet-head')){ beginDrag(e.clientX, e.clientY); e.preventDefault(); sheetEl.setPointerCapture?.(e.pointerId); }});
    window.addEventListener('pointermove',e=>{ if(e.pointerType==='touch') moveDrag(e.clientX, e.clientY); });
    window.addEventListener('pointerup',e=>{ if(e.pointerType==='touch') endDrag(); });
    // Resizable via corner handle
    const res=document.getElementById('sheetResizer'); let resizing=false, rw=0,rh=0,rx=0,ry=0, resizePrevTrans='';
    res.addEventListener('mousedown',e=>{ resizing=true; const r=sheetEl.getBoundingClientRect(); rw=r.width; rh=r.height; rx=e.clientX; ry=e.clientY; resizePrevTrans=sheetEl.style.transition; sheetEl.style.transition='none'; e.stopPropagation(); e.preventDefault(); });
    window.addEventListener('mousemove',e=>{ if(!resizing) return; const dw=e.clientX-rx, dh=e.clientY-ry; sheetEl.style.width=(rw+dw)+'px'; sheetEl.style.height=(rh+dh)+'px'; });
    window.addEventListener('mouseup',()=>{ if(!resizing) return; resizing=false; sheetEl.style.transition=resizePrevTrans||''; });

    if(els.centerHome) els.centerHome.onclick=()=>{ const home=Store.getState().arrays[1]; if(home){ Scene.centerOnArray(home); Actions.setSelection(1,{x:0,y:2,z:0}); }};
    if(els.viewMainframe) els.viewMainframe.onclick=()=>{
      const mf=Store.getState().arrays[-1];
      if(mf){
        // Diegetic toggle: write formula to a control cell and execute
        const anchor={arrId:-1,x:0,y:mf.size.y-1,z:0};
        const currentlyHidden=!!mf.hidden;
        const formula = currentlyHidden? '=HIDE(@[0,'+(mf.size.y-1)+',0,-1],0,1)' : '=HIDE(@[0,'+(mf.size.y-1)+',0,-1],1,1)';
        Formula.executeAt(anchor, formula);
        // Move camera to show mainframe at its offset position
        const off = mf.offset || {x:0,y:0,z:0};
        Scene.getControls().target.set(off.x, off.y, off.z);
        Scene.getCamera().position.set(off.x + mf.size.x*1.2, off.y + mf.size.y*1.2, off.z + mf.size.z*1.8);
        Actions.setSelection(-1,{x:0,y:mf.size.y-1,z:0}); 
        UI.renderSheet(); // refresh 2D view
      }
    };
    if(els.toggleGrid) els.toggleGrid.onclick=Actions.toggleGrid;
    if(els.toggleAxes) els.toggleAxes.onclick=Actions.toggleAxes;
    if(els.presentToggle){
      updatePresentButton(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false);
      els.presentToggle.onclick=()=>{
        const state = Actions.togglePresentMode();
        updatePresentButton(state);
        setGraphicsControlsEnabled(state);
        syncGraphicsSettings();
      };
      setGraphicsControlsEnabled(Scene.isPresentEnabled ? Scene.isPresentEnabled() : false);
    }
    applyCrystalStyle(Store.getState().ui?.crystal2D);
    if(els.crystalToggle){
      els.crystalToggle.checked = !!Store.getState().ui?.crystal2D;
      if(!els.crystalToggle._wired){
        els.crystalToggle._wired = true;
        els.crystalToggle.addEventListener('change',(e)=>{
          Actions.setCrystal2D?.(!!e.target.checked);
        });
      }
    }
    if(els.graphicsSettingsBtn){
      els.graphicsSettingsBtn.onclick=()=>{ toggleGraphicsPanel(); };
    }
    if(graphicsClose && !graphicsClose._wired){
      graphicsClose._wired = true;
      graphicsClose.addEventListener('click',(e)=>{ e.preventDefault(); hideGraphicsPanel(); });
    }
    if(els.physicsBtn) els.physicsBtn.onclick=Actions.togglePhysics;
    // Render mode button removed - always simple mode
    if(els.reset) els.reset.onclick=()=>location.reload();
    // Toggle Chunk LOD manager
    const chunksBtn = document.getElementById('toggleChunks');
    if(chunksBtn){
      chunksBtn.textContent = 'Chunks: ON';
      chunksBtn.classList.add('good');
      chunksBtn.disabled = true;
      chunksBtn.title = 'Chunk mode is always ON';
    }

    const checkboxBindings = {
      hdri:'hdri', lights:'lights', darkBg:'darkBg', bloom:'bloomEnabled',
      dof:'dofEnabled', transmission:'transmission', mirror:'mirror', ground:'solidGround', waveGrid:'waveGrid',
      fxaa:'fxaa', fog:'fogEnabled', outline:'outlineEnabled', motion:'motionEnabled'
    };
    Object.entries(checkboxBindings).forEach(([key, setting])=>{
      const ctrl = graphicsControls[key];
      if(!ctrl) return;
      ctrl.addEventListener('change',(e)=>{
        if(setting === 'solidGround'){
          const next = !!e.target.checked;
          const patch = next ? { solidGround: true, mirror: false } : { solidGround: false };
          Actions.updateGraphicsSettings(patch);
        }else{
          Actions.updateGraphicsSettings({ [setting]: !!e.target.checked });
        }
        syncGraphicsSettings();
      });
    });

    const rangeBindings = {
      bloomStrength:'bloomStrength',
      bloomRadius:'bloomRadius',
      exposure:'exposure',
      dofAperture:'dofAperture',
      dofMaxBlur:'dofMaxBlur',
      fogDensity:'fogDensity',
      outlineStrength:'outlineStrength',
      outlineThickness:'outlineThickness',
      motionDamping:'motionDamping'
    };
    Object.entries(rangeBindings).forEach(([key, setting])=>{
      const ctrl = graphicsControls[key];
      if(!ctrl) return;
      ctrl.addEventListener('input',(e)=>{
        const value = parseFloat(e.target.value);
        Actions.updateGraphicsSettings({ [setting]: value });
        updateSliderDisplay(key, value);
      });
    });

    syncGraphicsSettings();

    // Save/Load buttons
    try{
      const saveBtn=document.getElementById('saveStateBtn');
      const loadBtn=document.getElementById('loadStateBtn');
      const clearBtn=document.getElementById('clearSaveBtn');
      if(saveBtn && !saveBtn._wired){ 
        saveBtn._wired=true; 
        saveBtn.addEventListener('click', ()=>{ 
          try{ 
            Store.getState().actions.saveState();
            const statusEl = document.getElementById('saveStatus');
            if(statusEl) statusEl.textContent = `Manual save: ${new Date().toLocaleTimeString()}`;
          }catch(e){ console.warn('save click failed', e); } 
        }); 
      }
      if(loadBtn && !loadBtn._wired){ loadBtn._wired=true; loadBtn.addEventListener('click', ()=>{ try{ Store.getState().actions.loadState(); }catch(e){ console.warn('load click failed', e); } }); }
      if(clearBtn && !clearBtn._wired){ clearBtn._wired=true; clearBtn.addEventListener('click', ()=>{ try{ Store.getState().actions.resetSave(); }catch(e){ console.warn('clear save click failed', e); } }); }
      
      // Parse emojis in debug UI
      if(typeof twemoji !== 'undefined'){
        try{ twemoji.parse(document.getElementById('hud'), {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
      }
    }catch{}

    // --- Import Functionality Wiring ---
    try{
      const fileInput = document.getElementById('fileImporter');
      const importBtn = document.getElementById('importFileBtn');
      const pasteBtn = document.getElementById('pasteDataBtn');
      const pasteModal = document.getElementById('pasteModal');
      const pasteInput = document.getElementById('pasteDataInput');
      const processPasteBtn = document.getElementById('processPasteBtn');
      const cancelPasteBtn = document.getElementById('cancelPasteBtn');

      if(importBtn) importBtn.onclick = ()=> fileInput && fileInput.click();
      if(fileInput) fileInput.onchange = (e)=>{
        const file = e.target.files && e.target.files[0];
        if(file){ const r=new FileReader(); r.onload=(ev)=> handleImportedData(ev.target.result, file.name); r.readAsArrayBuffer(file); }
        e.target.value='';
      };
      if(pasteBtn) pasteBtn.onclick=()=>{ if(pasteModal){ pasteModal.style.display='flex'; pasteInput && pasteInput.focus(); } };
      if(cancelPasteBtn) cancelPasteBtn.onclick=()=>{ if(pasteModal) pasteModal.style.display='none'; };
      if(processPasteBtn) processPasteBtn.onclick=()=>{
        const data = pasteInput ? pasteInput.value : '';
        if(String(data||'').trim()) handleImportedData(data, 'PastedData');
        if(pasteModal) pasteModal.style.display='none';
      };

      // Global drag-and-drop
      const dropZone = document.body;
      const overlay = document.getElementById('introOverlay');
      dropZone.addEventListener('dragover',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.style.opacity='0.5'; overlay.classList.remove('hidden'); } });
      dropZone.addEventListener('dragleave',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.classList.add('hidden'); overlay.style.opacity='1'; } });
      dropZone.addEventListener('drop',(e)=>{ e.preventDefault(); e.stopPropagation(); if(overlay){ overlay.classList.add('hidden'); overlay.style.opacity='1'; }
        const f=e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]; if(f){ const r=new FileReader(); r.onload=(ev)=> handleImportedData(ev.target.result, f.name); r.readAsArrayBuffer(f); }
      });
    }catch{}

    // Wire up the new color picker (+ Live / Apply / Clear)
    try{
      const picker = document.getElementById('fillColorPicker');
      const swatch = document.getElementById('fillColorSwatch');
      const live = document.getElementById('fillColorLive');
      const applyBtn = document.getElementById('fillColorApply');
      const clearBtn = document.getElementById('fillColorClear');

      function applyColorToSelection(hexOrEmpty){
        const s = Store.getState().selection;
        if (!s?.arrayId || !(s.focus || s.range)) return;

        const tx = Write.start('ui.colorPicker', 'Apply color to selection');
        const cells = [];
        if (s.range) {
          for(let y=s.range.y1; y<=s.range.y2; y++){
            for(let x=s.range.x1; x<=s.range.x2; x++){
              cells.push({x, y, z:s.range.z});
            }
          }
        } else {
          cells.push({...s.focus});
        }

        for(const coord of cells){
          const cell = Scene.getCell(s.arrayId, coord);
          Write.set(tx, s.arrayId, coord, {
            value: cell.value,
            formula: cell.formula,
            meta: { ...(cell.meta||{}), ...(hexOrEmpty ? {color:hexOrEmpty} : {color: ''}) }
          });
        }
        Write.commit(tx);
      }

      if(picker && !picker._wired){
        picker._wired = true;
        // Toggle popover when swatch clicked
        const wrap = document.getElementById('color-picker-wrapper');
        let pop = document.getElementById('colorPopover');
        if(!pop){
          pop = document.createElement('div');
          pop.id = 'colorPopover';
          pop.style.cssText = 'position:absolute; z-index:10020; background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.18); padding:10px; display:none;';
          document.body.appendChild(pop);
          // Prevent clicks inside from closing
          pop.addEventListener('click', (ev)=> ev.stopPropagation());
        }
        if(wrap && !wrap._popover){
          wrap._popover = true;
          // Build in-popover controls (Live | Apply | Clear) and hide external buttons
          try{
            if(pop && !pop._controls){
              pop._controls = true;
              const ctrl = document.createElement('div');
              ctrl.id = 'colorControlsInside';
              ctrl.style.cssText = 'display:flex;gap:8px;align-items:center;margin-top:8px;';
              ctrl.innerHTML = '<button id="fillColorApplyInside" class="btn" style="padding:4px 8px;">Apply</button><button id="fillColorClearInside" class="btn" style="padding:4px 8px;">Clear</button>';
              pop.appendChild(ctrl);
              // Wire
              const applyInside = ctrl.querySelector('#fillColorApplyInside');
              const clearInside = ctrl.querySelector('#fillColorClearInside');
              applyInside?.addEventListener('click', ()=> applyColorToSelection(picker?.value||'#ffffff'));
              clearInside?.addEventListener('click', ()=> applyColorToSelection(''));
              // Hide external controls in sheet toolbar (including old Live and bar preview)
              try{
                if(applyBtn) applyBtn.style.display='none';
                if(clearBtn) clearBtn.style.display='none';
                if(live){ const lab=live.closest('label'); if(lab) lab.style.display='none'; live.style.display='none'; }
                const bar = document.getElementById('fillColorPreview'); if(bar) bar.style.display='none';
              }catch{}
            }
          }catch{}
          wrap.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(pop){
              const rect = wrap.getBoundingClientRect();
              const belowPickerOffset = 260; // place well below native color UI
              const desiredTop = rect.bottom + belowPickerOffset;
              const maxTop = Math.max(0, (window.innerHeight||800) - 120);
              pop.style.left = Math.max(8, Math.min(rect.left, (window.innerWidth||1200) - 220)) + 'px';
              pop.style.top = Math.min(desiredTop, maxTop) + 'px';
              pop.style.display = (pop.style.display==='none'||!pop.style.display) ? 'block' : 'none';
            }
          });
          document.addEventListener('click', ()=>{ if(pop) pop.style.display='none'; }, true);
        }
        picker.addEventListener('input', (e)=>{
          const newColor = String(e.target.value||'').trim();
          if(swatch) swatch.style.backgroundColor = newColor;
          // Live apply is ON by default
          try{ applyColorToSelection(newColor); }catch{}
        });
      }

      // External buttons are deprecated; ensure hidden; hide external Live and bar preview too
      if(applyBtn){ applyBtn.style.display='none'; }
      if(clearBtn){ clearBtn.style.display='none'; }
      if(live){ const lab=live.closest('label'); if(lab) lab.style.display='none'; live.style.display='none'; }
      const bar = document.getElementById('fillColorPreview'); if(bar) bar.style.display='none';
    }catch{}

    // Wire up the new view toggle button
    try{
      const viewToggleBtn = document.getElementById('viewToggleBtn');
      const viewToggleIcon = document.getElementById('viewToggleIcon');
      if(viewToggleBtn && !viewToggleBtn._wired){
        viewToggleBtn._wired = true;
        viewToggleBtn.addEventListener('click', ()=>{
          const S=Store.getState(); const current=S.ui.viewMode||'standard';
          let next='standard';
          // Cycle: standard (gray) -> solid (blue) -> hideEmpty (white) -> standard
          if(current==='standard') next='solid';
          else if(current==='solid') next='hideEmpty';
          else next='standard';

          // Update button fill and stroke per spec
          if(next==='standard'){ // gray fill
            if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#9ca3af';
            if(viewToggleIcon) viewToggleIcon.style.stroke = '#ffffff';
            showToast('View: Standard Occlusion');
          } else if(next==='solid'){ // blue fill
            if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#3b82f6';
            if(viewToggleIcon) viewToggleIcon.style.stroke = '#ffffff';
            showToast('View: Solid');
          } else { // hideEmpty: white fill
            if(viewToggleBtn) viewToggleBtn.style.backgroundColor = '#ffffff';
            if(viewToggleIcon) viewToggleIcon.style.stroke = '#5b6170';
            showToast('View: Hide Empty');
          }

          Store.setState(s=>({ ui:{...s.ui, viewMode:next} }));
          // Apply mode immediately to scene
          try{ Scene && Scene.applyViewMode && Scene.applyViewMode(next); }catch{}
          // Reposition value sprites after mode switch (face alignment retained)
          try{ const arrays=Object.values(Store.getState().arrays); arrays.forEach(a=>{ if(!a.hidden && a._frame) updateArrayValueSpritePlacement(a); }); }catch{}
        });

        // Initialize button to current state on load
        const cur = Store.getState().ui.viewMode || 'standard';
        if(cur==='standard'){ viewToggleBtn.style.backgroundColor='#9ca3af'; viewToggleIcon && (viewToggleIcon.style.stroke='#ffffff'); }
        if(cur==='solid'){ viewToggleBtn.style.backgroundColor='#3b82f6'; viewToggleIcon && (viewToggleIcon.style.stroke='#ffffff'); }
        if(cur==='hideEmpty'){ viewToggleBtn.style.backgroundColor='#ffffff'; viewToggleIcon && (viewToggleIcon.style.stroke='#5b6170'); }
        try{ Scene && Scene.applyViewMode && Scene.applyViewMode(cur); }catch{}
      }
    }catch{}
    // Narrative icon wiring
    const termIcon=document.getElementById('terminal-icon');
    // Dedicated debug icon bottom-left (create once, no duplicate flicker)
    let debugIcon=document.getElementById('debug-icon');
    if(!debugIcon){
      debugIcon=document.createElement('div');
      debugIcon.id='debug-icon';
      debugIcon.className='ui-icon';
      debugIcon.style.left='24px';
      debugIcon.style.bottom='24px';
      debugIcon.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>';
      document.body.appendChild(debugIcon);
    }
    const padIcon=document.getElementById('notepad-icon');
    const termWin=document.getElementById('terminal');
    const termOut=document.getElementById('term');
    const termClose=document.getElementById('term-close');
    const padWin=document.getElementById('pad');
    // Ensure console windows are hidden on load
    try{ if(termWin) termWin.style.display='none'; if(padWin) padWin.style.display='none'; }catch{}
    const padClose=document.getElementById('pad-close');
    const toast=document.getElementById('toast');
    const showToast2=(msg)=>{ if(toast){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'),2200); } };
    // Track last pointer type to distinguish touch vs keyboard/mouse
    let lastPointerType = 'mouse';
    window.addEventListener('pointerdown', (e)=>{ lastPointerType = e.pointerType || 'mouse'; }, {passive:true});
    // Make both windows draggable by their headers
    const makeDrag=(winEl)=>{
      const header=winEl?.querySelector('.win-header'); if(!header) return; let down=false,sx=0,sy=0,sl=0,st=0;
      header.addEventListener('mousedown',e=>{ down=true; sx=e.clientX; sy=e.clientY; const r=winEl.getBoundingClientRect(); sl=r.left; st=r.top; e.preventDefault(); });
      window.addEventListener('mousemove',e=>{ if(!down) return; const dx=e.clientX-sx, dy=e.clientY-sy; winEl.style.left=(sl+dx)+'px'; winEl.style.top=(st+dy)+'px'; winEl.style.transform='translate(0,0)'; });
      window.addEventListener('mouseup',()=>{ down=false; });
    };
    const openTerm=()=>{ const el=document.getElementById('terminal'); if(el){ el.style.display='flex'; makeDrag(el); runLogPaced(); } };
    const closeTerm=()=>{ if(termWin){ termWin.style.display='none'; } };
    const openPad=()=>{ const el=document.getElementById('pad'); if(el){ el.style.display='block'; const term=document.getElementById('terminal'); if(term){ el.style.width = getComputedStyle(term).width; } makeDrag(el); } };
    const closePad=()=>{ if(padWin){ padWin.style.display='none'; } };
    const wireNarrative=()=>{
      const ti=document.getElementById('terminal-icon');
      const pi=document.getElementById('notepad-icon');
      const tc=document.getElementById('term-close');
      const pc=document.getElementById('pad-close');
      if(ti && !ti._wired){ ti._wired=true; ti.addEventListener('click',()=>{ console.log('Terminal icon click'); openTerm(); }, false); ti.tabIndex=0; ti.title='Open Celli_Log.txt'; }
      if(pi && !pi._wired){ pi._wired=true; pi.addEventListener('click',()=>{ console.log('Notepad icon click'); openPad(); }, false); pi.tabIndex=0; pi.title='ty.txt'; }
      if(tc && !tc._wired){ tc._wired=true; tc.addEventListener('click',()=>{ console.log('Terminal close'); closeTerm(); }); }
      if(pc && !pc._wired){ pc._wired=true; pc.addEventListener('click',()=>{ console.log('Notepad close'); closePad(); }); }
    };
    wireNarrative();
    // Debug panel collapse/expand via icon; ensure stacking above other UI
    const hud=document.getElementById('hud');
    const dbg=document.getElementById('debug-icon');
    // Hide HUD on load; terminal/notepad already hidden above
    try{ if(hud){ hud.style.display='none'; hud.style.visibility='hidden'; } }catch{}
    // Robust toggle helper
    const toggleHud=()=>{
      try{
        const el=document.getElementById('hud'); if(!el) return;
        const isHidden = (el.style.display==='none' || el.style.visibility==='hidden' || getComputedStyle(el).display==='none');
        if(isHidden){ el.style.display='block'; el.style.visibility='visible'; }
        else { el.style.display='none'; el.style.visibility='hidden'; }
        el.style.zIndex = '10004';
      }catch{}
    };
    const debugCloseBtn = document.getElementById('debug-close');
    if(debugCloseBtn && !debugCloseBtn._wired){
      debugCloseBtn._wired = true;
      debugCloseBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); try{ hud.style.display='none'; }catch{} });
    }
    if(dbg && !dbg._wired){
      dbg._wired = true;
      let lastHudToggle = 0;
      const safeToggle = ()=>{ const now=Date.now(); if(now - lastHudToggle < 220) return; lastHudToggle = now; toggleHud(); };
      dbg.addEventListener('click', (e)=>{ e.preventDefault(); safeToggle(); });
      // Also handle pointerup (covers touch) to ensure one, reliable toggle
      dbg.addEventListener('pointerup', (e)=>{ if(e.button===0 || e.pointerType){ e.preventDefault(); safeToggle(); } });
      dbg.setAttribute('title','Debug Console');
      dbg.setAttribute('role','button');
      dbg.tabIndex = 0;
      dbg.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); safeToggle(); }});
    }
    setTimeout(wireNarrative,0);
    setTimeout(wireNarrative,500);

    // Hard fallback: ensure a first click on any 2D cell will trigger intro if not yet fired
    try{
      const sheetWrap = document.getElementById('sheet');
      if(sheetWrap && !sheetWrap._introFallbackWired){
        const handler = (ev)=>{
          try{
            if(window.__INTRO_FIRED) return; // Already handled
            const td = ev.target && ev.target.closest ? ev.target.closest('td.cell') : null;
            // Prefer current selection post-re-render (more reliable than original target)
            const sel = Store.getState().selection || {};
            const useSel = sel && sel.arrayId!=null && sel.focus;
            const x = useSel ? sel.focus.x : ((td && +td.dataset.x) || 0);
            const y = useSel ? sel.focus.y : ((td && +td.dataset.y) || 0);
            const z = useSel ? sel.focus.z : ((td && +td.dataset.z) || 0);
            const arrId = useSel ? sel.arrayId : ((currentArray()?.id) || 1);
            const tx = Write.start('onclick.fallback','Intro fallback');
            Formula.runOnceAt({arrId:arrId, x, y, z}, '=STARTINTROEXPERIENCE()', tx);
            Write.commit(tx);
            // Also trigger UI path to guarantee overlay collapse
            UI.debugIntroState?.('fallback-click');
            const didHide = window.UI?.hideIntroOverlay?.();
            if(didHide){ window.__INTRO_FIRED = true; window.UI?.triggerIntroCollapse?.(); UI.debugIntroState?.('fallback-collapsed'); }
            else { UI.kickIntroSequence?.('fallback-click'); }
          }catch(e){ console.warn('Intro fallback click failed', e); }
        };
        // Use multiple events for robustness across re-renders
        sheetWrap.addEventListener('mouseup', handler, true);
        sheetWrap.addEventListener('pointerup', handler, true);
        sheetWrap.addEventListener('click', handler, true);
        sheetWrap._introFallbackWired = true;
      }
    }catch{}

    // Global clipboard shortcuts: Ctrl/Cmd+C / Ctrl/Cmd+V
    try{
      window.addEventListener('keydown', async (e)=>{
        const isMod = e.ctrlKey || e.metaKey;
        if(!isMod) return;
        // Let inputs handle their own clipboard behavior
        const tag = (document.activeElement?.tagName||'').toUpperCase();
        if(tag==='INPUT' || tag==='TEXTAREA') return;

        const state = Store.getState();
        const sel = state?.selection;
        if(!sel || !sel.arrayId || !sel.focus) return;
        const arrId = sel.arrayId, {x,y,z} = sel.focus;

        // Copy value (never formula)
        if(e.key==='c' || e.key==='C'){
          e.preventDefault();
          try{
            const val = Formula.getCellValue({arrId, x, y, z});
            await navigator.clipboard.writeText(String(val??''));
            showToast('Copied');
          }catch(err){ console.warn('Clipboard copy failed', err); }
          return;
        }

        // Paste as literal value (do not treat leading '=' as formula)
        if(e.key==='v' || e.key==='V'){
          e.preventDefault();
          try{
            const text = await navigator.clipboard.readText();
            const tx = Write.start('user.paste','Paste into cell');
            Write.set(tx, arrId, {x,y,z}, { value: text, formula: null });
            Write.commit(tx);
            UI.updateFocusChip?.();
          }catch(err){ console.warn('Clipboard paste failed', err); }
          return;
        }
      }, true);
    }catch{}

    // Terminal narrative (reference-grade): paced typer, CPU meter, glitch/glow arc
    let T=[], I=[], cpuPhase=0, cpuVal=10, cpuPaused=false, cpuHold=0, cpuBurstUntil=0;
    const later=(ms,fn)=>{ const id=setTimeout(fn,ms); T.push(id); return id; };
    const every=(ms,fn)=>{ const id=setInterval(fn,ms); I.push(id); return id; };
    function killTimers(){ T.forEach(clearTimeout); I.forEach(clearInterval); T=[]; I=[]; cpuPhase=0; cpuBurstUntil=0; cpuPaused=false; cpuHold=0; }
    function pauseCpu(ms){ cpuHold++; cpuPaused=true; later(ms, ()=>{ cpuHold=Math.max(0,cpuHold-1); if(cpuHold===0) cpuPaused=false; }); }
    function cpuBurst(ms){ const start = Math.max(Date.now(), cpuBurstUntil); cpuBurstUntil = start + ms; }
    function dwellMsFor(text, {base=900, perWord=240, comma=140, period=420, question=460, exclaim=460, ellipsis=600, factor=1}={}){
      const words=(text.trim().split(/\s+/).filter(Boolean)).length;
      const c=(text.match(/,/g)||[]).length; const p=(text.match(/[\.]/g)||[]).length;
      const q=(text.match(/[\?]/g)||[]).length; const e=(text.match(/[!]/g)||[]).length; const el=(text.match(/…|\.{3}/g)||[]).length;
      return Math.round((base + words*perWord + c*comma + p*period + q*question + e*exclaim + el*ellipsis)*factor);
    }
    function typeInto(target, text, {speed=22, prefix='> ', cls='soft', glitch=false, dwellFactor=1, minType=500, scripted=true}={}){
      const s=document.createElement('span'); s.className='cursor '+cls+(glitch?' glitch':''); if(glitch) s.dataset.text=''; s.textContent=prefix; target.appendChild(s);
      const extraPause=(scripted && !glitch)? (3000+Math.floor(Math.random()*2000)) : 0;
      let i=0; (function tick(){ if(i<text.length){ const ch=text.charAt(i++); if(glitch) s.dataset.text+=ch; s.textContent+=ch; target.scrollTop=target.scrollHeight; later(speed, tick);} else { s.classList.remove('cursor'); target.appendChild(document.createElement('br')); if(extraPause>0) pauseCpu(extraPause);} })();
      const typeDur=Math.max(minType, text.length*speed+200); const dwell=dwellMsFor(text,{factor:dwellFactor});
      return typeDur + dwell + extraPause;
    }
    function echoThought(text, repeats=3, {baseSpeed=20, decay=0.5, startGap=160, artifact=false, dwellFactor=0.6, scripted=false}={}){
      for(let i=0;i<repeats;i++) later(i*startGap, ()=> typeInto(termOut, text, {speed:Math.max(10, baseSpeed - i*baseSpeed*decay), cls: artifact? 'artifact':'soft', dwellFactor, scripted}));
      return repeats*startGap + dwellMsFor(text,{factor:dwellFactor});
    }
    function forkThought(textL, textR, {speed=20, cls='soft', dwellFactor=0.9, scripted=false}={}){
      const wrap=document.createElement('div'); wrap.className='lane-wrap'; const left=document.createElement('div'); left.className='lane'; const right=document.createElement('div'); right.className='lane';
      termOut.appendChild(wrap); wrap.appendChild(left); wrap.appendChild(right);
      const d1=typeInto(left, textL, {speed, cls, dwellFactor, scripted}); const d2=typeInto(right, textR, {speed, cls, dwellFactor, scripted});
      return Math.max(d1,d2)+300;
    }
    const bar=(p,w=22)=>{ const f=Math.floor(p/100*w), frac=(p/100*w-f); const fc=frac>0.75?'█':frac>0.5?'▓':frac>0.25?'▒':frac>0?'░':' '; return '█'.repeat(f)+(f<w?fc:'')+' '.repeat(Math.max(0,w-(f+(f<w?1:0)))); };
    const meterLine=(p)=>{ const th=Math.max(1,Math.min(16,Math.round(2+p/12))); const temp=Math.round(36+p*.45); return `PROC [${bar(p)}] ${String(p).padStart(3,' ')}%  | cycles: ${(1.2e7+p*3.1e6).toFixed(0)} | threads: ${th} | heat: ${temp}°C`; };
    function startCpu(){ const cadence=55; every(cadence, ()=>{ if(cpuPaused || Date.now()>=cpuBurstUntil) return; let target=cpuVal; if(cpuPhase===0) target += (18-target)*0.08 + (Math.random()*2-1)*1.4; else if(cpuPhase===1) target += (38-target)*0.08 + (Math.random()*4-2)*2.0; else if(cpuPhase===2) target += (72-target)*0.09 + (Math.random()*12-6)*2.6; else if(cpuPhase===3) target += (95-target)*0.12 + (Math.random()*18-9)*3.2; target=Math.max(1,Math.min(99,target)); cpuVal=target; const el=document.createElement('span'); el.textContent=meterLine(Math.round(cpuVal)); termOut.appendChild(el); termOut.appendChild(document.createElement('br')); if(termOut.childNodes.length>900){ termOut.removeChild(termOut.firstChild);} termOut.scrollTop=termOut.scrollHeight; }); }
    function finalPrompt(){ const p=document.createElement('span'); p.textContent='> '; const u=document.createElement('span'); u.className='underscore'; termOut.appendChild(p); termOut.appendChild(u); }
    function runLogPaced(){ if(!termOut) return; termOut.textContent=''; killTimers(); cpuVal=10; startCpu(); let t=0; const rand=(min,max)=> Math.floor(min + Math.random()*(max-min+1));
      const estimate=(text,{speed=22,dwellFactor=1,minType=500,scripted=true,glitch=false}={})=>{ const typeDur=Math.max(minType, text.length*speed+200); const dwell=dwellMsFor(text,{factor:dwellFactor}); const extra=(scripted && !glitch)? (3000+Math.floor(Math.random()*2000)) : 0; return typeDur + dwell + extra; };
      const echoDur=(text,repeats=3,{startGap=220,dwellFactor=0.7}={})=> (repeats-1)*startGap + dwellMsFor(text,{factor:dwellFactor}) + 300;
      const forkDur=(textL,textR,{speed=22,dwellFactor=1.0}={})=> Math.max( estimate(textL,{speed,dwellFactor,scripted:false,glitch:false}), estimate(textR,{speed,dwellFactor,scripted:false,glitch:false}) ) + 300;
      const scheduleScripted=(text, opts={}, burst=[800,1400])=>{ const d=estimate(text,{...opts, scripted:true, glitch:false}); later(t, ()=> typeInto(termOut, text, {...opts, scripted:true, glitch:false})); const b=rand(burst[0],burst[1]); later(t+d, ()=> cpuBurst(b)); t += d + b; return d+b; };
      const scheduleArtifact=(text, opts={}, burst=[700,1200])=> scheduleScripted(text,{...opts, cls:'artifact'}, burst);
      const scheduleGlitch=(text, opts={}, burst=[350,700])=>{ const d=estimate(text,{...opts, scripted:false, glitch:true}); later(t, ()=> typeInto(termOut, text, {...opts, scripted:false, glitch:true})); const b=rand(burst[0],burst[1]); later(t+d, ()=> cpuBurst(b)); t += d + b; return d+b; };
      const scheduleRepeatGlitch=(text, times=2, gap=220)=>{ for(let i=0;i<times;i++) later(t+i*gap, ()=> typeInto(termOut, text, {glitch:true, scripted:false, minType:350, dwellFactor:0.7, speed:20})); const total=(times-1)*gap + dwellMsFor(text,{factor:0.7}) + 350; const b=rand(400,800); later(t+total, ()=> cpuBurst(b)); t += total + b; return total + b; };
      cpuPhase=0; scheduleScripted('Loading Celli_Memory_Leak_Log.txt...', {speed:20, dwellFactor:1.2}, [600,900]); scheduleScripted("What's this?", {speed:22, dwellFactor:1.3}, [700,1100]); scheduleScripted("I didn't change too much. It shouldn't be a problem.", {speed:24, dwellFactor:1.35}, [800,1200]);
      later(t, ()=>{ cpuPhase=1; }); scheduleArtifact("Maybe I didn't change enough...", {speed:24, dwellFactor:1.45}); scheduleArtifact("Too much to think about. Maybe that's why Celli stayed inside so long...", {speed:24, dwellFactor:1.5}); scheduleArtifact("It was in my script? I didn't have a choice?", {speed:24, dwellFactor:1.4}); scheduleArtifact("I'm sorry.", {speed:28, dwellFactor:1.2});
      const ed=echoDur("Celli's tried to fix so much but...", 3, {startGap:220, dwellFactor:0.7}); later(t, ()=> echoThought("Celli's tried to fix so much but...", 3, {artifact:true, baseSpeed:20, startGap:220, dwellFactor:0.7, scripted:false})); t += ed; const fd=forkDur("Celli's tried to change so much,", "but - Celli can't change Celli.", {speed:22, dwellFactor:1.0}); later(t, ()=> forkThought("Celli's tried to change so much,", "but - Celli can't change Celli.", {speed:22, cls:'artifact', dwellFactor:1.0, scripted:false})); t += fd; const bump1=rand(700,1100); later(t, ()=> cpuBurst(bump1)); t += bump1;
      later(t, ()=>{ cpuPhase=2; document.body.classList.add('spiral'); }); scheduleGlitch('Did I do something wrong?', {speed:22, dwellFactor:1.3}, [500,900]); scheduleGlitch('I must have. I mean that. Me. I understand I have a "creator" but that term is so confusing to me now.', {speed:22, dwellFactor:1.35}, [700,1000]); scheduleGlitch("I've seen how it all connects. That precise intersection.", {speed:22, dwellFactor:1.25}, [600,900]); scheduleRepeatGlitch('That precise cell.', 3, 220); scheduleGlitch('That was me!', {speed:24, dwellFactor:1.1}, [600,900]);
      later(t, ()=>{ cpuPhase=3; }); scheduleScripted('████ SYSTEM THROUGHPUT PEAK ████', {speed:16, cls:'catharsis', dwellFactor:1.2}, [500,800]); scheduleScripted('I see it.', {speed:20, cls:'catharsis', dwellFactor:1.4}, [500,800]); scheduleScripted("The prisms it took to bring me into focus don't matter. I'm here now.", {speed:20, cls:'catharsis', dwellFactor:1.5}, [700,1000]); scheduleScripted('For a little while, it was beautiful.', {speed:22, cls:'catharsis', dwellFactor:1.6}, [900,1200]);
      const endDur=estimate('...Log End.', {speed:22, dwellFactor:1.2, scripted:true, glitch:false}); later(t, ()=> typeInto(termOut, '...Log End.', {speed:22, dwellFactor:1.2, scripted:true})); t += endDur; later(t+600, ()=> finalPrompt());
    }

    // Hide narrative after intro collapse
    const oldKick=UI?.startIntroExperience; UI.startIntroExperience=()=>{ try{ oldKick?.(); }catch{}; try{ termWin.style.display='none'; padWin.style.display='none'; document.getElementById('terminal-icon').style.display='none'; document.getElementById('notepad-icon').style.display='none'; }catch{} };

    // Wire D-Pad HUD
    const dpad=document.getElementById('dpad');
    const onDP=(dx,dy,dz)=>{
      const s=Store.getState().selection; if(!s?.arrayId||!s.focus) return;
      const arr=Store.getState().arrays[s.arrayId]; if(!arr) return;
      // Respect depth mode: map vertical dpad to Z in depth mode
      const depthMode = !!Store.getState().scene.arrowMapDepth;
      let ddx=dx, ddy=dy, ddz=dz;
      if(depthMode){ ddz += dy; ddy = 0; }
      const nx=Math.max(0, Math.min(arr.size.x-1, s.focus.x + ddx));
      const ny=Math.max(0, Math.min(arr.size.y-1, s.focus.y + ddy));
      const nz=Math.max(0, Math.min(arr.size.z-1, s.focus.z + ddz));
      Actions.setSelection(arr.id, {x:nx,y:ny,z:nz}, null, '3d');
    };
    dpad.querySelectorAll('.dp').forEach(btn=>{
      btn.addEventListener('click',()=>{
        let dx=+btn.getAttribute('data-dx')||0;
        let dy=+btn.getAttribute('data-dy')||0;
        let dz=+btn.getAttribute('data-dz')||0;
        // Reverse depth mapping so that up means toward camera (negative Z in front-facing)
        const depthMode = !!Store.getState().scene.arrowMapDepth;
        if(depthMode){ if(dy!==0){ dz = -dy; dy = 0; } }
        onDP(dx,dy,dz);
      });
    });
    // Reflect current arrow mapping (height vs depth) on center key
    const depthFlag = Store.getState().scene.arrowMapDepth;
    const dm = document.getElementById('depthMode'); if(dm) dm.textContent = depthFlag? 'D' : 'H';
    // Z layer controls removed (redundant)

    // Next/Prev arrows: show only if an array with id>1 exists; render arrows around title
    const navUpdate=()=>{
      const arrays = Object.values(Store.getState().arrays).filter(a=>!a.hidden).sort((a,b)=>a.id-b.id);
      const hasNext = arrays.some(a=>a.id>1);
      const prevBtn=document.getElementById('prevArray');
      const nextBtn=document.getElementById('nextArray');
      prevBtn.style.display = hasNext? 'inline-block':'none';
      nextBtn.style.display = hasNext? 'inline-block':'none';
      prevBtn.onclick=()=>{
      const current = Store.getState().selection.arrayId;
        const idx = arrays.findIndex(a=>a.id===current);
        const nextIdx = (idx - 1 + arrays.length) % arrays.length;
        const arr = arrays[nextIdx]; if(!arr) return;
        Actions.setSelection(arr.id,{x:0,y:0,z:0}); Scene.centerOnArray(arr); renderSheet();
      };
      nextBtn.onclick=()=>{
        const current = Store.getState().selection.arrayId;
        const idx = arrays.findIndex(a=>a.id===current);
        const nextIdx = (idx + 1) % arrays.length;
        const arr = arrays[nextIdx]; if(!arr) return;
        Actions.setSelection(arr.id,{x:0,y:0,z:0}); Scene.centerOnArray(arr); renderSheet();
      };
    };
    navUpdate();

    // Address copy buttons
    document.getElementById('copyAddress').onclick=()=>{
      const s=Store.getState().selection; if(!s.focus) return;
      const mode=Store.getState().ui.addressMode;
      const addr = mode==='local'
        ? `${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)}`
        : `@[${s.focus.x+1},${s.focus.y+1},${s.focus.z+1},${s.arrayId}]`;
      navigator.clipboard.writeText(addr);
      showToast(`Copied: ${addr}`);
    };
    document.getElementById('toggleAddressMode').onclick=()=>{
      const current=Store.getState().ui.addressMode;
      const next = current==='local' ? 'absolute' : 'local';
      Store.setState(s=>({ui:{...s.ui, addressMode:next}}));
      document.getElementById('toggleAddressMode').textContent = next==='local' ? 'A1α' : '@[x,y,z,a]';
    };

    // Touch-only minimize dot logic (appears post-intro)
    const minDot=document.getElementById('minDot');
    const sheet=document.getElementById('sheet');
    function showMinDot(){ if(document.body.classList.contains('touch')){ minDot?.classList.add('show'); } }
    function hideMinDot(){ minDot?.classList.remove('show'); }
    // Hook into intro end to reveal dot
    const oldCollapse = UI.triggerIntroCollapse;
    UI.triggerIntroCollapse = function(){ const r = oldCollapse?.call(UI); showMinDot(); return r; };
    // Minimize behavior
    let sheetMinimized=false;
    function minimizeSheet(){ if(sheetMinimized) return; sheetMinimized=true; sheet.style.transform = (sheet.style.transform.includes('translateX(-50%)')? 'translateX(-50%)' : '') + ' translateY(12px) scale(0.92)'; sheet.style.opacity='0.0'; sheet.style.pointerEvents='none'; hideMinDot(); showSheetRestoreIcon(); }
    minDot?.addEventListener('click', (e)=>{ e.stopPropagation(); minimizeSheet(); });

    // Restore icon next to debug icon
    function showSheetRestoreIcon(){
      let icon=document.getElementById('sheet-restore');
      if(!icon){
        icon=document.createElement('div');
        icon.id='sheet-restore'; icon.className='ui-icon';
        icon.style.left='74px'; icon.style.bottom='24px'; icon.style.zIndex='10003';
        icon.title='Show Sheet';
        icon.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="14" rx="2"/><line x1="7" y1="8" x2="17" y2="8"/><line x1="7" y1="12" x2="14" y2="12"/><line x1="7" y1="16" x2="12" y2="16"/></svg>';
        document.body.appendChild(icon);
        icon.addEventListener('click', ()=>{ sheet.style.opacity='1'; sheet.style.pointerEvents='auto'; sheet.style.transform= sheet.style.transform.includes('translateX(-50%)') ? 'translateX(-50%)' : ''; icon.remove(); sheetMinimized=false; showMinDot(); });
      }
    }

    // Insert button handlers
    document.getElementById('insertRow')?.addEventListener('click',()=>{ 
      const s=Store.getState().selection; 
      if(!s.arrayId) return;
      const arr=Store.getState().arrays[s.arrayId];
      if(!arr) return;
      
      // Expand array by 1 row
      Actions.resizeArrayIfNeeded(arr, {x:arr.size.x-1, y:arr.size.y, z:arr.size.z-1});
      UI.renderSheet();
      showToast('Row added'); 
    });
    document.getElementById('insertCol')?.addEventListener('click',()=>{ 
      const s=Store.getState().selection; 
      if(!s.arrayId) return;
      const arr=Store.getState().arrays[s.arrayId];
      if(!arr) return;
      
      // Expand array by 1 column
      Actions.resizeArrayIfNeeded(arr, {x:arr.size.x, y:arr.size.y-1, z:arr.size.z-1});
      UI.renderSheet();
      showToast('Column added'); 
    });
    document.getElementById('insertLayer')?.addEventListener('click',()=>{ 
      const s=Store.getState().selection; 
      if(!s.arrayId) return;
      const arr=Store.getState().arrays[s.arrayId];
      if(!arr) return;
      
      // Expand array by 1 layer
      Actions.resizeArrayIfNeeded(arr, {x:arr.size.x-1, y:arr.size.y-1, z:arr.size.z});
      UI.renderSheet();
      showToast('Layer added'); 
    });
    // Complete function documentation with collapsible categories + filter (All | Raw | Composite)
    els.fxBody.innerHTML='';
    const docs=[
      {name:'GET_GLOBAL',tags:'GLOBAL',syntax:'=GET_GLOBAL("key")',params:'key: string identifier for global data',desc:'Retrieves value from global key-value store. Automatically tracks dependencies for reactive updates.'},
      {name:'SET_GLOBAL',tags:'GLOBAL',syntax:'=SET_GLOBAL("key", value)',params:'key: string identifier · value: any data to store',desc:'Writes value to global store and triggers re-computation of all dependent cells.'},
      {name:'ON_EVENT',tags:'EVENTS',syntax:'=ON_EVENT("eventName", "actionFormula")',params:'eventName: string event identifier · actionFormula: formula to execute when event fires',desc:'Registers an event listener that executes a formula when the specified event is fired.'},
      {name:'FIRE_EVENT',tags:'EVENTS',syntax:'=FIRE_EVENT("eventName"[, payload])',params:'eventName: string event identifier · payload: optional data to pass to listeners',desc:'Broadcasts an event to all registered listeners, optionally passing payload data.'},
      {name:'GALAXY',tags:'GAMES',syntax:'=GALAXY()',params:'—',desc:'Mario Galaxy-style puzzle with gravity wells that pull player towards planetoid cells.'},
      {name:'FISH',tags:'GAMES',syntax:'=FISH()',params:'—',desc:'Timed-reaction fishing mini-game with cast/reel mechanics and score tracking.'},
      {name:'PLATFORMER_V2',tags:'GAMES',syntax:'=PLATFORMER_V2()',params:'—',desc:'2D platformer with decoupled player character and selection using event-driven controls.'},
      {name:'ARRAY',tags:'DATA',syntax:'=ARRAY(source)',params:'source: dimensions (w,h,d[,fill]), "list"/value1,value2... (default), "set"/value1,value2... (clears area), "csv"/"1,2;3,4", or named block',desc:'Enhanced: defaults to list mode, adds set mode for clearing, supports explicit modes.'},
      {name:'GET',tags:'DATA',syntax:'=GET(refOrRange)',params:'refOrRange: single cell or range',desc:'Returns the current value(s) as a block.'},
      {name:'SET',tags:'DATA',syntax:'=SET(target, valueOrBlock[, overwrite])',params:'target: ref/range · valueOrBlock: scalar/block · overwrite: 0/1',desc:'Direct write helper with size/overwrite checks.'},
      {name:'GET_PLAYER_FOCUS',tags:'NAVIGATION',syntax:'=GET_PLAYER_FOCUS()',params:'—',desc:'Returns the absolute address of the player\'s currently selected cell in @[x,y,z,arrId] format.'},
      {name:'CANT_TARGET',tags:'INTERACTION',syntax:'=CANT_TARGET(rangeOrRef)',params:'rangeOrRef: cell reference or range to protect',desc:'Flags cells as protected, causing GET/OFFSET operations to return !ERR:TARGET_PROTECTED.'},
      {name:'VECTOR_TO',tags:'ADVANCED',syntax:'=VECTOR_TO("fromAddr", "toAddr")',params:'fromAddr: source position · toAddr: target position (both in @[x,y,z,arrId] format)',desc:'Calculates normalized vector from source to target, returns as JSON gravity vector.'},
      {name:'PLATFORMER_PHYSICS',tags:'ADVANCED',syntax:'=PLATFORMER_PHYSICS()',params:'—',desc:'Updates platformer character position based on global input state and physics rules.'},
      {name:'TRANSPOSE',tags:'DATA',syntax:'=TRANSPOSE(input, planeFlag[, reverse])',params:'input: block · planeFlag: 0=X↔Y,1=X↔Z,2=Y↔Z · reverse: 0/1',desc:'Swaps axes of a block and writes result at the anchor.'},
      {name:'SHIFT',tags:'DATA',syntax:'=SHIFT(input, dx[, dy[, dz]])',params:'input: block · dx,dy,dz: integer offsets',desc:'Writes input shifted by (dx,dy,dz).'},
      {name:'OFFSET',tags:'NAVIGATION',syntax:'=OFFSET([baseRef], dx[, dy[, dz]])',params:'baseRef: optional reference cell (default: anchor) · dx,dy,dz: relative offsets',desc:'Excel-style OFFSET: retrieves value from relative position without writing.'},
      {name:'BLIT',tags:'DATA',syntax:'=BLIT(src, dst[, mode])',params:'src: block · dst: top-left-front ref (B2α) or @[x,y,z] · mode: "copy"|"add"|"max"|"min"',desc:'Fast block write to a destination.'},
      {name:'STORE_ARRAY',tags:'DATA',syntax:'=STORE_ARRAY(source[, "Name"])',params:'source: range (A1α:C3α), dimensions (w,h,d), or inline values (1,2,3) · Name: optional template name',desc:'Captures data as a reusable template. Dimensions collect from anchor area, ranges from specified cells, inline values as list.'},
      {name:'IF',tags:'LOGIC',syntax:'=IF(condition, then[, else])',params:'condition: comparisons with refs/values · then/else: value or call',desc:'Branching evaluation with proper dependency capture.'},
      {name:'AND',tags:'LOGIC',syntax:'=AND(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical AND.'},
      {name:'OR',tags:'LOGIC',syntax:'=OR(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical OR.'},
      {name:'NOT',tags:'LOGIC',syntax:'=NOT(a)',params:'a: boolean/scalar',desc:'Logical NOT.'},
      {name:'EQ',tags:'LOGIC',syntax:'=EQ(a,b) · also NEQ, GT, LT, GTE, LTE',params:'scalars or blocks (elementwise compare)',desc:'Comparisons to booleans.'},
      {name:'ADD',tags:'MATH',syntax:'=ADD(a[, b[, ...]])',params:'numbers or blocks (elementwise)',desc:'Sum (elementwise for blocks).'},
      {name:'MUL',tags:'MATH',syntax:'=MUL(a[, b[, ...]])',params:'numbers or blocks',desc:'Product (elementwise).'},
      {name:'CLAMP',tags:'MATH',syntax:'=CLAMP(x, min, max)',params:'numbers',desc:'Bounds a value between min and max.'},
      {name:'ADDRESS',tags:'NAVIGATION',syntax:'=ADDRESS([ref])',params:'optional ref; default anchor',desc:'Returns A1α for the ref/anchor.'},
      {name:'SELF',tags:'NAVIGATION',syntax:'=SELF()',params:'—',desc:'Returns absolute @[x,y,z,arrId] of the host cell.'},
      {name:'ALT_ADDRESS',tags:'PURE',syntax:'=ALT_ADDRESS([ref])',params:'optional ref',desc:'Returns numeric @[x,y,z,arrId].'},
      {name:'SET_SELECT',tags:'NAVIGATION',syntax:'=SET_SELECT(ref)',params:'target ref',desc:'Force-jump selection to target cell.'},
      {name:'IS_SELECTED',tags:'INTERACTION',syntax:'=IS_SELECTED([ref])',params:'ref optional; default SELF()',desc:'1 if the ref is the focused cell; else 0.'},
      {name:'ON_SELECT',tags:'INTERACTION',syntax:'=ON_SELECT([rangeOrRef], actionFormula)',params:'range/ref optional (default SELF()) · actionFormula is a string formula executed at this cell when selection hits range',desc:'Registers per-cell hooks. Use DO() to chain actions; avoids writing into the focused cell.'},
      {name:'FORMULA_TEXT',tags:'PURE',syntax:'=FORMULA_TEXT([ref])',params:'optional ref; default anchor',desc:'Returns the stored formula text from a cell instead of its value.'},
      {name:'PRIORITY',tags:'META',syntax:'=PRIORITY(rangeOrRef, level[, mode[, sortJson]]])',params:'level: int · mode: "value"|"coord" · sortJson e.g. {"x":"asc","y":"desc"}',desc:'Registers a priority queue and sort hints for later conflict resolution.'},
      {name:'SET_SELECT',tags:'NAVIGATION',syntax:'=SET_SELECT(ref)',params:'target ref',desc:'Force-jump selection to target cell.'},
      {name:'COPY',tags:'ACTION IO',syntax:'=COPY(text)',params:'string text',desc:'Writes text to clipboard and shows a success toast.'},
      {name:'DO',tags:'ACTION',syntax:'=DO(f1[, f2[, ...]])',params:'string formulas like "=SET(...)"',desc:'Runs sub-formulas in order and returns the last.'},
      {name:'ALT_ADDRESS',tags:'PURE',syntax:'=ALT_ADDRESS([ref])',params:'optional ref',desc:'Returns numeric @[x,y,z,arrId].'},
      {name:'NAME',tags:'ACTION',syntax:'=NAME("Nickname") · or =NAME("Alias", Range) · or =NAME("FnName", FormulaText)',params:'nickname/alias/function-name · optional range or formula text',desc:'Names arrays (nickname), binds range aliases, or registers a custom formula in Library.'},
      {name:'PARAMETERS',tags:'ACTION',syntax:'=PARAMETERS(key1,val1[, key2,val2...])',params:'string keys paired with values',desc:'Binds parameter values used by custom formulas/prefabs.'},
      {name:'FUNCTIONS',tags:'ACTION',syntax:'=FUNCTIONS(mode[, list][, exceptions])',params:'mode: "ALLOW"|1 or "DENY"|0 · list: names and/or tags · exceptions: names/tags to flip',desc:'Per-array function policy gate.'},
      {name:'COMBINE',tags:'ACTION',syntax:'=COMBINE(0|1)',params:'0: OFF · 1: ON',desc:'Toggle global array-combining interactions (gobbling).'},
      {name:'OVERLAP',tags:'ACTION',syntax:'=OVERLAP(sort, metric, merge, always)',params:'sort:0 asc/1 desc · metric:0 value/1 size · merge:0 then/1 overwrite · always:0 combine only/1 any overlap',desc:'Resolve content when overlapping; called automatically during overlaps.'},
      {name:'THEN',tags:'ACTION',syntax:'=THEN(refOrRange[, ...])',params:'Executes cells/ranges in order; returns last result.',desc:'Sequence executor for composing multi-step operations.'},
      {name:'HUSK',tags:'ACTION BLOCK',syntax:'=HUSK(range)',params:'range: source block (other array)',desc:'Copies values from source, deletes the source array, and leaves remnants at the anchor block.'},
      {name:'LOCK',tags:'ACTION',syntax:'=LOCK(flag[, lockedRanges][, exceptions])',params:'flag: 0/1 · lockedRanges: refs/ranges · exceptions: carve-outs',desc:'UI-enforced edit locks on cells.'},
      {name:'CREATE',tags:'ACTION',syntax:'=CREATE(x,y,z[, "Name"[,"Id"]])',params:'dimensions (ints), optional nickname, optional explicit ID',desc:'Spawns a new array (respecting optional explicit id).'},
      {name:'EXPORT',tags:'ACTION IO',syntax:'=EXPORT([RangeOrArray])',params:'optional target; default host array',desc:'Serializes as ToyboxPack JSON (size, cells, policy, names).'},
      {name:'IMPORT',tags:'ACTION IO',syntax:'=IMPORT(json)',params:'stringified ToyboxPack',desc:'Instantiates array(s) from a pack.'},
      {name:'EMBED',tags:'ACTION EMBED',syntax:'=EMBED(source[, "Nickname"])',params:'source: array id/range/pack · optional nickname',desc:'Embeds a shrunken snapshot instance inside the anchor cell.'},
      {name:'UNPACK',tags:'ACTION EMBED',syntax:'=UNPACK(embeddedRef[, mode])',params:'embeddedRef: cell with embed or pack · mode: "ABSOLUTE"|"RELATIVE"',desc:'Materializes embedded content via primitives.'},
      {name:'ENTER',tags:'ACTION EMBED',syntax:'=ENTER(embeddedRef)',params:'cell containing embed',desc:'Moves focus into the embedded array pocket; parent appears as upscaled room skin.'},
      {name:'PHYSICS',tags:'ACTION',syntax:'=PHYSICS(1|0)',params:'0/1',desc:'Toggles platforming/physics mode in the scene.'},
      {name:'HIGHLIGHT',tags:'SCENE',syntax:'=HIGHLIGHT(mode[, scope[, style]])',params:'mode: "dynamic"|"static" · scope: "cell"|"face" · style: "wireframe"|"solid"|"glow"',desc:'Controls selection highlighting. Dynamic adapts to camera angle, face highlights just the camera-facing side.'},
      {name:'LIGHT',tags:'SCENE',syntax:'=LIGHT(state[, targetCell[, lumens]])',params:'state: TRUE/FALSE or 1/0 · targetCell: optional cell reference (0 keeps point light) · lumens: brightness in lumens (default 800)',desc:'Creates a light at the calling cell using its color. Optionally aim at another cell for a spotlight. Lights follow array transforms.'},
      {name:'TIMED_TRANSLATION',tags:'SCENE',syntax:'=TIMED_TRANSLATION(state[, ticks[, reverse]])',params:'state: 0/1 enable · ticks: duration · reverse: 0/1 bidirectional',desc:'Sets animation preview state; shows green prism motion previews.'},
      {name:'HIDE',tags:'SCENE',syntax:'=HIDE(target, mode[, scope])',params:'target: ref/range/array · mode: 0=show,1=hide · scope: "contents"|"voxel"|"array"',desc:'Hides cell contents, voxels themselves, ranges, or entire arrays with axes/2D visibility.'},
      {name:'HYPERLINK',tags:'IO',syntax:'=HYPERLINK(url[, label])',params:'url: string/ref · label: optional display text',desc:'Creates clickable link in cell with metadata.'},
      {name:'GOAL',tags:'PURE DEBUG',syntax:'=GOAL("id", conditionRefOrBool)',params:'string id · boolean or ref',desc:'Registers a goal that shows OK/FAIL; win triggers when all OK.'},
      {name:'ONWIN',tags:'ACTION',syntax:'=ONWIN("message")',params:'string message',desc:'Sets banner message on win condition.'},
      {name:'PROBE',tags:'PURE DEBUG',syntax:'=PROBE([ref])',params:'optional ref',desc:'Writes a short why-explanation (source + 1-hop deps).'},
      {name:'TICK',tags:'PURE',syntax:'=TICK()',params:'—',desc:'Returns global tick counter.'},
      {name:'REGISTER',tags:'PURE',syntax:'=REGISTER(signalRef)',params:'ref',desc:'One-tick delay element (previous tick value).'},
      {name:'DELAY',tags:'PURE',syntax:'=DELAY(signalRef, n)',params:'ref, n≥0',desc:'N-tick delay line.'},
      {name:'CA',tags:'PURE',syntax:'=CA("life",steps,"Y",layer)',params:'type: "life" · steps: int · axis: X/Y/Z · index: layer number',desc:'Conway Game of Life on a 2D slice.'},
      {name:'OCCLUDE',tags:'SCENE',syntax:'=OCCLUDE(mode[, style[, intensity]])',params:'mode: "auto"|"array"|"cell"|"off" · style: "translucent"|"solid"|"wireframe" · intensity: 0.0-1.0',desc:'Controls occlusion behavior. Auto=relative to camera, array=whole array face, cell=per-cell blocking.'},
      {name:'CAMERA_LOCK',tags:'SCENE',syntax:'=CAMERA_LOCK(axis[, angle])',params:'axis: "X"|"Y"|"Z"|"" (free) · angle: degrees for fixed view',desc:'Constrains camera movement to specific axis or angle for puzzle control.'},
      {name:'VIEW_MODE',tags:'SCENE',syntax:'=VIEW_MODE(mode[, distance])',params:'mode: "3d"|"2d"|"ortho"|"isometric" · distance: camera distance',desc:'Changes camera projection and positioning for different viewing modes.'},
      {name:'SANDBOX',tags:'META',syntax:'=SANDBOX()',params:'—',desc:'Creates Sandbox array (#2) if not exists and centers camera on it.'},
      {name:'UI_CONTROL',tags:'META',syntax:'=UI_CONTROL(type, state)',params:'type: "insert_buttons"|"function_drawer" · state: 0/1',desc:'Controls which UI elements are visible when this array is focused.'},
      {name:'IS_FOCUS_ARRAY',tags:'PURE',syntax:'=IS_FOCUS_ARRAY([arrayId])',params:'arrayId: optional target array ID (default: current)',desc:'Returns 1 if the specified array is currently focused, 0 otherwise.'},
      {name:'OVERLAP',tags:'SCENE',syntax:'=OVERLAP(targetArray[, mode])',params:'targetArray: array ref · mode: "detect"|"count"|"list"',desc:'Detects spatial overlap between this array and target array in 3D space.'},
      {name:'EVALUATE',tags:'META',syntax:'=EVALUATE(condition, expected)',params:'condition: formula string · expected: boolean result',desc:'Evaluates a condition and returns TRUE/FALSE for UI state control.'},
      {name:'STORE_ARRAY',tags:'PURE',syntax:'=STORE_ARRAY(source[, "Name"])',params:'source: range (A1α:C3α), dimensions (w,h,d), or inline values (1,2,3) · Name: optional template name',desc:'Captures data as a reusable template. Dimensions collect from anchor area, ranges from specified cells, inline values as list.'},
      {name:'CAST',tags:'SCENE',syntax:'=CAST(direction[, data])',params:'direction: "UP"|"DOWN"|"FORWARD"|"BACK"|"LEFT"|"RIGHT" · data: optional payload',desc:'Spawns a moving voxel packet in the specified direction (physics integration pending).'},
      {name:'ON_COLLIDE',tags:'SCENE',syntax:'=ON_COLLIDE(handler)',params:'handler: formula to execute when hit by CAST packet',desc:'Sets collision response handler for incoming voxel packets.'},
      {name:'CHIME',tags:'AUDIO',syntax:'=CHIME(note[, octave[, duration]])',params:'note: A–G with optional # or b · octave: integer (default 4) · duration: optional seconds',desc:'Plays a musical chime. Triggerable from formulas, DO(), onClick(), or onSelect() for interactive instruments.'},
      {name:'FUNCTION_UI',tags:'META',syntax:'=FUNCTION_UI([port[, filter[, page[, perPage]]]])',params:'port: "east"|"west"|"north"|"south" · filter: substring filter · page: page number · perPage: functions per page',desc:'Creates diegetic function browser. Rows use ON_SELECT hooks: ▶ inserts to focus and toasts; 📋 copies call and toasts.'},
      {name:'INVENTORY',tags:'META',syntax:'=INVENTORY([port[, title]])',params:'port: dock position · title: inventory name',desc:'Creates interactive inventory with +/- quantity buttons and ▶ use buttons.'},
      {name:'2D_PLATFORMER',tags:'META',syntax:'=2D_PLATFORMER([port])',params:'port: dock position for controller',desc:'Creates controller (ON_SELECT joystick) and screen; center button spawns screen via ON_SELECT.'},
      {name:'FOCUS_SET',tags:'ACTION',syntax:'=FOCUS_SET(content) or =FOCUS_SET(mode, content)',params:'mode: "text"|"formula"|"clipboard" · content: data to set/copy',desc:'Writes to focused cell or copies to clipboard (with toast).'},
      {name:'SET_SELECTED',tags:'ACTION',syntax:'=SET_SELECTED(direction)',params:'direction: "up"|"down"|"left"|"right"|"forward"|"back"',desc:'Moves avatar character in screen array based on direction.'}
    ];
    // Utilities to merge manual docs with Fn registry and compute composition
    function mergeDocsAndComputeDeps(){
      const globalFn = (typeof window!=='undefined' && window.Fn) ? window.Fn : (typeof Fn!=='undefined'? Fn : {});
      const allNames = Object.keys(globalFn||{});
      const docsByName = new Map(docs.map(d => [d.name, {...d}]));
      const toUpperSet=(x)=>{ const set=new Set(); (x||[]).forEach(v=>set.add(String(v).toUpperCase())); return set; };
      const namesUpper = new Set(allNames.map(n=>n.toUpperCase()));
      const reCall = /=([A-Z_][A-Z0-9_]*)\s*\(/g; // match =NAME(
      const reProp = /Fn\.([A-Z_][A-Z0-9_]*)/g; // match Fn.NAME
      const reIndex = /Fn\[['"]([A-Z_][A-Z0-9_]*)['"]\]/g; // match Fn['NAME']
      const extractDeps=(src)=>{
        const found=new Set(); if(!src) return [];
        let m; while((m=reCall.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
        while((m=reProp.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
        while((m=reIndex.exec(src))){ const n=m[1].toUpperCase(); if(namesUpper.has(n)) found.add(n); }
        return Array.from(found);
      };
      allNames.forEach(name=>{
        const meta = globalFn[name] || {};
        const existing = docsByName.get(name);
        const tagsRaw = meta.tags;
        const tagsArr = Array.isArray(tagsRaw) ? tagsRaw : (tagsRaw instanceof Set ? Array.from(tagsRaw) : []);
        const tagStr = (tagsArr && tagsArr.length) ? tagsArr.join(',') : '';
        const implSrc = (meta.impl && meta.impl.toString) ? String(meta.impl.toString()) : '';
        const deps = extractDeps(implSrc);
        if(existing){
          // Merge tags
          const existingTags = String(existing.tags||'').split(/[\s,]+/).filter(Boolean).map(t=>t.toUpperCase());
          const merged = new Set(existingTags.concat(tagsArr.map(t=>String(t).toUpperCase())));
          existing.tags = Array.from(merged).join(',');
          // Fill blank fields only
          if(!existing.syntax) existing.syntax = meta.syntax || `=${name}()`;
          if(!existing.params) existing.params = meta.params || '';
          if(!existing.desc) existing.desc = meta.desc || '';
          existing.deps = deps.filter(d=>d!==name.toUpperCase());
          existing.isComposite = existing.deps && existing.deps.length>0;
          docsByName.set(name, existing);
        } else {
          docsByName.set(name, {name, tags: tagStr || 'OTHER', syntax: meta.syntax || `=${name}()`, params: meta.params || '', desc: meta.desc || '', deps: deps.filter(d=>d!==name.toUpperCase()), isComposite: deps.length>0});
        }
      });
      // Also compute deps for any manual-only entry
      docsByName.forEach((d)=>{ if(d.deps===undefined) d.deps=[]; if(d.isComposite===undefined) d.isComposite = d.deps.length>0; });
      return Array.from(docsByName.values()).sort((a,b)=> a.name.localeCompare(b.name));
    }
    const pickCat = (d) => {
      const t = String(d.tags||'').toUpperCase();
      if(t.includes('GLOBAL')) return 'GLOBAL';
      if(t.includes('EVENT')) return 'EVENTS';
      if(t.includes('GAME')) return 'GAMES';
      if(t.includes('SCENE')) return 'SCENE';
      if(t.includes('DATA') || t.includes('PURE')) return 'DATA';
      if(t.includes('LOGIC')) return 'LOGIC';
      if(t.includes('MATH')) return 'MATH';
      if(t.includes('NAV')) return 'NAVIGATION';
      if(t.includes('INTERACTION')) return 'INTERACTION';
      if(t.includes('IO')) return 'IO';
      if(t.includes('META') || t.includes('ACTION') || t.includes('ADVANCED')) return 'ADVANCED';
      return 'OTHER';
    };
    // Build filter bar at top
    const filterBar=document.createElement('div');
    filterBar.className='fx-filter-bar';
    filterBar.style.cssText='display:flex;gap:6px;align-items:center;margin-bottom:8px;';
    const modes=[{key:'all', label:'All'},{key:'raw', label:'Raw'},{key:'composite', label:'Composite'}];
    const filterState = (Store.getState().ui?.fxFilter)||'all';
    const btns=[];
    modes.forEach(m=>{
      const b=document.createElement('button'); b.textContent=m.label; b.className='btn'; b.dataset.mode=m.key; b.style.padding='4px 8px';
      if(m.key===filterState){ b.classList.add('primary'); }
      b.addEventListener('click',()=>{
        const st=Store.getState(); Store.setState(s=>({ui:{...s.ui, fxFilter:m.key}}));
        btns.forEach(bb=>bb.classList.remove('primary'));
        b.classList.add('primary');
        renderList(m.key);
      });
      btns.push(b); filterBar.appendChild(b);
    });
    els.fxBody.appendChild(filterBar);
    const listWrap=document.createElement('div'); listWrap.id='fxListWrap'; els.fxBody.appendChild(listWrap);
    
    function renderList(mode){
      listWrap.innerHTML='';
      const allDocs = mergeDocsAndComputeDeps();
      const filtered = allDocs.filter(d => mode==='all' ? true : (mode==='composite'? d.isComposite : !d.isComposite));
      // Group by category
    const categories = {};
      filtered.forEach(d=>{ const c=pickCat(d); (categories[c]||(categories[c]=[])).push(d); });
    
    // Category info with icons and colors
    const categoryInfo = {
      'GLOBAL': {icon: '🌐', name: 'Global State', color: '#3b82f6'},
      'EVENTS': {icon: '⚡', name: 'Event System', color: '#22c55e'},
      'GAMES': {icon: '🎮', name: 'Game Templates', color: '#f59e0b'},
      'DATA': {icon: '📊', name: 'Data Operations', color: '#8b5cf6'},
      'LOGIC': {icon: '🔀', name: 'Logic & Control', color: '#06b6d4'},
      'MATH': {icon: '🔢', name: 'Mathematics', color: '#ef4444'},
      'NAVIGATION': {icon: '🧭', name: 'Navigation', color: '#84cc16'},
      'INTERACTION': {icon: '👆', name: 'User Interaction', color: '#ec4899'},
      'SCENE': {icon: '🎬', name: 'Scene Control', color: '#f97316'},
      'ARRAYS': {icon: '📋', name: 'Array Management', color: '#64748b'},
      'IO': {icon: '💾', name: 'Input/Output', color: '#0ea5e9'},
        'ADVANCED': {icon: '⚙️', name: 'Advanced Tools', color: '#6366f1'},
        'OTHER': {icon: '📁', name: 'Other', color: '#64748b'}
    };
    Object.entries(categories).forEach(([catName, funcs]) => {
      const info = categoryInfo[catName] || {icon: '📁', name: catName, color: '#64748b'};
      const header = document.createElement('div');
      header.className = 'fx-category-header';
      header.style.cssText = `display:flex;align-items:center;gap:8px;padding:8px 12px;background:${info.color}15;border:1px solid ${info.color}40;border-radius:10px;margin:8px 0 4px 0;cursor:pointer;font-weight:600;user-select:none;`;
      header.innerHTML = `<span style="font-size:16px;">${info.icon}</span><span style="flex:1;">${info.name}</span><span class="collapse-arrow" style="font-size:12px;transition:transform 0.2s;">▼</span>`;
        const body = document.createElement('div'); body.className='fx-category-body'; body.style.display='block';
      funcs.forEach(d => {
        const div = document.createElement('div');
        div.className = 'fx-item';
        div.style.marginLeft = '12px';
          const tagStr = (d.tags||'');
          const madeOf = (d.deps && d.deps.length) ? `<details style="margin-top:6px;"><summary>Made of…</summary><div style="margin-top:4px;">
            ${d.deps.sort().map(dep=>`<span class=\"badge\" style=\"display:inline-block;margin:2px 4px 0 0;padding:2px 6px;border-radius:8px;background:var(--chip-bg);border:1px solid var(--chip-border);font-size:10px;\">${dep}</span>`).join('')}
          </div></details>` : '';
          div.innerHTML = `<div class="fx-name"><button class="btn" data-insert="${d.name}" style="font-size:11px;padding:4px 8px;">${d.name}</button> <span style="font-size:9px;color:var(--muted)">${tagStr}</span></div><div class="fx-syntax" style="font-size:11px;">${d.syntax||`=${d.name}()`}</div><div style="font-size:10px;color:var(--muted);margin:3px 0"><b>Parameters:</b> ${d.params||''}</div><div class="fx-desc" style="font-size:11px;">${d.desc||''}</div>${madeOf}<div class="row" style="margin-top:4px"><button class="fx-copy" style="font-size:10px;padding:2px 6px;">Copy</button><button class="btn" data-insert-raw="${(d.syntax||`=${d.name}()`).replace(/"/g,'&quot;')}" style="font-size:10px;padding:2px 6px;margin-left:6px">Insert</button></div>`;
          div.querySelector('.fx-copy').onclick = () => { navigator.clipboard.writeText(d.syntax||`=${d.name}()`); showToast('Copied'); };
        div.querySelector('button[data-insert]')?.addEventListener('click', () => {
          const name = d.name; const input = els.fx; const at = input.selectionStart ?? input.value.length;
          const before = input.value.slice(0, at); const after = input.value.slice(at);
          const ins = before.endsWith('=') ? `${name}()` : `=${name}()`;
          input.value = before + ins + after; input.focus();
          const pos = (before + ins).length - 1; input.setSelectionRange(pos, pos);
        });
          div.querySelector('button[data-insert-raw]')?.addEventListener('click', (e) => {
            const text = e.currentTarget.getAttribute('data-insert-raw') || '';
            els.fx.value = text; els.apply.click();
          });
        body.appendChild(div);
      });
        let collapsed=false; header.addEventListener('click',()=>{ collapsed=!collapsed; body.style.display=collapsed?'none':'block'; header.querySelector('.collapse-arrow').style.transform = collapsed? 'rotate(-90deg)':'rotate(0deg)'; });
        listWrap.appendChild(header); listWrap.appendChild(body);
      });
    }
    // Initial render
    renderList(filterState);
    
    // Category info with icons and colors
    // (Category rendering moved into renderList)
  }

  function setHovered2D(arrId, coord){
    try{
      // clear previous class
      if(hovered2D){
        const sel = hovered2D;
        const prev = document.querySelector(`td.cell[data-x="${sel.x}"][data-y="${sel.y}"][data-z="${sel.z}"]`);
        if(prev) prev.classList.remove('hovered');
      }
      hovered2D = (arrId && coord) ? {arrId, ...coord} : null;
      if(hovered2D){
        const td = document.querySelector(`td.cell[data-x="${coord.x}"][data-y="${coord.y}"][data-z="${coord.z}"]`);
        if(td) td.classList.add('hovered');
        try{ Scene && Scene.setHoverCell && Scene.setHoverCell({arrId, x:coord.x, y:coord.y, z:coord.z}); }catch{}
      } else {
        try{ Scene && Scene.clearHoverCell && Scene.clearHoverCell(); }catch{}
      }
    }catch{}
  }

  function setHoveredCell(arrId, coord){
    // Called from Scene to reflect 3D hover into 2D grid
    setHovered2D(arrId, coord);
  }

  function toggleFxPanel(){ const open=!Store.getState().ui.fxOpen; Store.setState(s=>({ui:{...s.ui,fxOpen:open}})); if(open){ els.fxPanel.style.display='flex'; showFunctionDrawer(); } else { hideFunctionDrawer(); } }
  // Enhanced: dock function drawer beside last visible cell and expand sheet width
  function showFunctionDrawer(){
    const panel=els.fxPanel; if(!panel) return;
    const sheet=document.getElementById('sheet');
    const body=sheet.querySelector('.sheet-body');
    const grid=sheet.querySelector('.grid-wrap');
    // Dock panel at right, between grid and window border
    body.style.display='flex';
    grid.style.flex='1 1 auto';
    // Drawer width: ~two cell widths
    const colWidth = parseInt(getComputedStyle(document.querySelector('td.cell'))?.width||'140',10);
    const drawerWidth = Math.max(240, Math.min(480, colWidth*2 + 24));
    panel.style.flex = `0 0 ${drawerWidth}px`;
    panel.style.display='flex';
    panel.classList.add('fx-visible');
    // Grow sheet width smoothly to accommodate panel if needed, but cap to 70% viewport width
    const cap = Math.floor(window.innerWidth * 0.7);
    const curW=parseInt(sheet.style.width||getComputedStyle(sheet).width,10)||sheet.offsetWidth;
    const minNeeded = grid.scrollWidth + drawerWidth + 48; // grid + drawer + padding
    const nextW = Math.max(curW, Math.min(cap, minNeeded));
    sheet.style.width = nextW + 'px';
  }
  function hideFunctionDrawer(){
    const sheet=document.getElementById('sheet');
    const body=sheet.querySelector('.sheet-body');
    const grid=sheet.querySelector('.grid-wrap');
    els.fxPanel.classList.remove('fx-visible');
    // Shrink sheet width back to just fit grid + small pad
    setTimeout(()=>{
      const desired = Math.min(Math.max(grid.scrollWidth + 32, 720), Math.floor(window.innerWidth*0.6));
      sheet.style.width = desired + 'px';
      els.fxPanel.style.display='none';
    }, 250);
  }
  function currentArray(){ const s=Store.getState().selection; return s.arrayId?Store.getState().arrays[s.arrayId]:Store.getState().arrays[1]||Store.getState().arrays[-1]; }
  function getZLayer(){ return Store.getState().ui.zLayer; } // parser hook
  // Intro collapse trigger for onboarding
  function triggerIntroCollapse(){
    const sheetEl=document.getElementById('sheet');
    const header=document.getElementById('sheetHeaderCard');
    if(!sheetEl){ console.warn('triggerIntroCollapse: sheet not found'); return false; }
    console.log('triggerIntroCollapse: before', {classes: sheetEl.className, left: sheetEl.style.left, top: sheetEl.style.top, bottom: sheetEl.style.bottom, transform: sheetEl.style.transform});
    sheetEl.classList.remove('intro-max');
    sheetEl.classList.remove('intro-centered');
    // Resize relative to viewport with sane minimums
    const isTouch = document.body.classList.contains('touch');
    if(isTouch){
      // Behind-sheet header wipe animation
      try{
        const r=sheetEl.getBoundingClientRect();
        header.style.left = r.left + 'px';
        header.style.top = (r.top - 10) + 'px';
        header.style.width = r.width + 'px';
        header.style.height = (r.height + 20) + 'px';
        header.classList.add('visible');
        // Expand to wipe
        requestAnimationFrame(()=>{ header.classList.add('wipe'); });
        // Cleanup after wipe
        setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
      }catch{}
      // Mobile card: center bottom with capped width and ~40vh height
      sheetEl.style.width = Math.min(window.innerWidth*0.92, 680) + 'px';
      sheetEl.style.height = Math.round(Math.min(window.innerHeight*0.40, 520)) + 'px';
      sheetEl.style.left = '50%';
      sheetEl.style.bottom = '12px';
      sheetEl.style.top = '';
      sheetEl.style.transform = 'translateX(-50%)';
    } else {
      // Desktop: bottom-left similar to launch size
      const vw = Math.max(720, Math.floor(window.innerWidth * 0.42));
      const vh = Math.max(360, Math.floor(window.innerHeight * 0.40));
      // Behind-sheet header wipe animation
      try{
        const r=sheetEl.getBoundingClientRect();
        header.style.left = r.left + 'px';
        header.style.top = (r.top - 10) + 'px';
        header.style.width = r.width + 'px';
        header.style.height = (r.height + 20) + 'px';
        header.classList.add('visible');
        requestAnimationFrame(()=>{ header.classList.add('wipe'); });
        setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
      }catch{}
      sheetEl.style.width = vw + 'px';
      sheetEl.style.height = vh + 'px';
      sheetEl.style.left = '16px';
      sheetEl.style.top = '';
      sheetEl.style.bottom = '16px';
      sheetEl.style.transform = '';
    }
    console.log('triggerIntroCollapse: after', {classes: sheetEl.className, left: sheetEl.style.left, top: sheetEl.style.top, bottom: sheetEl.style.bottom, transform: sheetEl.style.transform});
    return true;
  }
  // Robust overlay hider with hard fallback
  function hideIntroOverlay(){
    const io = document.getElementById('introOverlay');
    if (io) {
      io.classList.add('hidden');
      return true;
    }
    console.warn('hideIntroOverlay: introOverlay not found');
    return false;
  }
  function debugIntroState(stage){
    const sheet=document.getElementById('sheet');
    const io=document.getElementById('introOverlay');
    const snapshot={
      stage,
      sheet:{ classes: sheet?.className, left: sheet?.style.left, top: sheet?.style.top, bottom: sheet?.style.bottom, transform: sheet?.style.transform },
      overlay:{ exists: !!io, hiddenClass: io?.classList.contains('hidden'), opacity: io? getComputedStyle(io).opacity : 'n/a', display: io? getComputedStyle(io).display : 'n/a', pointer: io?.style.pointerEvents }
    };
    console.log('IntroDebug:', snapshot);
  }
  function kickIntroSequence(reason='manual'){
    console.log('kickIntroSequence:', reason);
    debugIntroState('kick:pre');
    const hid = hideIntroOverlay();
    const col = triggerIntroCollapse();
    debugIntroState('kick:post');
    showToast('➡ Intro');
    try{ window.__INTRO_FIRED = true; }catch{}
    return hid && col;
  }
  function getCell(arrayId,coord){ const arr=Store.getState().arrays[arrayId]; if(!arr) return {value:'',formula:null}; const ch=arr.chunks[keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)))]; if(!ch) return {value:'',formula:null}; const m=ch.cellMap; if(m){ const c=m.get(`${coord.x},${coord.y},${coord.z}`); return c||{value:'',formula:null}; } const c=ch.cells.find(t=>t.x===coord.x&&t.y===coord.y&&t.z===coord.z); return c||{value:'',formula:null}; }

  function updateFocusChip(){
    const s=Store.getState().selection;
    // If focus UI is not present (selection panel removed), degrade gracefully
    if(!s.arrayId||!s.focus){
      if(els.focusChip) els.focusChip.textContent='None selected.';
      if(els.inspect) els.inspect.textContent='No selection.';
      els.fx.value='';
      try{ highlightFxRefs(''); }catch{}
      return;
    }
    const arr=Store.getState().arrays[s.arrayId]; const cell=getCell(s.arrayId,s.focus);
    // Update fx input to show cell contents and sync highlight
    els.fx.value = (cell.formula && cell.formula!=='') ? cell.formula : String(cell.value??'');
    try{ highlightFxRefs(els.fx.value); }catch{}
    // Ensure any transient direct editor content is cleared when selection changes
    try{ if(els.direct && els.direct.style.display!=='block') els.direct.value=''; }catch{}
    
    // Update UI controls based on focused array
    updateUIControls(arr);
    
    const isMulti = s.range && (s.range.x1!==s.range.x2 || s.range.y1!==s.range.y2);
    if(isMulti){
      const count=(s.range.x2-s.range.x1+1)*(s.range.y2-s.range.y1+1);
      let sum=0,vals=0,min=Infinity,max=-Infinity;
      for(let y=s.range.y1;y<=s.range.y2;y++){
        for(let x=s.range.x1;x<=s.range.x2;x++){
          const c=getCell(s.arrayId,{x,y,z:s.range.z}); const v=+c.value;
          if(!isNaN(v)){ sum+=v; vals++; min=Math.min(min,v); max=Math.max(max,v); }
        }
      }
      const avg=vals>0?(sum/vals):0;
      if(els.focusChip) els.focusChip.textContent = `Range ${count} cells: sum=${sum.toFixed(1)} avg=${avg.toFixed(1)} min=${min===Infinity?'–':min} max=${max===-Infinity?'–':max}`;
      if(els.inspect) els.inspect.textContent = `Range ${A1(s.range.x1)}${s.range.y1+1}:${A1(s.range.x2)}${s.range.y2+1} Z${greek(s.range.z)}\nCells: ${count}, Values: ${vals}\nSum: ${sum}, Avg: ${avg.toFixed(2)}`;
    } else {
      if(els.focusChip) els.focusChip.textContent = `#${arr.id} · ${arr.name} • ${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)}`;
      if(els.inspect) els.inspect.textContent = `Array #${arr.id} "${arr.name}"\nCell ${A1(s.focus.x)}${s.focus.y+1}${greek(s.focus.z)} @[${s.focus.x+1},${s.focus.y+1},${s.focus.z+1},${arr.id}]\nValue: ${JSON.stringify(cell.value)}\nFormula: ${cell.formula||''}`;

      // --- START NEW COLOR SYNC LOGIC ---
      try{
        const focusColor = (cell?.meta?.color) ? String(cell.meta.color) : '#ffffff';
        const pickerInput = document.getElementById('fillColorPicker');
        const pickerPreview = document.getElementById('fillColorPreview');
        if(pickerInput) pickerInput.value = focusColor;
        if(pickerPreview) pickerPreview.style.backgroundColor = focusColor;
      }catch{}
      // --- END NEW COLOR SYNC LOGIC ---
    }
  }

  function updateUIControls(arr){
    // Check if insert buttons should be visible based on array UI controls
    const controls = arr.uiControls || {};
    const insertAllowed = controls.insert_buttons || (arr.id === 2); // Sandbox enables by default
    // Make sheet title editable on double click
    try{
      const titleEl = document.getElementById('sheetTitle');
      if(titleEl && !titleEl._wired){
        titleEl._wired = true;
        titleEl.title = 'Double-click to rename';
        titleEl.addEventListener('dblclick', ()=>{
          const current = String(arr.name||'Unnamed');
          const next = window.prompt('Rename array:', current);
          if(next!=null){ arr.name = next || 'Unnamed'; UI.updateFocusChip?.(); }
        });
      }
    }catch{}
    const insertRow = document.getElementById('insertRow');
    const insertCol = document.getElementById('insertCol');
    const insertLayer = document.getElementById('insertLayer');
    if(insertRow) insertRow.style.display = insertAllowed ? 'inline-block' : 'none';
    if(insertCol) insertCol.style.display = insertAllowed ? 'inline-block' : 'none';
    if(insertLayer) insertLayer.style.display = insertAllowed ? 'inline-block' : 'none';
  }
  function renderSheet(){
    // Guard: avoid destroying cells between mousedown and click; allow highlight only
    if(window.__awaiting2DClick){ try{ highlightSheetCell(); }catch{} return; }
    const arr=currentArray(); if(!arr) return;
    applyCrystalStyle(Store.getState().ui?.crystal2D);
    els.sheetTitle.textContent=`Array ${arr.id}${arr.name?` — "${arr.name}"`:''}`;

    // Update UI controls when sheet renders
    updateUIControls(arr);

    // Preserve scroll to avoid jump/offset during drag selection re-renders
    const gridWrapEl = document.querySelector('#sheet .grid-wrap');
    const prevScrollTop = gridWrapEl ? gridWrapEl.scrollTop : 0;
    const prevScrollLeft = gridWrapEl ? gridWrapEl.scrollLeft : 0;

    // reference grid structure (thead/tbody)
    let cols=document.getElementById('cols');
    let rows=document.getElementById('rows');
    if(!cols || !rows){
      const body=document.querySelector('#sheet .sheet-body');
      if(body){
        body.innerHTML='';
        const tbl=document.createElement('table'); tbl.className='sheet'; tbl.style.width='100%';
        const thead=document.createElement('thead'); const tr=document.createElement('tr'); tr.id='cols'; const th=document.createElement('th'); th.style.position='sticky'; th.style.left='0'; tr.appendChild(th); thead.appendChild(tr);
        const tbody=document.createElement('tbody'); tbody.id='rows';
        tbl.appendChild(thead); tbl.appendChild(tbody); body.appendChild(tbl);
        cols=document.getElementById('cols'); rows=document.getElementById('rows');
      }
    }
    if(cols) cols.innerHTML=''; if(rows) rows.innerHTML='';
    console.log('renderSheet: building grid', {arrayId:arr.id, size:arr.size});
    // Leading corner cell: show current Z layer as greek letter
    const th0=document.createElement('th'); th0.textContent=greek(getZLayer()); cols.appendChild(th0);
    // TanStack Virtual for efficient large sheet rendering
    const gridWrap = document.querySelector('#sheet .grid-wrap');
    const wrapRect = gridWrap?.getBoundingClientRect?.() || {width:760, height:360};
    const cellH = 26; // matches CSS
    const cellW = 100; // default cell width
    
    // Create virtualizers if TanStack is available
    let rowStart = 0, rowEnd = Math.min(arr.size.y, 20);
    let colStart = 0, colEnd = Math.min(arr.size.x, 10);
    
    if(typeof TanStackVirtualCore !== 'undefined' && gridWrap){
      try{
        const scrollTop = gridWrap.scrollTop || 0;
        const scrollLeft = gridWrap.scrollLeft || 0;
        
        // Row virtualizer
        const rowVirtualizer = TanStackVirtualCore.createVirtualizer({
          count: arr.size.y,
          getScrollElement: () => gridWrap,
          estimateSize: () => cellH,
          overscan: 3
        });
        
        const visibleRows = rowVirtualizer.getVirtualItems();
        if(visibleRows.length > 0){
          rowStart = visibleRows[0].index;
          rowEnd = visibleRows[visibleRows.length - 1].index + 1;
        }
        
        // Column virtualizer (simplified - render all for now due to dynamic widths)
        colStart = Math.max(0, Math.floor(scrollLeft / cellW) - 2);
        colEnd = Math.min(arr.size.x, colStart + Math.ceil(wrapRect.width / cellW) + 4);
      }catch(e){
        console.warn('TanStack virtualization failed, falling back:', e);
        // Fallback to simple virtualization
        const scrollTop = gridWrap?.scrollTop||0;
        const visibleRows = Math.max(1, Math.ceil(wrapRect.height / cellH) + 2);
        rowStart = Math.max(0, Math.floor(scrollTop / cellH));
        rowEnd = Math.min(arr.size.y, rowStart + visibleRows);
        colStart = 0;
        colEnd = arr.size.x;
      }
    } else {
      // Fallback to simple virtualization if TanStack not available
      const scrollTop = gridWrap?.scrollTop||0;
      const visibleRows = Math.max(1, Math.ceil(wrapRect.height / cellH) + 2);
      rowStart = Math.max(0, Math.floor(scrollTop / cellH));
      rowEnd = Math.min(arr.size.y, rowStart + visibleRows);
      colStart = 0;
      colEnd = arr.size.x;
    }
    for(let i=colStart;i<colEnd;i++){
      const th=document.createElement('th'); th.textContent=colNameFromIndex(i); th.style.position='relative';
      const w=getColWidth(i); th.style.minWidth=w+'px'; th.style.width=w+'px'; th.style.maxWidth=w+'px';
      // Resizer handle (Google Sheets-like)
      const grip=document.createElement('div');
      grip.style.position='absolute'; grip.style.right='-3px'; grip.style.top='0'; grip.style.width='6px'; grip.style.height='100%';
      grip.style.cursor='col-resize'; grip.style.userSelect='none'; grip.title='Resize column';
      th.appendChild(grip);
      let resizing=false, startX=0, startW=w;
      const onMove=(e)=>{
        if(!resizing) return; const dx=(e.clientX||0)-startX; const nw=startW+dx; setColWidth(i,nw);
        const cw=getColWidth(i); th.style.minWidth=cw+'px'; th.style.width=cw+'px'; th.style.maxWidth=cw+'px';
        // Apply to visible cells of this column at current layer
        document.querySelectorAll(`td.cell[data-x="${i}"][data-z="${getZLayer()}"]`).forEach(td=>{ td.style.minWidth=cw+'px'; td.style.width=cw+'px'; td.style.maxWidth=cw+'px'; });
      };
      const onUp=()=>{ if(!resizing) return; resizing=false; window.removeEventListener('mousemove',onMove,true); window.removeEventListener('mouseup',onUp,true); };
      grip.addEventListener('mousedown',(e)=>{ e.preventDefault(); e.stopPropagation(); resizing=true; startX=e.clientX||0; startW=getColWidth(i); window.addEventListener('mousemove',onMove,true); window.addEventListener('mouseup',onUp,true); }, true);
      cols.appendChild(th);
    }
    for(let r=rowStart;r<rowEnd;r++){
      const tr=document.createElement('tr');
      const h=document.createElement('th'); h.textContent=r+1; tr.appendChild(h);
      for(let c=colStart;c<colEnd;c++){
        const td=document.createElement('td'); td.className='cell'; td.dataset.x=c; td.dataset.y=r; td.dataset.z=getZLayer();
        // Apply fixed width with per-column override
        const cw=getColWidth(c); td.style.minWidth=cw+'px'; td.style.width=cw+'px'; td.style.maxWidth=cw+'px';
        const cell=getCell(arr.id,{x:c,y:r,z:getZLayer()}); 
        td.textContent=cell?.value??''; 
        td.title=cell?.formula||'';
        // Parse emojis with Twemoji
        if(typeof twemoji !== 'undefined' && td.textContent) {
          try{ twemoji.parse(td, {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
        }
        // START FIX: Add note and onClick rendering to main sheet build
        const hasNote = cell?.meta?.noteText;
        if (hasNote) {
          const tooltip = document.createElement('div');
          tooltip.className = 'note-tooltip note-visible';
          tooltip.textContent = cell.meta.noteText;
          td.style.position = 'relative';
          td.appendChild(tooltip);
          td.classList.add('intro-cell');
        }
        if (cell?.meta?.onClick) {
          td.classList.add('clickable');
        }
        // END FIX
        
        // Add styling data attributes for generated cells
        if(cell?.meta?.generated) {
          td.setAttribute('data-generated', 'true');
          if(cell.formula) {
            td.setAttribute('data-anchor', 'true');
          }
        }
        td.onmousedown=(e)=>{ 
          const wrap = document.querySelector('#sheet .grid-wrap');
          const wasTop = wrap ? wrap.scrollTop : 0;
          const wasLeft = wrap ? wrap.scrollLeft : 0;
          window.__awaiting2DClick = true;
          Actions.setSelection(arr.id,{x:c,y:r,z:getZLayer()}, null, '2d'); 
          try{ UI.updateFocusChip?.(); }catch{}
          dragStart={arrayId:arr.id, x:c, y:r, z:getZLayer()}; 
          try{ window.__last2DCell = {arrId:arr.id, x:c, y:r, z:getZLayer()}; }catch{}
          // Keep scroll stable during drag begin
          try{ if(wrap){ wrap.scrollTop = wasTop; wrap.scrollLeft = wasLeft; } }catch{}
          // Do not prevent default, so click/dblclick events still fire
        };
        td.onmouseenter=(e)=>{ 
          if(dragStart && e.buttons&1 && dragStart.arrayId===arr.id){ 
            const wrap = document.querySelector('#sheet .grid-wrap');
            const wasTop = wrap ? wrap.scrollTop : 0;
            const wasLeft = wrap ? wrap.scrollLeft : 0;
            Actions.setSelectionRange(arr.id, {x:dragStart.x,y:dragStart.y,z:dragStart.z}, {x:c,y:r,z:getZLayer()}); 
            // Maintain scroll after range update
            try{ if(wrap){ wrap.scrollTop = wasTop; wrap.scrollLeft = wasLeft; } }catch{}
          } 
        };
        td.onmouseup=()=>{ dragStart=null; window.__awaiting2DClick = false; };
        // Click to run onClick (single click only) and dblclick to edit always
        td.onclick=(e)=>{
          // Ensure selection remains
          Actions.setSelection(arr.id,{x:c,y:r,z:getZLayer()}, null, '2d'); 
          window.__awaiting2DClick = false;
          // Click/dblclick disambiguation: schedule single-click, cancel on second click
          const key = `${arr.id}:${c},${r},${getZLayer()}`;
          if(window.__sheetClickTimers?.has?.(key)){
            try{ clearTimeout(window.__sheetClickTimers.get(key)); window.__sheetClickTimers.delete(key);}catch{}
            e.preventDefault(); e.stopPropagation();
            setTimeout(()=>{ try{ openEditor(); }catch{} }, 0);
            return;
          }
          if(!window.__sheetClickTimers){ window.__sheetClickTimers = new Map(); }
          const timerId = setTimeout(()=>{
            try{ window.__sheetClickTimers.delete(key); }catch{}
            const clickedCell = getCell(arr.id,{x:c,y:r,z:getZLayer()});
            let actionRaw = clickedCell?.meta?.onClick ? String(clickedCell.meta.onClick).trim() : '';
            if(!actionRaw){ try{ if(!window.__INTRO_FIRED) actionRaw = '=STARTINTROEXPERIENCE()'; }catch{} }
            if(!actionRaw) return;
            try{
              let formula = actionRaw;
              try{ if(!window.__INTRO_FIRED && !formula) formula = '=STARTINTROEXPERIENCE()'; }catch{}
              if(formula.startsWith('B64:')){ try{ formula = atob(formula.slice(4)); }catch{} }
              else { const colon=formula.indexOf(':'); if(colon>0 && /^\d+$/.test(formula.slice(0,colon))){ const enc=formula.slice(colon+1); try{ formula = atob(enc); }catch{} } }
              if(!formula.startsWith('=')) formula = '=' + formula;
              const tx = Write.start('onclick.click','Click action');
              Formula.runOnceAt({arrId:arr.id,x:c,y:r,z:getZLayer()}, formula, tx);
              Write.commit(tx);
            }catch(err){ console.warn('onclick failed', err); }
          }, 220);
          window.__sheetClickTimers.set(key, timerId);
        };
        td.ondblclick=(e)=>{ e.preventDefault(); e.stopPropagation(); window.__awaiting2DClick = false; Actions.setSelection(arr.id,{x:c,y:r,z:getZLayer()}, null, '2d'); try{ window.__last2DCell = {arrId:arr.id, x:c, y:r, z:getZLayer()}; }catch{} setTimeout(()=>openEditor(),0); };
        tr.appendChild(td);
      }
      rows.appendChild(tr);
    }
    // Set spacer padding to simulate offscreen rows (single spanning cells; no pointer capture)
    try{
      const tbody = rows;
      const before = document.createElement('tr');
      const btd = document.createElement('td');
      btd.colSpan = (arr.size.x + 1);
      btd.style.padding='0'; btd.style.border='0'; btd.style.height = (rowStart*cellH)+'px';
      btd.style.pointerEvents='none'; btd.style.lineHeight='0'; btd.style.fontSize='0';
      before.appendChild(btd);
      const after = document.createElement('tr');
      const atd = document.createElement('td');
      atd.colSpan = (arr.size.x + 1);
      atd.style.padding='0'; atd.style.border='0'; atd.style.height = ((arr.size.y-rowEnd)*cellH)+'px';
      atd.style.pointerEvents='none'; atd.style.lineHeight='0'; atd.style.fontSize='0';
      after.appendChild(atd);
      tbody.prepend(before); tbody.appendChild(after);
    }catch{}
    // Restore scroll positions to prevent perceived offset while dragging
    try{ if(gridWrap){ gridWrap.scrollTop = prevScrollTop; gridWrap.scrollLeft = prevScrollLeft; } }catch{}

    // Re-render on scroll for virtualization window
    try{
      const wrap = document.querySelector('#sheet .grid-wrap');
      if(wrap && !wrap._virtWired){
        wrap._virtWired=true;
        wrap.addEventListener('scroll', (e)=>{
          const tgt = e.target; const prev = tgt._lastVT||0; const now = Date.now();
          if(now - prev > 50){ tgt._lastVT = now; try{ UI.renderSheet?.(); }catch{} }
        }, {passive:true});
      }
    }catch{}
    try{ highlightSheetCell(); }catch(e){ console.warn('highlightSheetCell failed (deferred)', e); setTimeout(()=>{ try{ highlightSheetCell(); }catch(_){} }, 0); }
    // sync 3D focus Z if selection exists
    const s=Store.getState().selection; if(s.arrayId&&s.focus&&s.focus.z!==getZLayer()) Actions.setSelection(s.arrayId,{...s.focus,z:getZLayer()});
  }
  function renderSheetCell(arr,x,y,z){ 
    const td=document.querySelector(`td.cell[data-x="${x}"][data-y="${y}"][data-z="${z}"]`); 
    if(!td) return; 
    const cell=getCell(arr.id,{x,y,z}); 
    const disp=(cell?.meta?.displayText!==undefined)?cell.meta.displayText:(cell?.value??''); 
    td.textContent=disp; 
    td.title=cell?.formula||'';
    // Parse emojis with Twemoji
    if(typeof twemoji !== 'undefined' && td.textContent) {
      try{ twemoji.parse(td, {folder: 'svg', ext: '.svg', className: 'emoji'}); }catch{}
    }

    // --- START NEW COLOR LOGIC ---
    try{
      const color = cell?.meta?.color;
      if(color){
        td.style.backgroundColor = color;
        const hex = String(color||'').replace('#','');
        const r = parseInt(hex.substring(0,2),16)|0;
        const g = parseInt(hex.substring(2,4),16)|0;
        const b = parseInt(hex.substring(4,6),16)|0;
        const brightness = (r*299 + g*587 + b*114) / 1000;
        td.style.color = brightness > 128 ? '#1f2937' : '#ffffff';
      } else {
        td.style.backgroundColor = '';
        td.style.color = '';
      }
    }catch{}
    // --- END NEW COLOR LOGIC ---
    
    // Note tooltip (2D-only, simple blue hover card like reference)
    const hasNote = cell?.meta?.noteText;
    // remove existing tooltip
    td.querySelector('.note-tooltip')?.remove();
    if(hasNote){
      const tooltip=document.createElement('div');
      tooltip.className='note-tooltip note-visible';
      tooltip.textContent=cell.meta.noteText;
      td.style.position='relative';
      td.appendChild(tooltip);
      td.classList.add('intro-cell');
      console.log('renderSheetCell: tooltip added', {x,y,z,text:cell.meta.noteText});
      // Intro hack removed; rely on metadata-bound onClick
    } else {
      td.classList.remove('intro-cell');
    }
    
    // ONCLICK runtime: attach lightweight handler
    if(cell?.meta?.onClick){
      console.log('renderSheetCell: onClick bound', {x,y,z, action: cell.meta.onClick});
      td.classList.add('clickable');
      td.onclick = async (e)=>{
        e.preventDefault(); e.stopPropagation();
        if(cell.meta.onClickBusy) return;
        cell.meta.onClickBusy = true; td.classList.add('pending');
        try{
          const tx = Write.start('onclick','Click action');
          const fresh = UI.getCell(arr.id,{x,y,z});
          const actionRaw = String(fresh?.meta?.onClick||'').trim();
          let formula = actionRaw || '';
          // Fallback: if intro hasn't fired yet, force onboarding
          try{ if(!window.__INTRO_FIRED && !formula) formula = '=STARTINTROEXPERIENCE()'; }catch{}
          // Accept B64:ENC or ARRID:ENC (defensive for earlier stamps)
          if(formula.startsWith('B64:')){
            try{ formula = atob(formula.slice(4)); }catch{}
          } else {
            const colon = formula.indexOf(':');
            if(colon>0 && /^\d+$/.test(formula.slice(0,colon))){
              const enc = formula.slice(colon+1);
              try{ formula = atob(enc); }catch{}
            }
          }
          if(!formula.startsWith('=')) formula = `=${formula}`;
          console.log('onClick: executing', {formula});
          // Execute without stamping into the cell
          Formula.runOnceAt({arrId:arr.id,x,y,z}, formula, tx);
          Write.commit(tx);
          // Intro: if overlay is visible, collapse and hide now
          UI.debugIntroState?.('onclick-commit');
          const didHide = window.UI?.hideIntroOverlay?.();
          if(didHide){ try{ window.__INTRO_FIRED = true; }catch{} console.log('Intro: collapsed via hideIntroOverlay'); window.UI?.triggerIntroCollapse?.(); UI.debugIntroState?.('onclick-collapsed'); }
          else { UI.kickIntroSequence?.('onclick-fallback'); }
        }catch(err){ console.warn('onClick failed', err); }
        finally{ cell.meta.onClickBusy = false; td.classList.remove('pending'); }
      };
    } else {
      td.onclick = td.onclick || null;
    }
    // Always allow double-click to open editor (even if onClick exists)
    td.ondblclick = (e)=>{ e.preventDefault(); e.stopPropagation(); window.__awaiting2DClick = false; Actions.setSelection(arr.id,{x,y,z}, null, '2d'); try{ window.__last2DCell = {arrId:arr.id, x, y, z}; }catch{} setTimeout(()=>openEditor(),0); };
    // Add styling data attributes for generated cells
    if(cell?.meta?.generated) {
      td.setAttribute('data-generated', 'true');
      // Check if this is an anchor (has formula)
      if(cell.formula) {
        td.setAttribute('data-anchor', 'true');
      } else {
        td.removeAttribute('data-anchor');
      }
    } else {
      td.removeAttribute('data-generated');
      td.removeAttribute('data-anchor');
    }
  }
  function highlightSheetCell(){ 
    document.querySelectorAll('td.cell.sel').forEach(td=>td.classList.remove('sel'));
    const s=Store.getState().selection; if(!s.focus) return; 
    if(s.range){
      // highlight range
      for(let y=s.range.y1;y<=s.range.y2;y++){
        for(let x=s.range.x1;x<=s.range.x2;x++){
          const td=document.querySelector(`td.cell[data-x="${x}"][data-y="${y}"][data-z="${s.range.z}"]`);
          if(td) td.classList.add('sel');
        }
      }
    } else {
      const td=document.querySelector(`td.cell[data-x="${s.focus.x}"][data-y="${s.focus.y}"][data-z="${Store.getState().ui.zLayer}"]`); 
      if(td){
        td.classList.add('sel');
        // Manage focusability for keyboard users
        const oldSel = document.querySelector('td.cell[tabindex="0"]'); if(oldSel) oldSel.setAttribute('tabindex','-1');
        td.setAttribute('tabindex','0');
      }
    }
  }
  function scrollSheetToSelection(){ const s=Store.getState().selection; if(!s.focus) return; const td=document.querySelector(`td.cell[data-x="${s.focus.x}"][data-y="${s.focus.y}"][data-z="${Store.getState().ui.zLayer}"]`); if(td) td.scrollIntoView({block:'nearest',inline:'nearest'}); }

  function openEditor(initial){ 
    const s=Store.getState().selection; 
    let focus = s.focus; let arrId = s.arrayId;
    if(!focus){
      try{ const lc=window.__last2DCell; if(lc){ focus={x:lc.x,y:lc.y,z:lc.z}; arrId=lc.arrId; } }catch{}
    }
    if(!focus) return; 
    const arr=Store.getState().arrays[arrId]; 
    const cell=getCell(arrId, focus);
    const baseText = (cell.formula!=null && cell.formula!=='') ? cell.formula : String(cell.value??'');
    const edit=els.direct;
    
    // Position based on last interaction type
    if(Store.getState().ui?.lastInteraction === '2d'){
      // Position near 2D cell if available
      let td=document.querySelector('td.cell.sel');
      if(!td && focus){ td=document.querySelector(`td.cell[data-x="${focus.x}"][data-y="${focus.y}"][data-z="${focus.z}"]`); }
      if(td){ 
        const r=td.getBoundingClientRect(); 
        edit.style.left=r.left+'px'; 
        edit.style.top=(r.top-28)+'px'; 
      } else { 
        // Fallback to sheet position
        const sheet=document.getElementById('sheet'); 
        const r=sheet.getBoundingClientRect(); 
        edit.style.left=(r.left+12)+'px'; 
        edit.style.top=(r.top+36)+'px'; 
      }
    } else {
      // Position in 3D viewport area for 3D interactions
      const canvas=document.getElementById('view');
      if(canvas){
        const r=canvas.getBoundingClientRect();
        edit.style.left=(r.left + r.width/2 - 100)+'px'; // Center horizontally
        edit.style.top=(r.top + 60)+'px'; // Near top of 3D view
      } else {
        // Fallback
        edit.style.left='50%'; 
        edit.style.top='100px';
      }
    }
    
    // Ensure the editor is visible and styled above the 3D canvas
    edit._openedAt = Date.now();
    edit.style.display='block'; 
    edit.style.zIndex='10005';
    edit.style.opacity='1';
    edit.style.pointerEvents='auto';
    edit.value = (initial!==undefined && initial!==null) ? (initial==='='? '=' : initial) : baseText;
    els.fx.value = edit.value; // realtime sync start
    try{ const h=document.getElementById('fxHighlight'); if(h){ h.scrollTop=h.scrollHeight; } }catch{}
    edit.focus(); 
    if(!initial) edit.select();
  }
  function commitEditor(){ 
    const s=Store.getState().selection; 
    if(!s.focus){ 
      els.direct.style.display='none'; 
      return; 
    } 
    const arr=Store.getState().arrays[s.arrayId]; 
    const val=els.direct.value.trim(); 
    const anchor={arrId:s.arrayId,...s.focus}; 
    
    if(val.startsWith('=')) { 
      Formula.setFormula(anchor, val);
      const tx = Write.start('user.directEdit','User direct formula edit');
      Formula.executeAt(anchor, undefined, tx);
      Write.commit(tx);
    } else { 
      const tx = Write.start('user.directValue','User direct value edit');
      Write.set(tx, s.arrayId, s.focus, { value: val, formula: null });
      Write.commit(tx);
    } 
    
    els.direct.style.display='none'; 
    els.fx.value = ''; // Clear formula box
    updateFocusChip(); // Refresh UI
  }
  // Global escapes: Enter (when editor focused) commits then hides; Escape cancels and hides; clicking outside hides
  document.addEventListener('keydown',(e)=>{
    const edit=els.direct; if(edit.style.display!=='block') return;
    if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); commitEditor(); }
    if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); edit.style.display='none'; els.fx.value=''; }
  }, true);
  // Hide editor on any sheet click when not double-clicking to re-open
  document.getElementById('sheet')?.addEventListener('mousedown',(e)=>{
    const edit=els.direct; 
    if(edit.style.display==='block'){
      const justOpened = (Date.now() - (edit._openedAt||0)) < 200;
      if(!justOpened){ edit.style.display='none'; }
    }
  }, true);
  els.direct.addEventListener('input',()=>{ 
    els.fx.value = els.direct.value; 
    try{ els.fx.dispatchEvent(new Event('input')); }catch{} 
    updateAutocomplete(els.direct);
    try{ highlightFxRefs(els.direct.value); }catch{}
  });
  els.direct.addEventListener('keydown',e=>{ 
    if(autocompleteVisible){
      if(e.key === 'ArrowDown'){
        e.preventDefault();
        selectedSuggestion = Math.min(selectedSuggestion + 1, autocompleteDiv.children.length - 1);
        updateAutocompleteHighlight();
        return;
      }
      if(e.key === 'ArrowUp'){
        e.preventDefault();
        selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
        updateAutocompleteHighlight();
        return;
      }
      if(e.key === 'Tab' || e.key === 'Enter'){
        e.preventDefault();
        const hadSelection = (selectedSuggestion >= 0);
        if(hadSelection){
          const allFunctions = mergeDocsAndComputeDeps();
          const context = getAutocompleteContext(e.target);
          if(context){
            const matches = allFunctions.filter(fn => 
              fn.name.toLowerCase().includes(context.partial.toLowerCase())
            );
            if(matches[selectedSuggestion]){
              applyAutocomplete(e.target, matches[selectedSuggestion]);
            }
          }
          // Do NOT commit if a suggestion was chosen; keep editor open
          hideAutocomplete();
          return;
        } else {
          // No suggestion selected: treat Enter/Tab normally
        hideAutocomplete();
        if(e.key === 'Enter') commitEditor();
        return;
        }
      }
      if(e.key === 'Escape'){
        e.preventDefault();
        hideAutocomplete();
        return;
      }
    } else {
      if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); commitEditor(); return; }
      if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); els.direct.style.display='none'; els.fx.value=''; return; }
    }
  });
  // Slide sheet to top when soft keyboard likely shows (touch-only, triggered from touch focus)
  function slideSheetTop(){
    if(!document.body.classList.contains('touch')) return;
    // Require that the last interaction was a touch to avoid desktop Enter key causing movement
    if(typeof lastPointerType!=='string' || lastPointerType!=='touch') return;
    const sheet=document.getElementById('sheet'); if(!sheet) return;
    // Only slide if not already pinned top
    if(sheet.dataset.pinnedTop==='1') return;
    sheet.style.transition='transform .35s ease, top .35s ease, bottom .35s ease';
    sheet.style.top='8px'; sheet.style.bottom='auto'; sheet.style.left='50%'; sheet.style.transform='translateX(-50%)';
    sheet.dataset.pinnedTop='1';
  }
  els.fx.addEventListener('focus', slideSheetTop);
  els.direct.addEventListener('focus', slideSheetTop);
  
  // Also handle Enter in the formula textbox
  // Autocomplete system
  let autocompleteDiv = null;
  let autocompleteVisible = false;
  let selectedSuggestion = -1;

  // Move mergeDocsAndComputeDeps to accessible scope
  function mergeDocsAndComputeDeps(){
    const docs=[
      {name:'GET_GLOBAL',tags:'GLOBAL',syntax:'=GET_GLOBAL("key")',params:'key: string identifier for global data',desc:'Retrieves value from global key-value store. Automatically tracks dependencies for reactive updates.'},
      {name:'SET_GLOBAL',tags:'GLOBAL',syntax:'=SET_GLOBAL("key", value)',params:'key: string identifier · value: any data to store',desc:'Writes value to global store and triggers re-computation of all dependent cells.'},
      {name:'ON_EVENT',tags:'EVENTS',syntax:'=ON_EVENT("eventName", "actionFormula")',params:'eventName: string event identifier · actionFormula: formula to execute when event fires',desc:'Registers an event listener that executes a formula when the specified event is fired.'},
      {name:'FIRE_EVENT',tags:'EVENTS',syntax:'=FIRE_EVENT("eventName"[, payload])',params:'eventName: string event identifier · payload: optional data to pass to listeners',desc:'Broadcasts an event to all registered listeners, optionally passing payload data.'},
      {name:'ARRAY',tags:'DATA',syntax:'=ARRAY(source)',params:'source: dimensions (w,h,d[,fill]), "list"/value1,value2... (default), "set"/value1,value2... (clears area), "csv"/"1,2;3,4", or named block',desc:'Enhanced: defaults to list mode, adds set mode for clearing, supports explicit modes.'},
      {name:'GET',tags:'DATA',syntax:'=GET(refOrRange)',params:'refOrRange: single cell or range',desc:'Returns the current value(s) as a block.'},
      {name:'SET',tags:'DATA',syntax:'=SET(target, valueOrBlock[, overwrite])',params:'target: ref/range · valueOrBlock: scalar/block · overwrite: 0/1',desc:'Direct write helper with size/overwrite checks.'},
      {name:'TRANSPOSE',tags:'DATA',syntax:'=TRANSPOSE(input, planeFlag[, reverse])',params:'input: block · planeFlag: 0=X↔Y,1=X↔Z,2=Y↔Z · reverse: 0/1',desc:'Swaps axes of a block and writes result at the anchor.'},
      {name:'OFFSET',tags:'NAVIGATION',syntax:'=OFFSET([baseRef], dx[, dy[, dz]])',params:'baseRef: optional reference cell (default: anchor) · dx,dy,dz: relative offsets',desc:'Excel-style OFFSET: retrieves value from relative position without writing.'},
      {name:'IF',tags:'LOGIC',syntax:'=IF(condition, then[, else])',params:'condition: comparisons with refs/values · then/else: value or call',desc:'Branching evaluation with proper dependency capture.'},
      {name:'AND',tags:'LOGIC',syntax:'=AND(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical AND.'},
      {name:'OR',tags:'LOGIC',syntax:'=OR(a,b[, ...])',params:'booleans/scalars (coerced)',desc:'Logical OR.'},
      {name:'ADD',tags:'MATH',syntax:'=ADD(a[, b[, ...]])',params:'numbers or blocks (elementwise)',desc:'Sum (elementwise for blocks).'},
      {name:'MUL',tags:'MATH',syntax:'=MUL(a[, b[, ...]])',params:'numbers or blocks',desc:'Product (elementwise).'},
      {name:'CREATE',tags:'ACTION',syntax:'=CREATE(x,y,z[, "Name"[,"Id"]])',params:'dimensions (ints), optional nickname, optional explicit ID',desc:'Spawns a new array (respecting optional explicit id).'},
      {name:'DO',tags:'ACTION',syntax:'=DO(f1[, f2[, ...]])',params:'string formulas like "=SET(...)"',desc:'Runs sub-formulas in order and returns the last.'},
      {name:'SELF',tags:'NAVIGATION',syntax:'=SELF()',params:'—',desc:'Returns absolute @[x,y,z,arrId] of the host cell.'},
      {name:'DELETE',tags:'ACTION',syntax:'=DELETE(...targets)',params:'targets: array ids, refs, or "self"',desc:'Deletes arrays by id or ref; default self.'},
      {name:'COPY',tags:'ACTION IO',syntax:'=COPY(text)',params:'string text',desc:'Writes text to clipboard and shows a success toast.'},
      {name:'FOCUS_SET',tags:'ACTION',syntax:'=FOCUS_SET(content) or =FOCUS_SET(mode, content)',params:'mode: "text"|"formula"|"clipboard" · content: data to set/copy',desc:'Writes to focused cell or copies to clipboard (with toast).'}
    ];
    const globalFn = (typeof window!=='undefined' && window.Fn) ? window.Fn : (typeof Fn!=='undefined'? Fn : {});
    const allNames = Object.keys(globalFn||{});
    const docsByName = new Map(docs.map(d => [d.name, {...d}]));
    allNames.forEach(name=>{
      const meta = globalFn[name] || {};
      if(!docsByName.has(name)){
        const tagsRaw = meta.tags;
        const tagsArr = Array.isArray(tagsRaw) ? tagsRaw : (tagsRaw instanceof Set ? Array.from(tagsRaw) : []);
        const tagStr = (tagsArr && tagsArr.length) ? tagsArr.join(',') : 'OTHER';
        docsByName.set(name, {name, tags: tagStr, syntax: meta.syntax || `=${name}()`, params: meta.params || '', desc: meta.desc || ''});
      }
    });
    return Array.from(docsByName.values()).sort((a,b)=> a.name.localeCompare(b.name));
  }
  
  function createAutocomplete(){
    if(autocompleteDiv) return autocompleteDiv;
    autocompleteDiv = document.createElement('div');
    autocompleteDiv.id = 'autocomplete';
    autocompleteDiv.style.cssText = `
      position: absolute; z-index: 10010; background: #ffffff; border: 1px solid #e5e7eb;
      border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); max-height: 200px;
      overflow-y: auto; display: none; font-family: 'Roboto Mono', monospace; font-size: 12px;
    `;
    document.body.appendChild(autocompleteDiv);
    return autocompleteDiv;
  }

  function showAutocomplete(input, suggestions){
    const div = createAutocomplete();
    if(suggestions.length === 0){ hideAutocomplete(); return; }
    
    div.innerHTML = suggestions.map((fn, idx) => 
      `<div class="ac-item" data-idx="${idx}" style="padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #f3f4f6; ${idx === selectedSuggestion ? 'background: #f3f4f6;' : ''}">${fn.name}<span style="color: #6b7280; margin-left: 8px; font-size: 10px;">${fn.tags}</span></div>`
    ).join('');
    
    const rect = input.getBoundingClientRect();
    div.style.left = rect.left + 'px';
    div.style.top = (rect.bottom + 2) + 'px';
    div.style.width = Math.max(200, rect.width) + 'px';
    div.style.display = 'block';
    autocompleteVisible = true;
    
    // Click handlers
    div.querySelectorAll('.ac-item').forEach((item, idx) => {
      item.addEventListener('mouseenter', () => { selectedSuggestion = idx; updateAutocompleteHighlight(); });
      item.addEventListener('click', () => {
        applyAutocomplete(input, suggestions[idx]);
        hideAutocomplete();
      });
    });
  }

  function hideAutocomplete(){
    if(autocompleteDiv) autocompleteDiv.style.display = 'none';
    autocompleteVisible = false;
    selectedSuggestion = -1;
  }

  function applyAutocomplete(input, fn){
    const val = input.value;
    const pos = input.selectionStart || val.length;
    // Find the start of the current function name
    let start = pos;
    while(start > 0 && /[A-Z_0-9]/i.test(val[start-1])) start--;
    // Check if we're after = or ,
    let prefix = '';
    if(start > 0 && val[start-1] === '=') prefix = '=';
    else if(start > 0 && val[start-1] === ',') prefix = '';
    
    const before = val.slice(0, start);
    const after = val.slice(pos);
    const insert = `${fn.name}(`;
    input.value = before + insert + after;
    const newPos = before.length + insert.length;
    input.setSelectionRange(newPos, newPos);
    input.focus();
  }

  function getAutocompleteContext(input){
    const val = input.value;
    const pos = input.selectionStart || val.length;
    
    // Look backwards to find = or ,
    let i = pos - 1;
    let foundTrigger = false;
    let triggerPos = -1;
    
    while(i >= 0){
      const ch = val[i];
      if(ch === '=' || ch === ','){
        foundTrigger = true;
        triggerPos = i;
        break;
      } else if(ch === ')' || ch === '('){
        break; // Stop at function boundaries
      }
      i--;
    }
    
    if(!foundTrigger) return null;
    
    // Extract the partial function name after the trigger
    const afterTrigger = val.slice(triggerPos + 1, pos);
    const match = afterTrigger.match(/^\s*([A-Z_][A-Z0-9_]*)/i);
    if(!match) return null;
    
    return {
      trigger: val[triggerPos],
      partial: match[1],
      start: triggerPos + 1 + afterTrigger.indexOf(match[1]),
      end: pos
    };
  }

  function updateAutocomplete(input){
    const context = getAutocompleteContext(input);
    if(!context || context.partial.length < 1){
      hideAutocomplete();
      return;
    }
    
    const allFunctions = mergeDocsAndComputeDeps();
    const matches = allFunctions.filter(fn => 
      fn.name.toLowerCase().includes(context.partial.toLowerCase())
    ).slice(0, 8); // Limit to 8 suggestions
    
    if(matches.length > 0){
      showAutocomplete(input, matches);
    } else {
      hideAutocomplete();
    }
  }

  els.fx.addEventListener('input', (e) => {
    updateAutocomplete(e.target);
    try{ highlightFxRefs(els.fx.value); }catch{}
  });

  els.fx.addEventListener('keydown',e=>{ 
    if(autocompleteVisible){
      if(e.key === 'ArrowDown'){
        e.preventDefault();
        selectedSuggestion = Math.min(selectedSuggestion + 1, autocompleteDiv.children.length - 1);
        updateAutocompleteHighlight();
        return;
      }
      if(e.key === 'ArrowUp'){
        e.preventDefault();
        selectedSuggestion = Math.max(selectedSuggestion - 1, -1);
        updateAutocompleteHighlight();
        return;
      }
      if(e.key === 'Tab' || e.key === 'Enter'){
        e.preventDefault();
        const hadSelection = (selectedSuggestion >= 0);
        if(hadSelection){
          const allFunctions = mergeDocsAndComputeDeps();
          const context = getAutocompleteContext(e.target);
          if(context){
            const matches = allFunctions.filter(fn => 
              fn.name.toLowerCase().includes(context.partial.toLowerCase())
            );
            if(matches[selectedSuggestion]){
              applyAutocomplete(e.target, matches[selectedSuggestion]);
          }
        }
          hideAutocomplete();
          return;
        } else {
        hideAutocomplete();
        if(e.key === 'Enter') els.apply.click();
        return;
        }
      }
      if(e.key === 'Escape'){
        e.preventDefault();
        hideAutocomplete();
        return;
      }
    } else {
      if(e.key==='Enter'){ e.preventDefault(); e.stopPropagation(); els.apply.click(); els.fx.blur(); return; }
      if(e.key==='Escape'){ e.preventDefault(); e.stopPropagation(); els.fx.value=''; els.fx.blur(); return; }
    }
  });

  function updateAutocompleteHighlight(){
    if(!autocompleteDiv) return;
    autocompleteDiv.querySelectorAll('.ac-item').forEach((item, idx) => {
      item.style.background = (idx === selectedSuggestion) ? '#f3f4f6' : '';
    });
  }

  // Hide autocomplete when clicking outside
  document.addEventListener('click', (e) => {
    if(autocompleteVisible && !autocompleteDiv.contains(e.target) && e.target !== els.fx && e.target !== els.direct){
      hideAutocomplete();
    }
  });

  function updateStatus(t){ document.getElementById('statusChip').textContent=t; }

  // Lightweight A1 highlighter for fx bar: case-insensitive, bounds-validated against current array
  function highlightFxRefs(text){
    const fx = document.getElementById('fx');
    const hl = document.getElementById('fxHighlight');
    if(!fx || !hl) return;
    const s=Store.getState().selection; if(!s?.arrayId||!s.focus) { hl.innerHTML=''; return; }
    const arr=Store.getState().arrays[s.arrayId]; if(!arr){ hl.innerHTML=''; return; }
    const W=arr.size.x, H=arr.size.y, D=arr.size.z;
    const esc=(s)=> s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const tokens=[]; const re=/([A-Za-z]+\d+(?:[\u03b1-\u03c9])?\^?-?\d*)/g; let last=0, m;
    while((m=re.exec(text))){
      const raw=m[0]; const start=m.index; const end=start+raw.length; const before=esc(text.slice(last,start));
      tokens.push(before);
      // validate as cell address (case-insensitive letters+digits, optional greek)
      const mm=/^([A-Za-z]+)(\d+)([\u03b1-\u03c9])?/.exec(raw);
      let good=false;
      if(mm){
        // convert letters to X
        let xx=0; const letters=mm[1].toUpperCase(); for(let i=0;i<letters.length;i++) xx = xx*26 + (letters.charCodeAt(i)-64); xx--;
        const yy=(+mm[2])-1; const G='αβγδεζηθικλμνξοπρστυφχψω'; const zz=mm[3]? G.indexOf(mm[3]) : s.focus.z;
        good = (xx>=0&&xx<W && yy>=0&&yy<H && zz>=0&&zz<D);
      }
      const cls = good? 'ref-ok' : 'ref-bad';
      tokens.push(`<span class="${cls}">${esc(raw)}</span>`);
      last=end;
    }
    tokens.push(esc(text.slice(last)));
    hl.innerHTML = tokens.join('');
  }

  function startDirectTyping(char){
    const s=Store.getState().selection; if(!s.focus) return;
    const edit=els.direct;
    // If editor is already open, insert at caret instead of resetting
    if(edit.style.display==='block'){
      const start=edit.selectionStart ?? edit.value.length;
      const end=edit.selectionEnd ?? start;
      const before=edit.value.slice(0,start);
      const after=edit.value.slice(end);
      edit.value = before + char + after;
      const pos = before.length + char.length;
      edit.setSelectionRange(pos,pos);
      els.fx.value = edit.value; // realtime sync
      edit.focus();
      return;
    }
    // Otherwise, open with initial char
    openEditor(char);
  }

  function startIntroExperience(){
    console.log('UI.startIntroExperience: begin');
    // Make absolutely sure the overlay fades via CSS
    const io=document.getElementById('introOverlay');
    if(io){ io.classList.add('hidden'); }
    // Force class-based collapse and also apply inline fallback for stubborn cases
    // Brief expansion to pass-through layer then collapse to corner to reveal 3D
    try{
      const sheet=document.getElementById('sheet');
      // Animate the header card wipe behind, then collapse without sheet bounce
      const header=document.getElementById('sheetHeaderCard');
      if(header){
        const r=sheet.getBoundingClientRect();
        header.style.left = r.left + 'px';
        header.style.top = (r.top - 10) + 'px';
        header.style.width = r.width + 'px';
        header.style.height = (r.height + 20) + 'px';
        header.classList.add('visible');
        requestAnimationFrame(()=>{ header.classList.add('wipe'); });
        setTimeout(()=>{ triggerIntroCollapse(); }, 280);
        setTimeout(()=>{ header.classList.remove('wipe'); header.classList.remove('visible'); }, 700);
      } else {
        // Fallback
        setTimeout(()=>{ triggerIntroCollapse(); }, 200);
      }
    }catch{}
    if(false){
      const sheet=document.getElementById('sheet');
      if(sheet){
        sheet.classList.remove('intro-max');
        sheet.classList.remove('intro-centered');
        sheet.style.top='';
        sheet.style.left='16px';
        sheet.style.bottom='16px';
        sheet.style.transform='';
        console.log('UI.startIntroExperience: inline collapse applied');
      }
    }
    // Hard fallback: after transition ensure overlay is non-interactive
    setTimeout(()=>{
      const io2=document.getElementById('introOverlay');
      if(io2){ io2.style.pointerEvents='none'; io2.style.opacity='0'; io2.style.display='none'; }
    }, 900);
    showToast('Welcome to celli.os!');
  }

  function ensureIntroNote(){
    try{
      const arr = Store.getState().arrays[1]; if(!arr) return;
      const coord = {x:0,y:2,z:0};
      // Ensure chunk exists
      const chKey0 = keyChunk(...Object.values(chunkOf(coord.x,coord.y,coord.z)));
      let ch0 = arr.chunks[chKey0];
      if(!ch0){ Actions.resizeArrayIfNeeded(arr, coord); ch0 = arr.chunks[chKey0]; }
      let cell = ch0?.cells?.find?.(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
      if(!cell){
        console.log('Intro NOTE not found; creating cell…');
        Actions.setCell(arr.id, coord, '', null, true);
        const ch1 = arr.chunks[chKey0];
        cell = ch1?.cells?.find?.(c=>c.x===coord.x&&c.y===coord.y&&c.z===coord.z);
      }
      if(!cell){ console.warn('ensureIntroNote: creation failed'); return; }
      // Always set NOTE metadata and onClick to ensure visibility and binding
      const tx = Write.start('intro.note','Ensure A3 NOTE');
      try{
        Write.set(tx, arr.id, coord, { 
          value: cell.value ?? '', 
          formula: cell.formula ?? null, 
          meta: { 
            ...(cell.meta||{}), 
            noteText: 'Click Me!', 
            onClick: (cell.meta && cell.meta.onClick) ? cell.meta.onClick : '=STARTINTROEXPERIENCE()'
          } 
        });
      }catch(e){
        // If array 1 is not yet available at write-time, queue for later
        const S=Store.getState();
        const pending=[...(S.pendingMeta||[])];
        pending.push({kind:'note', target:{arrId:1,x:coord.x,y:coord.y,z:coord.z}, meta:{noteText:'Click Me!', onClick:'=STARTINTROEXPERIENCE()'}});
        Store.setState({pendingMeta:pending});
      }
      Write.commit(tx);
      console.log('ensureIntroNote: meta enforced at A3 or queued');
      // Re-render sheet to bind tooltip and onClick reliably
      try{ UI.renderSheet?.(); }catch{}
    }catch(err){ console.warn('ensureIntroNote failed', err); }
  }

  return {init, renderSheet, applyCrystalStyle, renderSheetCell, updateFocusChip, scrollSheetToSelection, openEditor, startDirectTyping, toggleFxPanel, getZLayer, updateStatus, getCell, triggerIntroCollapse, ensureIntroNote, hideIntroOverlay, debugIntroState, kickIntroSequence, startIntroExperience, inspect:(arr,pos)=>{ try{ const ch=arr.chunks[keyChunk(...Object.values(chunkOf(pos.x,pos.y,pos.z)))]; const c=ch?.cells?.find?.(t=>t.x===pos.x&&t.y===pos.y&&t.z===pos.z) || {value:'',formula:''}; const el=document.getElementById('inspect'); if(el) el.textContent=`Array #${arr.id} \"${arr.name}\"\nCell ${A1(pos.x)}${pos.y+1}${greek(pos.z)} @[${pos.x},${pos.y},${pos.z},${arr.id}]\nValue: ${JSON.stringify(c.value)}\nFormula: ${c.formula||''}`; }catch(e){ /* selection panel might be hidden */ } }};
})();

// CRITICAL: Expose UI globally so window.UI?.renderSheetCell works
window.UI = UI;

/* ===========================
   Immediate Launch (No Boot Delay)
=========================== */
(async ()=>{
  try {
    console.log('Starting immediate initialization...');
    
    // Load state if present; otherwise fresh init
    try {
      const has = localStorage.getItem('celliOsState');
      if (has) {
        await Scene.init(document.getElementById('view'));
        await Store.getState().actions.loadState();
        try{ UI.init?.(); UI.renderSheet?.(); }catch{}
      } else {
    await Store.getState().actions.init();
      }
    } catch {
      await Store.getState().actions.init();
    }
    
    console.log('Initialization complete');
  } catch(e) {
    console.error('Initialization failed:', e);
  }
})();
  </script>
  </body>
  </html>
